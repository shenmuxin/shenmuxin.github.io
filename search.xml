<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>step或stl文件转urdf并添加到机械臂上</title>
      <link href="/2024/05/24/step%E6%88%96stl%E6%96%87%E4%BB%B6%E8%BD%ACurdf%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%BA%E6%A2%B0%E8%87%82%E4%B8%8A/"/>
      <url>/2024/05/24/step%E6%88%96stl%E6%96%87%E4%BB%B6%E8%BD%ACurdf%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%BA%E6%A2%B0%E8%87%82%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="【Moveit】step或stl文件转urdf，并添加到机械臂上"><a href="#【Moveit】step或stl文件转urdf，并添加到机械臂上" class="headerlink" title="【Moveit】step或stl文件转urdf，并添加到机械臂上"></a>【Moveit】step或stl文件转urdf，并添加到机械臂上</h1><p>ROS专门提供了一种机器人建模方法——URDF，用来描述机器人外观、性能等各方面属性。所以我们需要将别的描述格式转换成URDF，才能在ROS中使用。</p><h2 id="1-安装sw-urdf-exporter插件"><a href="#1-安装sw-urdf-exporter插件" class="headerlink" title="1. 安装sw_urdf_exporter插件"></a>1. 安装sw_urdf_exporter插件</h2><p>参考官方给出的wiki page：<a href="http://wiki.ros.org/sw_urdf_exporter/Tutorials">sw_urdf_exporter&#x2F;Tutorials</a><br>我们需要给solideworks下载一个插件，插件地址为：<a href="http://wiki.ros.org/sw_urdf_exporter">SolidWorks to URDF Exporter</a>，其github的release为：<a href="https://github.com/ros/solidworks_urdf_exporter/releases">https://github.com/ros/solidworks_urdf_exporter&#x2F;releases</a></p><p>注意solideworks的版本不能过高，这个插件支持solidworks的版本为（<strong>2018SP5～2021</strong>），我们安装的时候可以直接下载这个<code>.exe</code>可执行文件即可，然后默认安装</p><p><img src="https://pic.imgdb.cn/item/66d2f691d9c307b7e940d91f.png" alt="img"></p><h2 id="2-导出urdf"><a href="#2-导出urdf" class="headerlink" title="2. 导出urdf"></a>2. 导出urdf</h2><p>具体的操作可以参考这个视频：<a href="https://www.bilibili.com/video/BV1J54y1D7VE/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">[ROS] Solidworks导出urdf</a></p><p>然后按照教程中的方式进行导出即可。这里我导出了一个夹爪，如下所示</p><p><img src="https://pic.imgdb.cn/item/66d2f659d9c307b7e940b43f.png" alt="img"></p><p>导出的结果会生成一个ROS的功能包，其目录结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── config</span><br><span class="line">│   └── joint_names_gripper_urdf3.yaml</span><br><span class="line">├── export.log</span><br><span class="line">├── launch</span><br><span class="line">│   ├── display.launch</span><br><span class="line">│   └── gazebo.launch</span><br><span class="line">├── meshes</span><br><span class="line">│   └── base_link.STL</span><br><span class="line">├── package.xml</span><br><span class="line">├── textures</span><br><span class="line">└── urdf</span><br><span class="line">    ├── gripper_urdf3.csv</span><br><span class="line">    └── gripper_urdf3.urdf</span><br><span class="line"></span><br><span class="line">5 directories, 9 files</span><br></pre></td></tr></table></figure><p>我们可以使用其<code>display.launch</code>来查看模型是否正确，但是首先得使用<code>catkin_make</code>来进行编译一下，我的显示结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch gripper_urdf display.launch</span><br></pre></td></tr></table></figure><p>打开rviz之后，我们需要手动添加<code>RobotModel</code>，添加完毕后即可显示</p><p><img src="https://pic.imgdb.cn/item/66d2f6aed9c307b7e940f2aa.png" alt="img"></p><p>显示的效果如下：</p><p><img src="https://pic.imgdb.cn/item/66d2f6bdd9c307b7e940ff15.png" alt="img"></p><h2 id="3-将夹爪连接到机械臂上"><a href="#3-将夹爪连接到机械臂上" class="headerlink" title="3. 将夹爪连接到机械臂上"></a>3. 将夹爪连接到机械臂上</h2><p>在导出的功能包中最重要的内容是<code>meshs</code>目录中的<code>.stl</code>文件，这是我们夹爪的模型外观，还有就是<code>urdf</code>目录中的<code>gripper_urdf3.urdf</code>文件，这个是根据<code>.stl</code>模型文件生成的ROS下的URDF机器人描述文件，我们可以复制其中的部分，然后将其粘贴到我们的机械臂的URDF中。</p><p>值得注意的是，<code>link-joint-link</code>是urdf的基本结构，示意如下</p><p><img src="https://pic.imgdb.cn/item/66d2f6d4d9c307b7e941110c.png" alt="img"></p><p>我们在编写<code>joint</code>时，需要指定其类型，一共有这么四种类型可以指定</p><p><img src="https://pic.imgdb.cn/item/66d2f6e7d9c307b7e9411e57.png" alt="img"></p><p>夹爪的基座相对于机械臂是固定的，所以我们在指定夹爪的基座到机械臂的末端的这个<code>joint</code>的时候，一定要选择<code>fixed</code>类型，具体可以这么写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;gripper_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.107&quot;</span> /&gt;</span>#xyz rpy是你的夹爪相对于机械臂的姿态</span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;wrist3_Link&quot;</span> /&gt;</span>#改为你的机械臂的最后一个link</span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;arm_hand_link0&quot;</span> /&gt;</span> #改为你的gripper的base link</span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在定义完这个<code>joint</code>之后，我们就可以将之前生成的URDF中的内容复制到其中，如下是我生成的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;arm_hand_link0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;-2.12153840077004E-06 9.05398824170634E-05 0.0527906490348432&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;0.113713405635938&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;5.00996061302902E-05&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;3.81710319217012E-10&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;2.12328984939388E-10&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;5.98637675434999E-05&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;-3.29078206892533E-08&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;6.10777596321381E-05&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">filename</span>=<span class="string">&quot;package://frcobot_description/meshes/fr5/collision/hand_1.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792156862745098 0.819607843137255 0.933333333333333 1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">filename</span>=<span class="string">&quot;package://frcobot_description/meshes/fr5/collision/hand_1.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_j1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;j1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;j1_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_j2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;j2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;j2_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_j3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;j3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;j3_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_j4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;j4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;j4_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_j5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;j5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;j5_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_j6&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;j6&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;j6_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_ros_control&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>package://</code>需要更改为你存放这个urdf的包的名字，我这里是将其复制了一份，统一放置在了<code>fr_description</code>这个包中了，请将这里修改为你的放置路径。</p><h2 id="4-使用moveit-setup-assistant配置功能包"><a href="#4-使用moveit-setup-assistant配置功能包" class="headerlink" title="4. 使用moveit_setup_assistant配置功能包"></a>4. 使用moveit_setup_assistant配置功能包</h2><p>修改完毕后，我们就可以使用<code>moveit_setup_assisatant</code>来配置或者修改功能包了，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch moveit_setup_assistant setup_assistant.launch</span><br></pre></td></tr></table></figure><p>如下所示，我们能看到夹爪正确地显示了</p><p><img src="https://pic.imgdb.cn/item/66d2f6fcd9c307b7e9412d79.png" alt="img"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="https://blog.csdn.net/hyxxi/article/details/125082120">机械臂urdf模型修改及功能包配置</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Moveit </tag>
            
            <tag> ROS </tag>
            
            <tag> urdf </tag>
            
            <tag> step </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graspnet+Astra2相机实现部署</title>
      <link href="/2024/05/21/Graspnet-Astra2%E7%9B%B8%E6%9C%BA%E5%AE%9E%E7%8E%B0%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/05/21/Graspnet-Astra2%E7%9B%B8%E6%9C%BA%E5%AE%9E%E7%8E%B0%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="graspnet-Astra2相机实现部署"><a href="#graspnet-Astra2相机实现部署" class="headerlink" title="graspnet+Astra2相机实现部署"></a>graspnet+Astra2相机实现部署</h1><p>环境配置</p><ul><li>ubuntu 20.04</li><li>Astra2相机</li><li>cuda 11.0.1</li><li>cudnn v8.9.7</li><li>python 3.8.19</li><li>pytorch 1.7.0</li><li>numpy 1.23.5</li></ul><h2 id="1-graspnet的复现"><a href="#1-graspnet的复现" class="headerlink" title="1. graspnet的复现"></a>1. graspnet的复现</h2><p>具体的复现流程可以参考这篇文章：<a href="https://blog.csdn.net/qq_44940689/article/details/138539714?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22138539714%22,%22source%22:%22qq_44940689%22%7D">Ubuntu20.04下GraspNet复现流程</a></p><p>这里就不再详细介绍了</p><h2 id="2-Astra2的Python-API"><a href="#2-Astra2的Python-API" class="headerlink" title="2. Astra2的Python API"></a>2. Astra2的Python API</h2><p>以下内容都是参考官方文档：<a href="https://vcp.developer.orbbec.com.cn:9001/project-2/doc-70/#h3-linuxpython20sdk20u7F16u8BD1">Orbbec SDK for Python 使用手册</a></p><p>我们首先确认输入到网络中的数据为一个点云数据，再一个我们需要一个rgb图像用来给点云上色，<code>graspnetAPI</code>帮我们写好了从深度图转换到点云的函数<code>create_point_cloud_from_depth_image</code>，所以我们只需要写好从相机的视频流获取深度图片和rgb图片的部分就好了，特别注意的是，大多数相机的rgb的fov是要大于深度图的fov所以我们要对两者进行对齐操作，对齐操作的本质就是在深度图中填充<code>0</code>，使得深度图和rgb图的大小一致。大多数的相机厂商已经提供了具体的示例来演示如何进行对齐，这里就不再赘述。</p><p>这里我直接给出我写的<code>astra2.py</code>，用于获取相机的深度图和rgb图的代码，大家可以参考一下思路</p><p><code>astra2.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyorbbecsdk <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, width=<span class="number">1280</span>, height=<span class="number">720</span>,fps=<span class="number">15</span></span>):</span><br><span class="line">        self.im_width = width</span><br><span class="line">        self.im_height = height</span><br><span class="line">        self.fps = fps</span><br><span class="line">        self.intrinsic = <span class="literal">None</span></span><br><span class="line">        self.scale = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接相机</span></span><br><span class="line">        <span class="comment"># self.connect()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;用于连接相机&quot;&quot;&quot;</span></span><br><span class="line">        self.pipeline = Pipeline()</span><br><span class="line">        config = Config()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># color config</span></span><br><span class="line">        profile_list = self.pipeline.get_stream_profile_list(OBSensorType.COLOR_SENSOR)</span><br><span class="line">        color_profile = profile_list.get_default_video_stream_profile()</span><br><span class="line">        config.enable_stream(color_profile)</span><br><span class="line">        <span class="comment"># depth config</span></span><br><span class="line">        profile_list = self.pipeline.get_stream_profile_list(OBSensorType.DEPTH_SENSOR)</span><br><span class="line">        <span class="keyword">assert</span> profile_list <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        depth_profile = profile_list.get_default_video_stream_profile()</span><br><span class="line">        <span class="keyword">assert</span> depth_profile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;color profile : &#123;&#125;x&#123;&#125;@&#123;&#125;_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(color_profile.get_width(),</span><br><span class="line">                                                   color_profile.get_height(),</span><br><span class="line">                                                   color_profile.get_fps(),</span><br><span class="line">                                                   color_profile.get_format()))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;depth profile : &#123;&#125;x&#123;&#125;@&#123;&#125;_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(depth_profile.get_width(),</span><br><span class="line">                                                   depth_profile.get_height(),</span><br><span class="line">                                                   depth_profile.get_fps(),</span><br><span class="line">                                                   depth_profile.get_format()))</span><br><span class="line">        config.enable_stream(depth_profile)</span><br><span class="line">        <span class="comment"># set synchronize for depth img and color img</span></span><br><span class="line">        config.set_align_mode(OBAlignMode.SW_MODE)</span><br><span class="line">        self.pipeline.enable_frame_sync()</span><br><span class="line">        <span class="comment"># start config</span></span><br><span class="line">        self.pipeline.start(config)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get intrinsic</span></span><br><span class="line">        self.intrinsic = self.get_intrinsic()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">disconnect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;用于断开相机&quot;&quot;&quot;</span></span><br><span class="line">        self.pipeline.stop()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_frame</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;通过流来获取color frame和depth frame&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            frames: FrameSet = self.pipeline.wait_for_frames(<span class="number">200</span>)</span><br><span class="line">            <span class="keyword">if</span> frames <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            color_frame = frames.get_color_frame()</span><br><span class="line">            <span class="keyword">if</span> color_frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            depth_frame = frames.get_depth_frame()</span><br><span class="line">            <span class="keyword">if</span> depth_frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> color_frame != <span class="literal">None</span> <span class="keyword">and</span> depth_frame != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> color_frame, depth_frame</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">frame2data</span>(<span class="params">self, color_frame, depth_frame</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;暂时没用&quot;&quot;&quot;</span></span><br><span class="line">        width = depth_frame.get_width()</span><br><span class="line">        height = depth_frame.get_height()</span><br><span class="line">        scale = depth_frame.get_depth_scale()</span><br><span class="line">        depth_data = np.frombuffer(depth_frame.get_data(), dtype=np.uint16)</span><br><span class="line">        depth_data = depth_data.reshape((height, width))</span><br><span class="line"></span><br><span class="line">        width = color_frame.get_width()</span><br><span class="line">        height = color_frame.get_height()</span><br><span class="line">        color_data = np.asanyarray(color_frame.get_data(), dtype=np.uint16)</span><br><span class="line">        <span class="comment"># color_data = color_data.reshape((height, width, 3))</span></span><br><span class="line">        <span class="keyword">return</span> color_data.astype(np.float32), depth_data.astype(np.float32)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;通过流来获取color data和depth data&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接相机</span></span><br><span class="line">        self.connect()</span><br><span class="line">        color_frame, depth_frame = self.get_frame()</span><br><span class="line"></span><br><span class="line">        width = color_frame.get_width()</span><br><span class="line">        height = color_frame.get_height()</span><br><span class="line">        color_format = color_frame.get_format()</span><br><span class="line">        data = np.asanyarray(color_frame.get_data())</span><br><span class="line">        color_data = cv2.imdecode(data, cv2.IMREAD_COLOR)</span><br><span class="line">        color_data.astype(np.float32)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;color_image.shape: &#x27;</span>, color_data.shape)</span><br><span class="line">        <span class="comment"># print(&quot;===width: &#123;&#125;===&quot;.format(width))</span></span><br><span class="line">        <span class="comment"># print(&quot;===height: &#123;&#125;===&quot;.format(height))</span></span><br><span class="line">        width = depth_frame.get_width()</span><br><span class="line">        height = depth_frame.get_height()</span><br><span class="line">        scale = depth_frame.get_depth_scale()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;===width: &#123;&#125;===&quot;</span>.<span class="built_in">format</span>(width))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;===height: &#123;&#125;===&quot;</span>.<span class="built_in">format</span>(height))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;===scale: &#123;&#125;===&quot;</span>.<span class="built_in">format</span>(scale))</span><br><span class="line">        save_dir = os.path.join(os.getcwd(), <span class="string">&quot;real/intrinsic&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_dir):</span><br><span class="line">            os.mkdir(save_dir)</span><br><span class="line">        filename = save_dir + <span class="string">&quot;/camera_depth_scale.txt&quot;</span></span><br><span class="line">        save = np.array([scale])</span><br><span class="line">        np.savetxt(filename, save, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        depth_data = np.frombuffer(depth_frame.get_data(), dtype=np.uint16)</span><br><span class="line">        depth_data = depth_data.reshape((height, width))</span><br><span class="line">        depth_data = depth_data.astype(np.float32) * scale</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;depth_image.shape: &#x27;</span>, depth_data.shape)</span><br><span class="line"></span><br><span class="line">        depth_data = cv2.normalize(depth_data, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX, dtype=cv2.CV_16U)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 断开相机</span></span><br><span class="line">        self.disconnect()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> color_data, depth_data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data_saved</span>(<span class="params">self</span>):</span><br><span class="line">        color_data, depth_data = self.get_data()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># depth_image = depth_data_normalized.astype(np.uint8)</span></span><br><span class="line"></span><br><span class="line">        save_image_dir = os.path.join(os.getcwd(), <span class="string">&quot;real/images&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_image_dir):</span><br><span class="line">            os.mkdir(save_image_dir)</span><br><span class="line">        depth_filename = save_image_dir + <span class="string">&quot;/depth_&#123;&#125;x&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(depth_data.shape[<span class="number">0</span>], depth_data.shape[<span class="number">1</span>])</span><br><span class="line">        color_filename = save_image_dir + <span class="string">&quot;/color_&#123;&#125;x&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(color_data.shape[<span class="number">0</span>], color_data.shape[<span class="number">1</span>])</span><br><span class="line">        cv2.imwrite(color_filename, color_data)</span><br><span class="line">        <span class="comment"># depth_data.tofile(depth_filename)</span></span><br><span class="line">        cv2.imwrite(depth_filename, depth_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> color_data, depth_data</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_intrinsic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取内参&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># get intrinsic</span></span><br><span class="line">        itsc = self.pipeline.get_camera_param()</span><br><span class="line">        raw_intrinsic = itsc.depth_intrinsic</span><br><span class="line"></span><br><span class="line">        intrinsic = np.array([raw_intrinsic.fx, <span class="number">0</span>, raw_intrinsic.cx, </span><br><span class="line">                                <span class="number">0</span>, raw_intrinsic.fy, raw_intrinsic.cy,</span><br><span class="line">                                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;intrinsic: &quot;</span>, itsc)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;depth intrinsic: &#x27;</span>, raw_intrinsic)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;intrinsic matrix&quot;</span>, intrinsic)</span><br><span class="line">        save_dir = os.path.join(os.getcwd(), <span class="string">&quot;real/intrinsic&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_dir):</span><br><span class="line">            os.mkdir(save_dir)</span><br><span class="line">        filename = save_dir + <span class="string">&quot;/camera_itcs.txt&quot;</span></span><br><span class="line"></span><br><span class="line">        np.savetxt(filename, intrinsic, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intrinsic</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># for test</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visualize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示rgbd图像&quot;&quot;&quot;</span></span><br><span class="line">        color_data, depth_data = self.get_data()</span><br><span class="line">        depth_image = cv2.normalize(depth_data, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX, dtype=cv2.CV_8U)</span><br><span class="line">        depth_image = cv2.applyColorMap(depth_image, cv2.COLORMAP_JET)</span><br><span class="line">        <span class="comment"># overlay color image on depth image</span></span><br><span class="line">        depth_image = cv2.addWeighted(color_data, <span class="number">0.5</span>, depth_image, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;Depth with Color&quot;</span>, depth_image)</span><br><span class="line">        cv2.waitKey(<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    camera = Camera()</span><br><span class="line">    camera.visualize()</span><br><span class="line">    color, depth = camera.get_data()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;depth.shape: &quot;</span>, depth.shape)</span><br></pre></td></tr></table></figure><p>测试相机是否实现对齐,结果如下</p><p><img src="https://pic.imgdb.cn/item/66d2f4e6d9c307b7e93f943b.png" alt="img"></p><p>表明了相机确实实现了对齐操作</p><h2 id="3-修改demo-py"><a href="#3-修改demo-py" class="headerlink" title="3. 修改demo.py"></a>3. 修改demo.py</h2><p>我们使用<code>get_data()</code>函数就能够让相机进行一次拍摄，然后得到<code>color_data</code>和<code>depth_data</code>供我们进行后续的处理。然后可以修改一下<code>demo.py</code>，将从文件读取数据改为直接从相机进行读取</p><p><code>demo.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> astra2 <span class="keyword">import</span> Camera()</span><br><span class="line">astra2 = Camera()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_and_process_data</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用相机获取一次数据</span></span><br><span class="line">    color, depth = astra2.get_data()</span><br><span class="line">    color = color / <span class="number">255.0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然后别的部分可以保持不变或者以后再修改。这里一定要使用官方提供的<code>checkpoint-rs.tar</code>，如果使用<code>checkpoint-kn.tar</code>，会出现异常，暂时我也没有找到原因。</p><p>最后处理的效果如下</p><p><img src="https://pic.imgdb.cn/item/66d2f53ad9c307b7e93fda74.png" alt="img"></p><p>可以看到出现了许多我们不希望存在的抓取框,这个可以通过调整<code>workspace_mask</code>来进行过滤</p>]]></content>
      
      
      <categories>
          
          <category> 6D位姿抓取算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graspnet </tag>
            
            <tag> Astra2 </tag>
            
            <tag> 6D位姿抓取 </tag>
            
            <tag> 机械臂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu中复现Graspnet</title>
      <link href="/2024/05/10/Ubuntu%E4%B8%AD%E5%A4%8D%E7%8E%B0Graspnet/"/>
      <url>/2024/05/10/Ubuntu%E4%B8%AD%E5%A4%8D%E7%8E%B0Graspnet/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu20-04中GraspNet复现流程"><a href="#Ubuntu20-04中GraspNet复现流程" class="headerlink" title="Ubuntu20.04中GraspNet复现流程"></a>Ubuntu20.04中GraspNet复现流程</h1><p><strong>非常重要的环境配置</strong></p><ul><li>ubuntu 20.04</li><li>cuda 11.0.1</li><li>cudnn v8.9.7</li><li>python 3.8.19</li><li>pytorch 1.7.0</li><li>numpy 1.23.5</li></ul><p>详细的信息如下：</p><p><img src="https://pic.imgdb.cn/item/66d2f882d9c307b7e943e928.png" alt="img"></p><p>笔者在复现的过程中遇到了许多的坑，现在记录一下，来帮助希望也能够复现的同学。</p><h2 id="1-安装cuda和cudnn"><a href="#1-安装cuda和cudnn" class="headerlink" title="1.安装cuda和cudnn"></a>1.安装cuda和cudnn</h2><p>具体可以参考这篇：<a href="https://blog.csdn.net/qq_44940689/article/details/138496584">ubuntu配置多版本cuda+cudnn环境，及版本切换方法</a></p><h2 id="2-安装pytorch"><a href="#2-安装pytorch" class="headerlink" title="2.安装pytorch"></a>2.安装pytorch</h2><p>具体可以参考这篇：<a href="https://blog.csdn.net/qq_44940689/article/details/132684758">【Linux】Ubuntu20.04版本配置pytorch环境2023.09.05【教程】</a></p><h2 id="3-编译graspnetAPI"><a href="#3-编译graspnetAPI" class="headerlink" title="3.编译graspnetAPI"></a>3.编译graspnetAPI</h2><p>直接参考官方给的流程就好，参考这里：<a href="https://github.com/graspnet/graspnet-baseline?tab=readme-ov-file">graspnet-baseline</a></p><p>然后下载官方给的预训练权重，运行demo</p><p>如果出现问题：</p><blockquote><p>ImportError: numpy.core.multiarray failed to import ( auto-generated, because you didn’t call ‘numpy.import _array()’ after cimporting numpy; use ‘<void>numpy.<em>import</em> array’ to  disable if you are certain you don’t need it)</p></blockquote><p>或者其他<code>numpy</code>相关的问题，我们可以把<code>numpy</code>的版本换成<code>numpy==1.23.5</code>，而不是默认的<code>numpy==1.20.3</code></p><p>直接在你的虚拟环境中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy==1.23.5</span><br></pre></td></tr></table></figure><p>即可完成替换，然后再运行demo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh command_demo.sh</span><br></pre></td></tr></table></figure><p>即可出现以下的结果：</p><p><img src="https://pic.imgdb.cn/item/66d2f85fd9c307b7e9439b4e.png" alt="img"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="https://blog.csdn.net/weixin_49663860/article/details/136941470">复现GraspNet遇到的问题-解决方法！</a><br>[2]<a href="https://blog.csdn.net/weixin_45622961/article/details/136753265?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-136753265-blog-136941470.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-136753265-blog-136941470.235%5Ev43%5Econtrol&utm_relevant_index=5">GraspNet-baseline复现—-Linux-Ubuntu</a></p>]]></content>
      
      
      <categories>
          
          <category> 6D位姿抓取算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graspnet </tag>
            
            <tag> 6D位姿抓取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL简明教程</title>
      <link href="/2024/03/31/C-STL%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2024/03/31/C-STL%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL简明教程"><a href="#C-STL简明教程" class="headerlink" title="C++ STL简明教程"></a>C++ STL简明教程</h1><p>C++ STL（standard template library）标准模板库，是一套强大的C++模板类，提供了通用了模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量<code>vector</code>，队列<code>deque</code>，和映射<code>map</code>等。</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>容器（Containers）</td><td>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td>算法（Algorithms）</td><td>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td>迭代器（Iterators）</td><td>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td></tr></tbody></table><p><img src="https://pic.imgdb.cn/item/66d2b21fd9c307b7e9e772fd.png" alt="img"></p><h2 id="1-1-std-vector"><a href="#1-1-std-vector" class="headerlink" title="1.1 std::vector"></a>1.1 std::vector</h2><p><code>std::vector</code>（向量），是一种变长数组，类似于python中的<code>list</code>，是一种可以“自动改变数组长度的数组”。在要使用<code>std::vector</code>的时候，我们需要添加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//如果没有这句，我们在使用时必须指明命名空间std::vector</span></span><br></pre></td></tr></table></figure><h3 id="1-1-1vector的定义"><a href="#1-1-1vector的定义" class="headerlink" title="1.1.1vector的定义"></a>1.1.1vector的定义</h3><p>可以像定义普通变量一样来定义vector变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;类型名&gt; 变量名;</span><br></pre></td></tr></table></figure><p>可以是各种类型，也同样可以是STL容器，举个例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; my_vector;</span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; my_vector;</span><br><span class="line">std::vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; my_vector;<span class="comment">//这里定义了一个二维的向量</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2vector容器的初始化"><a href="#1-1-2vector容器的初始化" class="headerlink" title="1.1.2vector容器的初始化"></a>1.1.2vector容器的初始化</h3><p>vector容器可以使用C中的<strong>初始化器</strong><code>&#123;&#125;</code>来进行初始化，vector容器也可以使用<strong>构造函数</strong><code>()</code>来进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector;<span class="comment">// 创建一个空的整数向量</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">my_vector</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;<span class="comment">// 创建一个整数向量初始化为5个10</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;<span class="comment">//创建一个整数向量为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h3 id="1-1-3vector容器内元素的访问和修改"><a href="#1-1-3vector容器内元素的访问和修改" class="headerlink" title="1.1.3vector容器内元素的访问和修改"></a>1.1.3vector容器内元素的访问和修改</h3><p><code>std::vector</code>容器一般有两种访问方式：</p><ul><li>通过下标<code>[]</code>来进行访问和修改，这种方式和python高度一致</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">my_vector</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; my_vector[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过迭代器（iterator）访问</li></ul><p>迭代器可以理解为指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;类型名&gt;::iterator 变量名;</span><br></pre></td></tr></table></figure><p>迭代器可以这样声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">my_vector.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = my_vector.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; my_vector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; it[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>可以将<code>for</code>循环读取部分简写为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = my_vector.<span class="built_in">begin</span>(); it != my_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4vector中的常用函数"><a href="#1-1-4vector中的常用函数" class="headerlink" title="1.1.4vector中的常用函数"></a>1.1.4vector中的常用函数</h3><ul><li><code>push_back()</code>，在vector的末尾添加元素，类似python中<code>list.append()</code>方法</li><li><code>emplace_back()</code>，在vector的末尾添加元素（C++11特性）</li><li><code>pop_back()</code>，删除vector末尾的元素，类似python中<code>list.pop()</code>方法，但是没有返回值</li><li><code>size()</code>，返回vector的长度，类似python中的<code>len(list)</code></li><li><code>clear()</code>，清空vector中的所有元素</li><li><code>insert()</code>，在指定的地址插入元素</li><li><code>back()</code>，访问vector中的最后一个元素</li><li><code>front()</code>，访问vector中的首元</li><li><code>erase()</code>，删除指定地址的元素</li></ul><p><strong>（1）push_back()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> <span class="type">int</span> &amp;__x)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><p><strong>（2）pop_back()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">pop_back</span>()</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加10个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//使用pop_back()弹出5个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>（3）size()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">size_t</span> std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加10个元素</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Length of the vector is &quot;</span> &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length of the vector is 10</span><br></pre></td></tr></table></figure><p><strong>（4）clear()</strong></p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加10个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Length of vector is &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Length of vector is &quot;</span> &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Length of vector is 10</span><br><span class="line">Length of vector is 0</span><br></pre></td></tr></table></figure><p><strong>（5）insert()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(__position, __x);</span><br><span class="line">参数：</span><br><span class="line">    __position: - A const_iterator into the vector.</span><br><span class="line">    __x: - Data to be inserted.</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>(), <span class="number">-1</span>);<span class="comment">// 在索引0的位置添加一个-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>() + <span class="number">1</span>, &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;);<span class="comment">// 用初始化器在索引1的位置，插入两个元素-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; antherVector = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">end</span>(), antherVector.<span class="built_in">begin</span>(), antherVector.<span class="built_in">end</span>());<span class="comment">// 在末尾，插入另一个vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">-1 1 2 3 4 5</span><br><span class="line">-1 -1 -1 1 2 3 4 5</span><br><span class="line">-1 -1 -1 1 2 3 4 5 -1 -1 -1</span><br></pre></td></tr></table></figure><p><strong>（6）erase()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">erase</span>(__position);</span><br><span class="line">参数：</span><br><span class="line">    __position: - A const_iterator into the vector.</span><br></pre></td></tr></table></figure><p>指定删除的区间的时候，这个区间是左闭右闭的。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除索引为1的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>() - <span class="number">1</span>);<span class="comment">//删除一段区间的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 3 4 5</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h2 id="1-2-std-string"><a href="#1-2-std-string" class="headerlink" title="1.2 std::string"></a>1.2 std::string</h2><p><code>std::string</code>（字符串），是C++标准库中用于表示和字符串的类，它提供了许多成员函数和操作符，用于处理字符串的各种操作，非常类似于Python中的<code>str</code>数据类型，当我们使用<code>std::string</code>的时候，我们需要提前包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//如果没有这句，我们在使用时必须指明命名空间std::string</span></span><br></pre></td></tr></table></figure><h3 id="1-2-1string的定义"><a href="#1-2-1string的定义" class="headerlink" title="1.2.1string的定义"></a>1.2.1string的定义</h3><p><code>std::string</code>可以像普通类型一样进行定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br></pre></td></tr></table></figure><h3 id="1-2-2string的初始化"><a href="#1-2-2string的初始化" class="headerlink" title="1.2.2string的初始化"></a>1.2.2string的初始化</h3><p><code>std::string</code>可以直接使用字符串字面量来进行初始化，或者使用另一个字符串变量来进行初始化，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello, World!&quot;</span>;<span class="comment">// 使用字符串字面量来初始化</span></span><br><span class="line">std::string str2 = str1;<span class="comment">// 使用另一个字符串变量来初始化</span></span><br></pre></td></tr></table></figure><p>举个能实际运行的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str1 = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">std::string str2 = str1;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="1-2-3string中元素的访问和修改"><a href="#1-2-3string中元素的访问和修改" class="headerlink" title="1.2.3string中元素的访问和修改"></a>1.2.3string中元素的访问和修改</h3><p><code>std::string</code>有两种访问和修改字符的方式，<code>std::string</code>和Python中<code>str</code>数据类型的不同点在于，Python<code>str</code>类型不支持原地修改，而<code>std::string</code>支持，<code>str</code>类型支持切片操作，但是<code>std::string</code>不支持切片操作，可以使用<code>std::string::substr()</code>方法来代替。</p><ul><li>使用<code>[]</code>进行元素访问和修改</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str[<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//使用[]进行元素访问</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;C&#x27;</span>;<span class="comment">//使用[]进行元素修改</span></span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">Cello World!</span><br></pre></td></tr></table></figure><ul><li>使用<code>at</code>进行元素修改和访问</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;<span class="comment">//使用at进行元素访问</span></span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;C&#x27;</span>;<span class="comment">//使用at进行元素修改</span></span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">Cello World!</span><br></pre></td></tr></table></figure><h3 id="1-2-4string的遍历"><a href="#1-2-4string的遍历" class="headerlink" title="1.2.4string的遍历"></a>1.2.4string的遍历</h3><ul><li>range-based for循环遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代器遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用下标遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-5string中连接字符串"><a href="#1-2-5string中连接字符串" class="headerlink" title="1.2.5string中连接字符串"></a>1.2.5string中连接字符串</h3><p><code>std::string</code>可以像Python中<code>str</code>一样进行使用<code>+</code>进行拼接，使用<code>append()</code>方法在末尾添加字符。</p><ul><li>使用<code>+</code>进行拼接，<code>+</code>会返回一个新的字符串</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str1 + str2;<span class="comment">// 使用+进行字符串拼接</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line"> World!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><ul><li>使用<code>append()</code>进行拼接，在原字符串的基础上进行添加</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">std::string str2 = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">str1.<span class="built_in">append</span>(str2);<span class="comment">// 使用append进行字符串拼接</span></span><br><span class="line">cout &lt;&lt; str1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line"> World!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="1-2-6string中的常用函数"><a href="#1-2-6string中的常用函数" class="headerlink" title="1.2.6string中的常用函数"></a>1.2.6string中的常用函数</h3><ul><li><code>length()</code>获取字符串的长度，</li><li><code>size()</code>获取字符串的长度，</li><li><code>substr()</code>，获取字符串的子串，第一个参数是索引，第二个参数是子串的长度</li><li><code>find()</code>查找子串的位置</li><li><code>resize()</code>，直接调整<code>string</code>的长度</li><li><code>stoi()</code>，将单个字符串转换成<code>int</code>类型</li><li><code>stoll()</code>，将单个字符串转换成<code>long long</code>类型</li><li><code>push_back()</code>，将单个字符拼接在末尾</li><li><code>pop_back()</code>，弹出末尾的字符</li></ul><p><strong>（1）length()和size()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> std::string::<span class="built_in">length</span>() <span class="type">const</span>;</span><br><span class="line"><span class="type">size_t</span> std::string::<span class="built_in">size</span>() <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 12</span><br></pre></td></tr></table></figure><p><strong>（2）substr()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string std::string::<span class="built_in">substr</span>(<span class="type">size_t</span> __pos, <span class="type">size_t</span> __count) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p><code>substr()</code>是用于获得子串的函数，第一个位置是索引，第二个位置是子串的长度。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hell</span><br></pre></td></tr></table></figure><p><strong>（3）find()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> std::string::<span class="built_in">find</span>(<span class="type">const</span> std::string&amp; __str, <span class="type">size_t</span> __pos = <span class="number">0</span>) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p><code>find()</code>是用于查找子串的位置，返回子串首元出现在母船中的位置。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">std::string substr = <span class="string">&quot;orld&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(substr) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>返回的是<code>orld</code>在字符串<code>Hello World!</code>中首元的位置，在下标<code>7</code>的地方。</p><h2 id="1-3-std-map"><a href="#1-3-std-map" class="headerlink" title="1.3 std::map"></a>1.3 std::map</h2><p><code>std::map</code>是一种键值对容器，在python中这种容器被称为字典<code>dict</code>，在<code>std::map</code>中数据都是成对出现的，每一对中的第一个值被称为关键字<code>key</code>，每个关键字只能在<code>std::map</code>中出现一次，第二个称之为关键的对应值。在使用<code>std::map</code>之前，我们需要包含头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//如果没有这句，我们在使用时必须指明命名空间std::map</span></span><br></pre></td></tr></table></figure><h3 id="1-3-1map的定义"><a href="#1-3-1map的定义" class="headerlink" title="1.3.1map的定义"></a>1.3.1map的定义</h3><p><code>std::map</code>是一个模板类，需要的关键字和存储对象两个模板参数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;关键字的类型名， 存储对象的类型名&gt; 变量名;</span><br></pre></td></tr></table></figure><p>类型名可以是各种类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;string, <span class="type">int</span>&gt; person;<span class="comment">//使用string需要先#include &lt;string&gt;</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mydict;</span><br></pre></td></tr></table></figure><h3 id="1-3-2map的初始化"><a href="#1-3-2map的初始化" class="headerlink" title="1.3.2map的初始化"></a>1.3.2map的初始化</h3><p><code>std::map</code>可以使用初始化列表<code>&#123;&#125;</code>来进行初始化，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-3map的遍历"><a href="#1-3-3map的遍历" class="headerlink" title="1.3.3map的遍历"></a>1.3.3map的遍历</h3><p><code>std::map</code> 并不直接支持使用下标进行遍历，因为它是一种按键排序的关联容器，而不是顺序容器。使用下标遍历会导致元素的顺序混乱，不符合 <code>std::map</code> 的特性。</p><ul><li>使用迭代器遍历</li></ul><p>举个例子，初始化一个<code>std::map</code>然后使用<code>iterator</code>遍历其中的键值对（key-value pair）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (std::map&lt;string, <span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); it++ ) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用 <code>myMap.begin()</code> 获取指向第一个键值对的迭代器，使用 <code>myMap.end()</code> 获取指向最后一个键值对后面位置的迭代器。然后，通过迭代器遍历 <code>std::map</code> 中的键值对，并使用 <code>it-&gt;first</code> 获取键，<code>it-&gt;second</code> 获取值。</p><p>上述代码我们在指定迭代器的时候，手动去指定迭代器的类型，这样十分的麻烦，我们可以使用<code>auto</code>关键字来自动生成符合条件的迭代器，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); it++ ) &#123;<span class="comment">// 使用auto关键字自动生成迭代器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用范围循环遍历</li></ul><p>举个例子，初始化一个<code>std::map</code>然后使用<code>std::pair</code>遍历其中的键值对（key-value pair）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;string, <span class="type">int</span>&gt;&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><p>同样我们也能使用关键字<code>auto</code>来自动推导类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;<span class="comment">// 使用auto关键字自动生成pair</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-4map中元素的访问和修改"><a href="#1-3-4map中元素的访问和修改" class="headerlink" title="1.3.4map中元素的访问和修改"></a>1.3.4map中元素的访问和修改</h3><p>可以使用<code>[]</code>来访问并修改<code>std::map</code>中的元素，就类似于Python的<code>dict</code>一样，举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line">myMap[<span class="string">&quot;One&quot;</span>] = <span class="number">10</span>;<span class="comment">// 修改One对应的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;<span class="comment">// 使用auto关键字自动生成迭代器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 10</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><h3 id="1-3-5map中的常用函数"><a href="#1-3-5map中的常用函数" class="headerlink" title="1.3.5map中的常用函数"></a>1.3.5map中的常用函数</h3><ul><li><code>insert()</code>，向map中插入一个键值对，</li><li><code>erase()</code>，删除指定键的键值对</li><li><code>find()</code>，查找指定键的迭代器</li><li><code>count()</code>，返回指定键在map中的出现次数</li><li><code>size()</code>，返回map的长度</li><li><code>empty()</code>，检查map是否为空</li><li><code>clear()</code>，清空map中的所有键值对</li><li><code>beign()</code>，返回指向第一个键值对的迭代器</li><li><code>end()</code>，返回指向最后一个键值对的迭代器</li></ul><p>这里有很多函数的用法于之前介绍<code>string</code>和<code>vector</code>时的用法类似，这里就不再重复介绍了，</p><p><strong>（1）insert()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::map&lt;Key, T, Compare, Allocator&gt;::<span class="built_in">insert</span>(<span class="type">const</span> std::pair&lt;<span class="type">const</span> Key, T&gt;&amp; __x)</span><br></pre></td></tr></table></figure><p><code>std::map&lt;Key, T, Compare, Allocator&gt;</code> 表示 <code>std::map</code> 的模板参数，其中 <code>Key</code> 是键的类型，<code>T</code> 是值的类型，<code>Compare</code> 是用于比较键的比较函数类型，<code>Allocator</code> 是分配器的类型。</p><p>而 <code>insert()</code> 函数的原型部分 <code>const std::pair&lt;const Key, T&gt;&amp; __x</code> 表示参数 <code>__x</code> 是一个常量引用，类型为 <code>std::pair&lt;const Key, T&gt;</code>，即键值对的类型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;Four&quot;</span>, <span class="number">4</span> &#125;);<span class="comment">//插入单个键值对</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;Five&quot;</span>, <span class="number">5</span>));<span class="comment">//插入std::pair键值对</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Six&quot;</span>, <span class="number">6</span>));<span class="comment">//使用std::make_pair插入键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br><span class="line"></span><br><span class="line">Key: Five       Value: 5</span><br><span class="line">Key: Four       Value: 4</span><br><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Six        Value: 6</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><p><strong>（2）erase()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::map&lt;Key, T, Compare, Allocator&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; __x)</span><br></pre></td></tr></table></figure><p><code>std::map&lt;Key, T, Compare, Allocator&gt;</code> 表示 <code>std::map</code> 的模板参数，其中 <code>Key</code> 是键的类型，<code>T</code> 是值的类型，<code>Compare</code> 是用于比较键的比较函数类型，<code>Allocator</code> 是分配器的类型。</p><p>而 <code>erase()</code> 函数的原型部分 <code>const Key&amp; __x</code> 表示参数 <code>__x</code> 是一个常量引用，类型为 <code>Key</code>，即要删除的键的类型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125;, &#123; <span class="string">&quot;Four&quot;</span>, <span class="number">4</span> &#125;, &#123;<span class="string">&quot;Five&quot;</span>, <span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="string">&quot;Two&quot;</span>);<span class="comment">// 删除指定键的键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Three&quot;</span>);<span class="comment">// 删除指定迭代器指向的键值对</span></span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">myMap.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> start = myMap.<span class="built_in">find</span>(<span class="string">&quot;Five&quot;</span>);<span class="comment">// 删除一定范围内的键值对</span></span><br><span class="line"><span class="keyword">auto</span> end = myMap.<span class="built_in">find</span>(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">myMap.<span class="built_in">erase</span>(start, end);<span class="comment">// 左开右闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Key: Five       Value: 5</span><br><span class="line">Key: Four       Value: 4</span><br><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br><span class="line"></span><br><span class="line">Key: Four       Value: 4</span><br><span class="line">Key: One        Value: 1</span><br></pre></td></tr></table></figure><h2 id="1-4std-pair"><a href="#1-4std-pair" class="headerlink" title="1.4std::pair"></a>1.4std::pair</h2><p><code>std::pair</code>是C++标准库中的模板类，用于表示两个值的有序对，它可以存储不同类型的值，并提供了一些成员函数和操作符来访问和操作这两个值，在使用<code>std::pair</code>之前，我们需要导入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span><span class="comment">// 导入该头文件才能正常使用pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">// 但是当我们使用了标准输入输出流的时候，就已经包括了该头文件，无需重复导入</span></span></span><br></pre></td></tr></table></figure><h3 id="1-4-1pair的定义和初始化"><a href="#1-4-1pair的定义和初始化" class="headerlink" title="1.4.1pair的定义和初始化"></a>1.4.1pair的定义和初始化</h3><ul><li>使用构造函数进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair &lt;<span class="type">int</span>, std::string&gt; <span class="built_in">myPair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>使用初始化器<code>&#123;&#125;</code>来初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair &lt;<span class="type">int</span>, std::string&gt; myPair = &#123;<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用<code>make_pair</code>函数进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);<span class="comment">// 使用auto自动推断构建后的类型</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2pair的访问与修改"><a href="#1-4-2pair的访问与修改" class="headerlink" title="1.4.2pair的访问与修改"></a>1.4.2pair的访问与修改</h3><p>使用<code>.</code>来访问<code>std::pair</code>中的值，<code>std::pair</code> 的第一个值可以通过 <code>pair.first</code> 访问，第二个值可以通过 <code>pair.second</code> 访问。需要注意的是，<code>std::pair</code> 是一个简单的容器，只包含两个值，没有提供像容器类（如 <code>std::vector</code> 或 <code>std::map</code>）那样的迭代器和成员函数。使用 <code>std::pair</code> 主要是为了方便地存储和传递两个相关的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl;<span class="comment">//访问pair1的第一个值</span></span><br><span class="line">pair2.second = <span class="number">5</span>;<span class="comment">//修改pair2的第二个值</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3pair的比较"><a href="#1-4-3pair的比较" class="headerlink" title="1.4.3pair的比较"></a>1.4.3pair的比较</h3><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isEqual = (pair1 == pair2);</span><br><span class="line"><span class="type">bool</span> isNotEqual = (pair1 != pair2);</span><br><span class="line"><span class="type">bool</span> isLess = (pair1 &lt; pair2);</span><br><span class="line"><span class="type">bool</span> isGreater = (pair1 &gt; pair2);</span><br><span class="line">cout &lt;&lt; isEqual &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isNotEqual &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isLess &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isGreater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure><h2 id="1-5std-set"><a href="#1-5std-set" class="headerlink" title="1.5std::set"></a>1.5std::set</h2><p><code>std::set</code>是C++标准库中的容器类，用于存储唯一且自动排序的元素集合，类似于Python中的<code>set</code>。要使用<code>std::set</code>，我们需要包含以下头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-5-1set的定义"><a href="#1-5-1set的定义" class="headerlink" title="1.5.1set的定义"></a>1.5.1set的定义</h3><p><code>set</code>是一个模板类，需要的一个模板参数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;类型名&gt; 变量名;</span><br></pre></td></tr></table></figure><p>类型名可以是各种类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">std::set&lt;string&gt; mySet;</span><br></pre></td></tr></table></figure><h3 id="1-5-2set的初始化"><a href="#1-5-2set的初始化" class="headerlink" title="1.5.2set的初始化"></a>1.5.2set的初始化</h3><p><code>std::set</code>可以使用多种方式来进行初始化</p><ul><li>使用初始化列表来初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//使用初始化列表初始化set</span></span><br></pre></td></tr></table></figure><ul><li>使用迭代器范围初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mySet</span><span class="params">(vec.begin(), vec.end())</span></span>;<span class="comment">// 使用迭代器范围初始化set</span></span><br></pre></td></tr></table></figure><ul><li>使用另一个<code>std::set</code>进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; sourceSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mySet</span><span class="params">(sourceSet)</span></span>;<span class="comment">// 使用另一个`std::set`进行初始化</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3set的插入与删除"><a href="#1-5-3set的插入与删除" class="headerlink" title="1.5.3set的插入与删除"></a>1.5.3set的插入与删除</h3><p><code>std::set</code>中有关插入与修删除的函数分别是：</p><ul><li><code>insert()</code>，插入一个元素</li><li><code>erase()</code>，删除一个元素</li></ul><p>插入元素的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">10</span>);<span class="comment">// 插入一个元素10</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3 10</span><br></pre></td></tr></table></figure><p>删除元素的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">1</span>);<span class="comment">// 插入一个元素1</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="1-5-4set的遍历"><a href="#1-5-4set的遍历" class="headerlink" title="1.5.4set的遍历"></a>1.5.4set的遍历</h3><p>在C++标准库中<code>std::set</code>是基于红黑树实现的关联容器，其中元素按照特定的排序顺序规则进行存储和访问，所以<code>std::set</code>不支持使用<code>[]</code>通过下标来进行访问，对于<code>std::set</code>要访问其中的元素，我们可以使用<strong>迭代器</strong>或者<strong>范围-based for循环</strong>来访问</p><ul><li>使用迭代器来遍历访问</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (std::set&lt;<span class="type">int</span>&gt;::iterator it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;<span class="comment">// 手动指定迭代器类型</span></span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;<span class="comment">// 使用auto关键字自动推断迭代器类型</span></span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><ul><li>使用范围-based for循环来遍历访问</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; value : mySet) &#123;<span class="comment">// 手动指定value的类型</span></span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : mySet) &#123;<span class="comment">// 使用auto关键字自动推导类型</span></span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="1-5-5set中的常用函数"><a href="#1-5-5set中的常用函数" class="headerlink" title="1.5.5set中的常用函数"></a>1.5.5set中的常用函数</h3><ul><li><code>count()</code>，返回指定键在set中的出现次数</li><li><code>find()</code>，查找指定值的迭代器</li><li><code>size()</code>，获取元素的数量</li><li><code>empty()</code>，判断set是否为空</li><li><code>clear()</code>，清空set</li></ul><p><strong>（1）count()</strong></p><p><code>std::set::count()</code>会返回查找元素在容器中的次数，这里是<code>std::set</code>，不允许有重复的元素，所以如果查找到元素的话就返回<code>1</code>，没有查找到元素就返回<code>0</code>。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mySet.<span class="built_in">count</span>(<span class="number">1</span>) != <span class="number">0</span>) &#123;<span class="comment">// 查找元素1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;找到元素&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;未找到元素为&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到元素</span><br></pre></td></tr></table></figure><p><strong>（2）find()</strong></p><p><code>std::set::find()</code>会返回查找元素的迭代器，如果没找到，则遍历到<code>std::set::end()</code></p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="comment">//auto it = mySet.find(3);</span></span><br><span class="line"><span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it == mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;遍历到末尾未找到元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;找到元素为:&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">遍历到末尾未找到元素</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到元素为:3</span><br></pre></td></tr></table></figure><h2 id="1-6std-stack"><a href="#1-6std-stack" class="headerlink" title="1.6std::stack"></a>1.6std::stack</h2><p>在C++中，<code>std::stack</code>是一个容器适配器，它基于其他容器实现了栈的功能，栈是一种先进后出（first int last out， FILO）的数据结构，要使用<code>std::stack</code>我们得先包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-6-1stack的初始化"><a href="#1-6-1stack的初始化" class="headerlink" title="1.6.1stack的初始化"></a>1.6.1stack的初始化</h3><p><code>std::stack</code>的使用过程中一般使用默认初始化，即不给<code>std::stack</code>赋值，<code>std::stack</code>不支持使用花括号初始化器<code>&#123;&#125;</code>来进行初始化，但是<code>std::stack</code>可以使用其他容器来进行初始化，比如<code>std::deque</code>，这种初始化方式会调用适当的构建函数来构建栈对象。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">std::stack&lt;<span class="type">int</span>&gt; <span class="title">myStack</span><span class="params">(myDeque)</span></span>;<span class="comment">// 使用std::deque来构建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::stack&lt;<span class="type">int</span>&gt; <span class="title">myStack</span><span class="params">(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;)</span></span>;<span class="comment">// // 使用std::deque作为底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><h3 id="1-6-2stack的常用函数"><a href="#1-6-2stack的常用函数" class="headerlink" title="1.6.2stack的常用函数"></a>1.6.2stack的常用函数</h3><ul><li><code>push()</code>，向栈顶添加元素</li><li><code>pop()</code>，弹出栈顶元素，请注意无返回值</li><li><code>top()</code>，访问栈顶元素</li><li><code>empty()</code>，判断栈是否为空</li><li><code>size()</code>，获取栈中元素的数量</li></ul><p>举个使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">myStack.<span class="built_in">push</span>(i + <span class="number">1</span>);<span class="comment">// 向栈中添加元素</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;栈顶元素为: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;<span class="comment">// 查看栈顶元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;弹出元素&quot;</span> &lt;&lt; std::endl;<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;栈中元素个数为: &quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl;<span class="comment">// 查看元素个数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;栈是否为空: &quot;</span> &lt;&lt; myStack.<span class="built_in">empty</span>() &lt;&lt; std::endl;<span class="comment">// 查看栈是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈顶元素为: 10</span><br><span class="line">弹出元素</span><br><span class="line">栈中元素个数为: 8</span><br><span class="line">栈是否为空: 0</span><br></pre></td></tr></table></figure><h2 id="1-7std-queue"><a href="#1-7std-queue" class="headerlink" title="1.7std::queue"></a>1.7std::queue</h2><p>在C++标准库中，<code>std::queue</code>是一个容器适配器，它提供了队列的功能<code>queue</code>，队列是一种先进先出（first in first out）的数据结构，<code>std::queue</code>通过封装<code>std:deque</code>来实现队列操作，使用<code>std::queue</code>需要包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-7-1queue的初始化"><a href="#1-7-1queue的初始化" class="headerlink" title="1.7.1queue的初始化"></a>1.7.1queue的初始化</h3><p><code>std::queue</code>可以使用默认初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br></pre></td></tr></table></figure><p><code>std::queue</code>也可以使用花括号初始化器<code>&#123;&#125;</code>来进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; myQueue = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-7-2queue的常用函数"><a href="#1-7-2queue的常用函数" class="headerlink" title="1.7.2queue的常用函数"></a>1.7.2queue的常用函数</h3><ul><li><code>push()</code>，在队尾添加元素</li><li><code>front()</code>，访问队首元素</li><li><code>back()</code>，访问队尾元素</li><li><code>pop()</code>，移除队首元素，无返回值</li><li><code>empty()</code>，检查是否为空</li><li><code>size()</code>，返回队列中元素数量</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; myQueue;<span class="comment">// 默认初始化</span></span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">// 添加元素</span></span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;当前队首元素为: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;<span class="comment">// 查看队首元素</span></span><br><span class="line">myQueue.<span class="built_in">pop</span>();<span class="comment">// 移除队首元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;当前队列中的元素数量为: &quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl;<span class="comment">// 查看队列中元素个数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;当前队列是否为空: &quot;</span> &lt;&lt; myQueue.<span class="built_in">empty</span>() &lt;&lt; std::endl;<span class="comment">// 查看当前队列是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前队首元素为: 1</span><br><span class="line">当前队列中的元素数量为: 2</span><br><span class="line">当前队列是否为空: 0</span><br></pre></td></tr></table></figure><h2 id="1-8std-priority-queue"><a href="#1-8std-priority-queue" class="headerlink" title="1.8std::priority_queue"></a>1.8std::priority_queue</h2><p>Cpp的标准库中<code>std::priority_queue</code>是一个模板类，用于实现优先级队列，其中的元素按照一定的优先级顺序进行排列，默认情况下，<code>std::priority_queue</code>使用大顶堆进行排序（即最大的元素优先）。使用<code>std::priority_queue</code>需要先包含头文件</p><h3 id="1-8-1std-priority-queue的基本用法"><a href="#1-8-1std-priority-queue的基本用法" class="headerlink" title="1.8.1std::priority_queue的基本用法"></a>1.8.1std::priority_queue的基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>1.定义元素类型：确定要存储在优先级队列中的元素类型。该类型必须支持比较操作符（<code>&lt;</code>），以便进行元素的排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyElement</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.定义比较函数或使用自定义比较器（可选）：如果您的元素类型不是内置类型或没有默认的 <code>&lt;</code> 操作符，您需要定义一个比较函数或使用自定义的比较器类来指定元素的优先级排序规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyElement&amp; lhs, <span class="type">const</span> MyElement&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.priority &lt; rhs.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.创建优先级队列对象：使用定义的元素类型和比较函数&#x2F;比较器类，创建一个 <code>std::priority_queue</code> 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;MyElement, std::vector&lt;MyElement&gt;, Compare&gt; pq;</span><br></pre></td></tr></table></figure><p>4.插入元素：使用 <code>push</code> 函数将元素插入优先级队列中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyElement element1&#123;<span class="number">5</span>, <span class="string">&quot;First&quot;</span>&#125;;</span><br><span class="line">MyElement element2&#123;<span class="number">3</span>, <span class="string">&quot;Second&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pq.<span class="built_in">push</span>(element1);</span><br><span class="line">pq.<span class="built_in">push</span>(element2);</span><br></pre></td></tr></table></figure><p>5.访问顶部元素：使用 <code>top</code> 函数访问优先级队列中的最高优先级元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyElement topElement = pq.top();</span><br></pre></td></tr></table></figure><p>6.删除顶部元素：使用 <code>pop</code> 函数从优先级队列中删除最高优先级元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pq.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><p>通过重复执行步骤 5 和步骤 6，您可以顺序访问和删除优先级队列中的元素。</p><h3 id="1-8-2std-priority-queue的使用示例"><a href="#1-8-2std-priority-queue的使用示例" class="headerlink" title="1.8.2std::priority_queue的使用示例"></a>1.8.2std::priority_queue的使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    std::string description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> p, <span class="type">const</span> std::string&amp; desc) : <span class="built_in">priority</span>(p), <span class="built_in">description</span>(desc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Task&amp; lhs, <span class="type">const</span> Task&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.priority &lt; rhs.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, Compare&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到队列</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(<span class="number">2</span>, <span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(<span class="number">1</span>, <span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(<span class="number">3</span>, <span class="string">&quot;Task 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理任务</span></span><br><span class="line">    <span class="keyword">while</span> (!taskQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Task currentTask = taskQueue.<span class="built_in">top</span>();</span><br><span class="line">        taskQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing task: &quot;</span> &lt;&lt; currentTask.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Processing task: Task 3</span><br><span class="line">Processing task: Task 2</span><br><span class="line">Processing task: Task 1</span><br></pre></td></tr></table></figure><h2 id="1-9std-algorithm"><a href="#1-9std-algorithm" class="headerlink" title="1.9std::algorithm"></a>1.9std::algorithm</h2><p>Cpp的标准库中<code>std::algorithm</code>提供了许多使用的算法函数，用于处理容器（如<code>std::vector</code>、<code>std::list</code>等）中的元素，这些算法函数可以用于查找、排序、转换、合并等操作。在使用<code>std::algorithm</code>之前，需要包含头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-9-1algorithm中的常用函数"><a href="#1-9-1algorithm中的常用函数" class="headerlink" title="1.9.1algorithm中的常用函数"></a>1.9.1algorithm中的常用函数</h3><ul><li><code>std::sort()</code>，对容器进行排序</li><li><code>std::find()</code>，返回查找容器中的值的迭代器，没有找到则返回<code>容器::end()</code></li><li><code>std::copy()</code>，将一个容器的元素复制到另一个容器中</li><li><code>std::reverse()</code>，将容器中的元素进行反转</li><li><code>std::max()</code>，返回比较值中的最大元素</li><li><code>std::max_element()</code>，返回查找指定范围中的最大值所对应的迭代器</li><li><code>std::min()</code>，返回比较值中的最小元素</li><li><code>std::min_element()</code>，返回查找指定范围中的最小值所对应的迭代器</li><li><code>std::swap()</code>，交换两个对象的值</li></ul><p><strong>（1）std::sort()</strong></p><p>函数的原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">    Compare pred)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myV&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myV.<span class="built_in">begin</span>(), myV.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : myV) &#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>举个例子，使用逆序排列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompareReverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myV&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">//std::sort(myV.begin(), myV.end(), CompareReverse);// 1.传入比较函数</span></span><br><span class="line">std::<span class="built_in">sort</span>(myV.<span class="built_in">begin</span>(), myV.<span class="built_in">end</span>(),<span class="comment">// 2.使用Lambda匿名函数</span></span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : myV) &#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 8 7 6 5 3 2 1 0</span><br></pre></td></tr></table></figure><p><strong>（2）std::find()</strong></p><p>函数原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">cout &lt;&lt; *std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 1.查找元素3</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">bool</span>(std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">8</span>) == v.<span class="built_in">end</span>());<span class="comment">// 2.未找到元素8，返回v.end()</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>（3）std::copy()</strong></p><p>函数原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator destBeg)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; source&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">destination</span><span class="params">(source.size(),<span class="number">0</span>)</span></span>;<span class="comment">// 确保destination能够容纳source的所有元素</span></span><br><span class="line">std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), destination.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : destination) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>（4）std::reverse()</strong></p><p>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    BidirectionalIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::<span class="built_in">reverse</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : v1) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure><p><strong>（5）std::max()，std::min()</strong></p><p>函数原型分别是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Type&amp; <span class="title">max</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; left,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; right)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> Type&amp; <span class="title">min</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; left,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; right)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The max value of two is: &quot;</span> &lt;&lt; std::<span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The max value of three is: &quot;</span> &lt;&lt; std::<span class="built_in">max</span>(&#123; <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The max value of two is: 7</span><br><span class="line">The max value of three is: 9</span><br></pre></td></tr></table></figure><p><strong>（6）std::max_element()，std::min_element()</strong></p><p>函数原型分别是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ForwardIterator <span class="title">max_element</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ForwardIterator <span class="title">min_element</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator last )</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> min_it = std::<span class="built_in">min_element</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The max of v1 is: &quot;</span> &lt;&lt; *max_it &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The min of v1 is: &quot;</span> &lt;&lt; *min_it;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The max of v1 is: 9</span><br><span class="line">The min of v1 is: 1</span><br></pre></td></tr></table></figure><p><strong>（7）std::swap()</strong></p><p>函数原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type&amp; left,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type&amp; right)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myV&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; myV.<span class="built_in">size</span>(), j &lt; myV.<span class="built_in">size</span>(); i += <span class="number">2</span>, j += <span class="number">2</span>) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(myV[i], myV[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : myV) &#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 4 3</span><br></pre></td></tr></table></figure><p>这个例子两两交换了数组中的值。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.apiref.com/cpp-zh/cpp/container.html">C++容器库</a><br><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?view=msvc-170">C++微软库</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型预测控制MPC详解（附带案例实现）</title>
      <link href="/2024/02/22/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6MPC%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2024/02/22/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6MPC%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="模型预测控制MPC详解（附带案例实现）"><a href="#模型预测控制MPC详解（附带案例实现）" class="headerlink" title="模型预测控制MPC详解（附带案例实现）"></a>模型预测控制MPC详解（附带案例实现）</h1><p>写在前面本文是记录学习B站博主<a href="https://space.bilibili.com/230105574?spm_id_from=333.337.0.0">Dr.can</a>的学习笔记，如有侵权请联系笔者删除此文。</p><h2 id="1-最优控制问题"><a href="#1-最优控制问题" class="headerlink" title="1. 最优控制问题"></a>1. 最优控制问题</h2><p>最优控制问题就是研究在约束条件下达到最优的系统表现，通常系统的表现是综合分析的结果。比如考虑一个<strong>单输入单输出</strong>的系统（<strong>SISO</strong>），状态变量$x$，输出为$y$，要求其输出能跟踪预设的参考值$r$，误差可以表示为$e&#x3D;y-r$，那么最优控制的目标是</p><p>$$<br>\min \int_0^t e^2 dt<br>$$</p><p>如果同时希望输入量$u$也能越小越好（一般的目的是减少能耗），那最优控制的目标可以是</p><p>$$<br>\min \int_0^t q\times e^2 dt + r\times u^2 dt<br>$$</p><p>其中$q,r$分别是权重参数，用于调节两个目标的重要性。</p><p>考虑一个<strong>多输入多输出</strong>的系统（<strong>MIMO</strong>），系统的模型为：</p><p>$$<br>\begin{align*}<br>\frac{dX}{dt} &amp; &#x3D; AX + BU\<br>Y &amp; &#x3D; CX<br>\end{align*}<br>$$</p><p>那么可以将上述的最优化目标改写为：</p><p>$$<br>J &#x3D; \int^t_0 E^T Q E + U^T R U dt<br>$$</p><p>举一个实际的例子，系统的模型如下所示：</p><p>$$<br>\begin{align*}<br>\frac{d}{dt}<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix} &amp; &#x3D; A<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix} + B<br>\begin{bmatrix}<br>u_1\<br>u_2<br>\end{bmatrix}\<br>\begin{bmatrix}<br>y_1\<br>y_2<br>\end{bmatrix} &amp; &#x3D;<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix}<br>\end{align*}<br>$$</p><p>设置的参考值$R$为:</p><p>$$<br>R &#x3D; \begin{bmatrix}<br>r_1\<br>r_2<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>0\<br>0<br>\end{bmatrix}<br>$$</p><p>那么可以推导出误差$E$为：</p><p>$$<br>E &#x3D;<br>\begin{bmatrix}<br>e_1\<br>e_2<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>y_1 - r_1\<br>y_2 - r_2<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix}<br>$$</p><p>那么上述最优控制的目标函数可以写成：</p><p>$$<br>\begin{align*}<br>E^TQE  &amp; &#x3D;<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix}^T \begin{bmatrix}<br>q_1 &amp; 0\<br>0 &amp; q_2<br>\end{bmatrix}\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix} &#x3D; q_1 x_1^2 + q_2 x_2^2\<br>U^TRU &amp; &#x3D;<br>\begin{bmatrix}<br>u_1\<br>u_2<br>\end{bmatrix}^T \begin{bmatrix}<br>r_1 &amp; 0\<br>0 &amp; r_2<br>\end{bmatrix}\begin{bmatrix}<br>u_1\<br>u_2<br>\end{bmatrix} &#x3D; r_1 u_1^2 +r_2 u_2^2\<br>J &amp; &#x3D; \int^t_0 q_1 x_1^2 + q_2 x_2^2 + r_1 u_1^2 + r_2 u_2^2<br>\end{align*}<br>$$</p><h2 id="2-什么是MPC"><a href="#2-什么是MPC" class="headerlink" title="2. 什么是MPC"></a>2. 什么是MPC</h2><p>MPC（Model Predictive Control，模型预测控制）的基本思想是通过建立一个系统的动态模型，并在每一个控制时刻使用这个模型来预测系统未来的行为。基于这些预测，它可以生成一个优化控制序列，然后通过执行第一个控制动作来调整系统状态，接着在下一个时刻重新计算和执行。这个过程反复进行，以使系统能够在未来的一段时间内优化一个特定的性能指标。</p><p>通常来说，MPC包括以下四个基本步骤：</p><ul><li><p><strong>系统模型化</strong>：建立描述系统动态行为的数学模型，通常是差分方程或微分方程。</p></li><li><p><strong>预测</strong>：在当前时刻基于系统状态和控制输入，使用模型预测未来一段时间内的系统响应。</p></li><li><p><strong>优化</strong>：基于预测的系统响应，通过求解一个优化问题来计算最优的控制输入序列，以最大化或最小化一个性能指标（如系统响应时间、能耗等）。</p></li><li><p><strong>执行</strong>：根据优化得到的控制输入序列中的第一个值，执行这个控制动作，并将实际的系统状态反馈到下一个控制周期中</p></li></ul><p>在具体实施的过程中MPC主要分为下列的三个步骤：</p><p>在<code>k</code>时刻：</p><ul><li><font color=red>step1</font>：估计&#x2F;测量&#x2F;读取当前的系统状态；</li><li><font color=red>step2</font>：基于$\bold{u}<em>k, \bold{u}</em>{k+1},  \cdots, \bold{u}<em>{k+N}$来进行最优化<br>  $$<br>  J &#x3D; \sum_k^{N-1} E_k^TQE_k + U_k^T R U_k + \underbrace{E_N^TFE_N}</em>{\text{Terminal Cost}}<br>  $$<br>  其中Terminal Cost代表了模型滑动窗口的末端的控制误差。</li><li><font color=red>step3</font>：只取$\bold{u}_k$，进行滚动优化控制。</li></ul><h2 id="3-二次规划Quadratic-Programming"><a href="#3-二次规划Quadratic-Programming" class="headerlink" title="3. 二次规划Quadratic Programming"></a>3. 二次规划Quadratic Programming</h2><p>为了能求解MPC问题，我们需要将其转换成二次规划（Quadratic Programming）的形式，对于二次规划已经有很多成熟的求解器了，我们只需要使用这些求解器就能顺利求解。</p><p>二次规划一般具有如下的形式：</p><p>$$<br>\begin{align*}<br>&amp; \min_\bold{x} \bold{x}^TH\bold{x} + f^T\bold{x}\<br>&amp; \text{subject to} \quad…<br>\end{align*}<br>$$</p><p>其中$H$是正定的对称矩阵，$f$，$\bold{x}$是向量。</p><h2 id="4-MPC为什么可以转换成QP问题（推导过程）"><a href="#4-MPC为什么可以转换成QP问题（推导过程）" class="headerlink" title="4. MPC为什么可以转换成QP问题（推导过程）"></a>4. MPC为什么可以转换成QP问题（推导过程）</h2><p>考虑一个<font color=red>离散</font>的线性系统</p><p>$$<br>\bold{x}(k+1) &#x3D; A_{n\times n}\bold{x}(k) + B_{n\times p}\bold{u}(k)\<br>\bold{x}<em>{n\times 1} &#x3D; \begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots\<br>x_n<br>\end{bmatrix}, \bold{u}</em>{p\times1} &#x3D; \begin{bmatrix}<br>u_1\<br>u_2\<br>\vdots\<br>u_p<br>\end{bmatrix}<br>$$</p><p>假设滚动的窗口大小（预测区间，Predictive Horizon）为$N$，在$k$时刻，预测$k$时刻的输入为$\bold{u}(k|k)$，预测$k+1$时刻的输入为$\bold{u}(k+1|k)$，以此类推预测，预测区间的最后一个时刻的输入为$\bold{u}(k+N-1|k)$，将这些预测输入整合成一个向量</p><p>$$<br>\bold{U}_k &#x3D; \begin{bmatrix}<br>\bold{u}(k|k)\<br>\bold{u}(k+1|k)\<br>\vdots\<br>\bold{u}(k+i|k)\<br>\bold{u}(k+N-1|k)<br>\end{bmatrix}<br>$$</p><p>在$k$时刻，系统的状态为$\bold{x}(k|k)$，$k+1$系统的状态为$\bold{x}(k+1|k)$，以此类推预测，预测区间的最后一个时刻的系统的状态为$\bold{x}(k+N-1|k)$，然后再加上区间结束后的第一个状态$\bold{x}(k+N|k)$，将这些系统的状态整合成一个向量</p><p>$$<br>\bold{X}_k &#x3D; \begin{bmatrix}<br>\bold{x}(k|k)\<br>\bold{x}(k+1|k)\<br>\vdots\<br>\bold{x}(k+i|k)\<br>\bold{x}(k+N|k)<br>\end{bmatrix}<br>$$</p><p>假设系统的输出$\bold{y}&#x3D;\bold{x}$，设定的参考值$\bold{r}&#x3D;0$，那么系统的误差为$\bold{e}&#x3D;\bold{y}-\bold{r}&#x3D;\bold{x}-0 &#x3D; \bold{x}$，为了最优化误差和最优化输入，我们可以这样表示代价函数（Cost Function)</p><p>$$<br>\min_\bold{u} J &#x3D; \sum^{N-1}<em>{i&#x3D;0} \Big(\bold{x}(k+i|k)^TQ \bold{x}(k+i|k) + \bold{u}(k+i|k)^TR \bold{u}(k+i|k) \Big) + \underbrace{\bold{x}(k+N)^T F \bold{x}(k+N)}</em>{\text{Terminal Cost}}<br>$$</p><p>但是乍一看这并不是二次规划的形式，我们可以通过化简将其转化为标准的二次规划形式。</p><p>在$k$时刻，我们的系统状态可以表示为</p><p>$$<br>\begin{align*}<br>\bold{x}(k|k) &amp; &#x3D; \bold{x}_k\<br>\bold{x}(k+1|k) &amp; &#x3D; A \bold{x}(k|k) + B\bold{u}(k|k) &#x3D; A\bold{x}_k + B\bold{u}(k|k)\<br>\bold{x}(k+2|k) &amp; &#x3D; A \bold{x}(k+1|k) + B\bold{u}(k|k) &#x3D; A^2\bold{x}_k + AB\bold{u}(k|k) + B\bold{u}(k+1|k)\<br>\vdots\<br>\bold{x}(k+N|k) &amp; &#x3D; A^N \bold{x}_k + A^{N-1}B\bold{u}(k|k) + \cdots + B \bold{u}(k+N-1|k)<br>\end{align*}<br>$$</p><p>左边即为$\bold{X}_k$，然后将右边写成矩阵的形式</p><p>$$<br>\begin{align*}<br>\bold{X}<em>k &amp; &#x3D; \underbrace{\begin{bmatrix}<br>I\<br>A\<br>A^2\<br>\vdots\<br>A^N<br>\end{bmatrix}}</em>{M} \bold{x}<em>k + \underbrace{\begin{bmatrix}<br>0 &amp; 0 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>0 &amp; 0 &amp; \cdots &amp; 0\<br>B &amp; 0 &amp; \cdots &amp; 0\<br>AB &amp; B &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>A^{N-1}B &amp; A^{N-2}B &amp; \cdots &amp; B<br>\end{bmatrix}}</em>{C}\bold{U}_k\<br>\bold{X}_k &amp; &#x3D; M \bold{x}_k + C \bold{U}_k<br>\end{align*}<br>$$</p><p>其中$M$的前$n$行都是$0$。接下来，我们来将代价函数化成QP的形式</p><p>$$<br>\begin{align*}<br>J &amp; &#x3D; \sum^{N-1}<em>{i&#x3D;0} \Big(\bold{x}(k+i|k)^TQ \bold{x}(k+i|k) + \bold{u}(k+i|k)^TR \bold{u}(k+i|k) \Big) + \bold{x}(k+N)^T F \bold{x}(k+N)\<br>&amp; &#x3D; \bold{x}(k|k)^TQ\bold{x}(k|k) + \bold{x}(k+1|k)^TQ\bold{x}(k+1|k) + \cdots + \bold{x}(k+N-1|k)^TQ\bold{x}(k+N-1|k) + \bold{x}(k+N|k)^TQ\bold{x}(k+N|k) \<br>&amp; + \sum^{N-1}</em>{i&#x3D;0}\bold{u}(k+i|k)^TR\bold{u}(k+i|k)\<br>&amp; &#x3D; \begin{bmatrix}<br>\bold{x}(k|k)\<br>\bold{x}(k+1|k)\<br>\vdots\<br>\bold{x}(k+i|k)\<br>\bold{x}(k+N|k)<br>\end{bmatrix}^T \underbrace{\begin{bmatrix}<br>Q &amp; &amp; &amp;&amp;\<br>&amp; Q &amp; &amp; &amp;\<br>&amp; &amp; Q &amp;&amp;\<br>&amp; &amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; &amp; F<br>\end{bmatrix}}<em>{\bar{Q}}\begin{bmatrix}<br>\bold{x}(k|k)\<br>\bold{x}(k+1|k)\<br>\vdots\<br>\bold{x}(k+i|k)\<br>\bold{x}(k+N|k)<br>\end{bmatrix} + \begin{bmatrix}<br>\bold{u}(k|k)\<br>\bold{u}(k+1|k)\<br>\vdots\<br>\bold{u}(k+i|k)\<br>\bold{u}(k+N-1|k)<br>\end{bmatrix}^T \underbrace{\begin{bmatrix}<br>R &amp; &amp; &amp;&amp;\<br>&amp; R &amp; &amp; &amp;\<br>&amp; &amp; R &amp;&amp;\<br>&amp; &amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; &amp; R<br>\end{bmatrix}}</em>{\bar{R}}\begin{bmatrix}<br>\bold{u}(k|k)\<br>\bold{u}(k+1|k)\<br>\vdots\<br>\bold{u}(k+i|k)\<br>\bold{u}(k+N-1|k)<br>\end{bmatrix}\<br>&amp; &#x3D; \bold{X}_k^T \bar{Q} \bold{X}_k + \bold{U}_k \bar{R} \bold{U}_k<br>\end{align*}<br>$$</p><p>然后再将前面推导的条件带入</p><p>$$<br>\begin{align*}<br>J &amp; &#x3D; \bold{X}_k^T \bar{Q} \bold{X}_k + \bold{U}_k \bar{R} \bold{U}_k\<br>&amp; &#x3D; (M \bold{x}_k + C \bold{U}_k)^T \bar{Q}(M \bold{x}_k + C \bold{U}_k) + \bold{U}_k \bar{R} \bold{U}_k\<br>&amp; &#x3D; \bold{x}_k^TM^T\bar{Q}M\bold{x}_k + \underbrace{\bold{U}_k^TC^T\bar{Q}M\bold{x}_k + \bold{x}<em>k^TM^T\bar{Q}C}</em>{2\bold{x}^TC^T\bar{Q}M\bold{U}_k} \bold{U}_k + \bold{U}_k^TC^T\bar{Q}C \bold{U}_k + \bold{U}_k \bar{R} \bold{U}_k\<br>&amp; &#x3D; \bold{x}_k^TM^T\bar{Q}M\bold{x}_k + 2\bold{x}^TC^T\bar{Q}M\bold{U}_k \bold{U}_k + \bold{U}_k^TC^T\bar{Q}C \bold{U}_k + \bold{U}_k \bar{R} \bold{U}_k<br>\end{align*}<br>$$</p><p>其中$G&#x3D;M^T\bar{Q}M$，$E&#x3D;C^T\bar{Q}M$，$H&#x3D;C^T\bar{R}C+\bar{R}$，那么$J$可以化简为：</p><p>$$<br>J &#x3D; \bold{x}_k^T G \bold{x}_k + 2\bold{U}_k^T E \bold{x}_k  + \bold{U}_k^T H \bold{U}_k<br>$$</p><p>其中$\bold{x}_k^T G \bold{x}_k$是初始状态，是一个常量，在优化的过程中可以忽略。最终的代价函数可以表示为</p><p>$$<br>\min_\bold{U}J &#x3D; \bold{U}_k^T E \bold{x}_k  + 0.5 \times\bold{U}_k^T H \bold{U}_k\<br>G&#x3D;M^T\bar{Q}M\<br>E&#x3D;C^T\bar{Q}M\<br>H&#x3D;C^T\bar{R}C+\bar{R}\<br>\bar{Q} &#x3D; \begin{bmatrix}<br>Q &amp; \cdots &amp;\<br>\vdots &amp; Q &amp; \vdots\<br>&amp; \cdots &amp; F<br>\end{bmatrix}, \bar{R} &#x3D; \begin{bmatrix}<br>R &amp; \cdots &amp;\<br>\vdots &amp; \ddots &amp; \vdots\<br>&amp; \cdots &amp; R<br>\end{bmatrix}<br>$$</p><p>这就是一个标准的QP问题。</p><h2 id="5-MPC总结"><a href="#5-MPC总结" class="headerlink" title="5. MPC总结"></a>5. MPC总结</h2><h3 id="5-1-MPC的优势劣势"><a href="#5-1-MPC的优势劣势" class="headerlink" title="5.1 MPC的优势劣势"></a>5.1 MPC的优势劣势</h3><p>:smile:MPC的<font color=blue>优势</font>在于：</p><ul><li>可以处理多输入多数出的系统（MIMO），PID控制只能在一个PID环内控制一个系统状态，当系统状态相互影响的时候PID控制往往难以设计，MPC就体现出了其优势</li><li>MPC的另一个优势在于可以处理约束条件，约束很重要，因为违反它们会导致不良后果。</li></ul><p>:smile:MPC的<font color=blue>不足</font>在于：</p><ul><li>MPC是在线滚动优化的，所以需要比较强的算力。</li></ul><h3 id="5-2-MPC的衍生算法"><a href="#5-2-MPC的衍生算法" class="headerlink" title="5.2 MPC的衍生算法"></a>5.2 MPC的衍生算法</h3><p>:smile:如何<font color=blue>选择</font>合适的MPC？</p><p><font size="4" color="red"><b>自适应MPC（Adaptive MPC）</b></font></p><p>在自适应MPC 中，线性模型是随着工作条件的变化而动态计算的，并且在每个时间步长，您都可以使用此线性模型更新。MPC控制器使用的内部被控对象模型，请注意，在自适应MPC 中，优化问题的结构在不同的工作点上保持不变。这意味着在预测范围内，状态数量和约束数量不会因不同的操作条件而改变。</p><p><img src="https://pic.imgdb.cn/item/66d2eea2d9c307b7e93b34c6.png" alt="img"></p><p><font size="4" color="red"><b>增益调度MPC（Gain-scheduled MPC）</b></font></p><p>如果它们确实发生了变化，则应使用增益调度MPC。在增益调度MPC 中，您可以在感兴趣的工作点进行离线线性化，并为每个工作点设计一个线性MPC控制器。每个控制器彼此独立，因此可能具有不同数量的状态和不同数量的约束。</p><p><img src="https://pic.imgdb.cn/item/66d2eec3d9c307b7e93b4ce4.png" alt="img"></p><p>小结：</p><p>如果被控对象是非线性的，但可以通过线性模型逼近，则可以使用自适应MPC 控制器和如果被控对象是非线性的且状态的维度和约束的数量会发生变化，那么应该使用增益调度的MPC控制器。如果优化问题的结构在不同的工作条件下没有变化，则应使用自适应 MPC；但是，如果该结构有变化，则使用增益调度 MPC；如果因您有一个无法通过线性化进行良好逼近的高度非线性系统，从而导致以上这些方法都不起作用，则可以使用非线性MPC。具体可以如下图所示：</p><p><img src="https://pic.imgdb.cn/item/66d2eed6d9c307b7e93b5a37.png" alt="img"></p><h2 id="6-示例实现"><a href="#6-示例实现" class="headerlink" title="6. 示例实现"></a>6. 示例实现</h2><p>这个示例系统的状态方程为</p><p>$$<br>\begin{bmatrix}<br>x_1(k+1)\<br>x_2(k+1)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>1 &amp; 0.1\<br>-1 &amp; 2<br>\end{bmatrix}\begin{bmatrix}<br>x_1(k)\<br>x_2(k)<br>\end{bmatrix} + \begin{bmatrix}<br>0.2 &amp; 1\<br>0.5 &amp; 2<br>\end{bmatrix}\begin{bmatrix}<br>u_1(k)\<br>u_2(k)<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>y_1(k)\<br>y_2(k)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>x_1(k)\<br>x_2(k)<br>\end{bmatrix}, \begin{bmatrix}<br>r_1(k)\<br>r_2(k)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>0\<br>0<br>\end{bmatrix}<br>$$</p><p>Dr_can提供的<code>matlab/octave</code>示例代码</p><p><code>MPC_Test.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 清屏</span></span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%% 加载 optim package,若使用matlab，则注释掉此行</span></span><br><span class="line">pkg load optim;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 第一步，定义状态空间矩阵</span></span><br><span class="line"><span class="comment">%% 定义状态矩阵 A, n x n 矩阵</span></span><br><span class="line">A=[<span class="number">1</span> <span class="number">0.1</span>; <span class="number">-1</span> <span class="number">2</span>];</span><br><span class="line">n=<span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">%% 定义输入矩阵 B, n x p 矩阵</span></span><br><span class="line">B=[ <span class="number">0.2</span> <span class="number">1</span>; <span class="number">0.5</span> <span class="number">2</span>];</span><br><span class="line">p=<span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%% 定义Q矩阵，n x n 矩阵</span></span><br><span class="line">Q=[<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%% 定义F矩阵，n x n 矩阵</span></span><br><span class="line">F=[<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%% 定义R矩阵，p x p 矩阵</span></span><br><span class="line">R=[<span class="number">1</span> <span class="number">0</span> ;<span class="number">0</span> <span class="number">.1</span>];</span><br><span class="line"><span class="comment">%% 定义step数量k</span></span><br><span class="line">k_steps=<span class="number">100</span>;</span><br><span class="line"><span class="comment">%% 定义矩阵 X_K， n x k 矩 阵</span></span><br><span class="line">X_K = <span class="built_in">zeros</span>(n,k_steps);</span><br><span class="line"><span class="comment">%% 初始状态变量值， n x 1 向量</span></span><br><span class="line">X_K(:,<span class="number">1</span>) =[<span class="number">20</span>;<span class="number">-20</span>];</span><br><span class="line"><span class="comment">%% 定义输入矩阵 U_K， p x k 矩阵</span></span><br><span class="line">U_K=<span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">%% 定义预测区间K</span></span><br><span class="line">N=<span class="number">5</span>;</span><br><span class="line"><span class="comment">%% Call MPC_Matrices 函数 求得 E,H矩阵 </span></span><br><span class="line">[E,H]=MPC_Matrices(A,B,Q,R,F,N);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算每一步的状态变量的值</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line"><span class="comment">%% 求得U_K(:,k)</span></span><br><span class="line">U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);</span><br><span class="line"><span class="comment">%% 计算第k+1步时状态变量的值</span></span><br><span class="line">X_K(:,k+<span class="number">1</span>)=(A*X_K(:,k)+B*U_K(:,k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘制状态变量和输入的变化</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span> :<span class="built_in">size</span> (X_K,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span> (X_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>)</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span> : <span class="built_in">size</span> (U_K,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span> (U_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u1&quot;</span>,<span class="string">&quot;u2&quot;</span>) </span><br></pre></td></tr></table></figure><p><code>MPC_Matrices.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[E , H]</span>=<span class="title">MPC_Matrices</span><span class="params">(A,B,Q,R,F,N)</span></span></span><br><span class="line">n=<span class="built_in">size</span>(A,<span class="number">1</span>);<span class="comment">% A 是 n x n 矩阵, 得到 n</span></span><br><span class="line">p=<span class="built_in">size</span>(B,<span class="number">2</span>);<span class="comment">% B 是 n x p 矩阵, 得到 p</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%</span></span><br><span class="line">M=[<span class="built_in">eye</span>(n);<span class="built_in">zeros</span>(N*n,n)];<span class="comment">% 初始化 M 矩阵. M 矩阵是 (N+1)n x n的，它上面是 n x n 个 &quot;I&quot;, 这一步先把下半部分写成 0 </span></span><br><span class="line">C=<span class="built_in">zeros</span>((N+<span class="number">1</span>)*n,N*p); <span class="comment">% 初始化 C 矩阵, 这一步令它有 (N+1)n x NP 个 0</span></span><br><span class="line"><span class="comment">% 定义M 和 C </span></span><br><span class="line">tmp=<span class="built_in">eye</span>(n);<span class="comment">%定义一个n x n 的 I 矩阵</span></span><br><span class="line"><span class="comment">%　更新Ｍ和C</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N <span class="comment">% 循环，i 从 1到 N</span></span><br><span class="line"><span class="comment">%定义当前行数，从i x n开始，共n行</span></span><br><span class="line">rows =<span class="built_in">i</span>*n+(<span class="number">1</span>:n);</span><br><span class="line">C(rows,:)=[tmp*B,C(rows-n, <span class="number">1</span>:<span class="keyword">end</span>-p)]; <span class="comment">%将c矩阵填满</span></span><br><span class="line">tmp= A*tmp;<span class="comment">%每一次将tmp左乘一次A</span></span><br><span class="line">M(rows,:)=tmp;<span class="comment">%将M矩阵写满</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义Q_bar和R_bar</span></span><br><span class="line">Q_bar = kron(<span class="built_in">eye</span>(N),Q);</span><br><span class="line">Q_bar = <span class="built_in">blkdiag</span>(Q_bar,F);</span><br><span class="line">R_bar = kron(<span class="built_in">eye</span>(N),R);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算G, E, H</span></span><br><span class="line">G=M&#x27;*Q_bar*M;<span class="comment">% G: n x n</span></span><br><span class="line">E=C&#x27;*Q_bar*M;<span class="comment">% E: NP x n</span></span><br><span class="line">H=C&#x27;*Q_bar*C+R_bar;<span class="comment">% NP x NP </span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Prediction.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u_k</span>= <span class="title">Prediction</span><span class="params">(x_k,E,H,N,p)</span></span></span><br><span class="line">U_k = <span class="built_in">zeros</span>(N*p,<span class="number">1</span>); <span class="comment">% NP x 1</span></span><br><span class="line">U_k = quadprog(H,E*x_k);</span><br><span class="line">u_k = U_k(<span class="number">1</span>:p,<span class="number">1</span>); <span class="comment">% 取第一个结果</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>仿真的结果如下</p><p><img src="https://pic.imgdb.cn/item/66d2eef6d9c307b7e93b6f2e.png" alt="img"></p><p>使用<code>CasaDi Python API</code>重新实现了Dr_can视频里提到的示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> casadi <span class="keyword">as</span> ca</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统参数</span></span><br><span class="line">N = <span class="number">5</span>  <span class="comment"># 预测区间</span></span><br><span class="line">k_steps = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态矩阵A和输入矩阵B</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">0.1</span>], [-<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">B = np.array([[<span class="number">0.2</span>, <span class="number">1</span>], [<span class="number">0.5</span>, <span class="number">2</span>]])</span><br><span class="line">n = A.shape[<span class="number">0</span>]</span><br><span class="line">p = B.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q、F、R矩阵</span></span><br><span class="line">Q = np.diag([<span class="number">100</span>, <span class="number">1</span>])</span><br><span class="line">F = np.diag([<span class="number">100</span>, <span class="number">1</span>])</span><br><span class="line">R = np.diag([<span class="number">1</span>, <span class="number">0.1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义step的数量</span></span><br><span class="line">k_steps = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开辟所有状态x的存储空间并初始状态</span></span><br><span class="line">X_k = np.zeros((n, k_steps+<span class="number">1</span>))</span><br><span class="line">X_k[:,<span class="number">0</span>] = np.array([<span class="number">20</span>,-<span class="number">20</span>])</span><br><span class="line"><span class="comment"># 开辟所有控制输入u的存储空间</span></span><br><span class="line">U_k = np.zeros((p, k_steps))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算QP中代价函数相关的矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_QPMatrix</span>(<span class="params">A, B, Q, R, F, N</span>):</span><br><span class="line">    M = np.vstack([np.eye(n), np.zeros((N*n, n))])</span><br><span class="line">    C = np.zeros(((N+<span class="number">1</span>)*n, N*p))</span><br><span class="line">    temp = np.eye(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        rows = i * n + np.arange(n)</span><br><span class="line">        C[rows,:] = np.hstack([temp @ B, C[rows-n, :-p]])</span><br><span class="line">        temp = A @ temp</span><br><span class="line">        M[rows,:] = temp</span><br><span class="line"></span><br><span class="line">    Q_ = np.kron(np.eye(N), Q)</span><br><span class="line">    rows_Q, cols_Q = Q_.shape</span><br><span class="line">    rows_F, cols_F = F.shape</span><br><span class="line">    Q_bar = np.zeros((rows_Q+rows_F, cols_Q+cols_F))</span><br><span class="line">    Q_bar[:rows_Q, :cols_Q] = Q_</span><br><span class="line">    Q_bar[rows_Q:, cols_Q:] = F</span><br><span class="line">    R_bar = np.kron(np.eye(N), R)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># G = M.T @ Q_bar @ M</span></span><br><span class="line">    E = C.T @ Q_bar @ M</span><br><span class="line">    H = C.T @ Q_bar @ C + R_bar</span><br><span class="line">    <span class="keyword">return</span> E, H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义MPC优化问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mpc_prediction</span>(<span class="params">x_k, E, H, N, p</span>):</span><br><span class="line">    <span class="comment"># 定义优化变量</span></span><br><span class="line">    U = ca.SX.sym(<span class="string">&#x27;U&#x27;</span>, N * p)</span><br><span class="line">    <span class="comment"># 定义目标函数</span></span><br><span class="line">    objective = <span class="number">0.5</span> * ca.mtimes([U.T, H, U]) + ca.mtimes([U.T, E, x_k])</span><br><span class="line">    qp = &#123;<span class="string">&#x27;x&#x27;</span>: U, <span class="string">&#x27;f&#x27;</span>: objective&#125;</span><br><span class="line">    opts = &#123;<span class="string">&#x27;print_time&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;ipopt&#x27;</span>: &#123;<span class="string">&#x27;print_level&#x27;</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line">    solver = ca.nlpsol(<span class="string">&#x27;solver&#x27;</span>, <span class="string">&#x27;ipopt&#x27;</span>, qp, opts)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求解问题</span></span><br><span class="line">    sol = solver()</span><br><span class="line">    <span class="comment"># 提取最优解</span></span><br><span class="line">    U_k = sol[<span class="string">&#x27;x&#x27;</span>].full().flatten()</span><br><span class="line">    u_k = U_k[:p]  <span class="comment"># 取第一个结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u_k</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Get QP Matrix</span></span><br><span class="line">    E, H = get_QPMatrix(A, B, Q, R, F, N)</span><br><span class="line">    <span class="comment"># Simulation</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_steps):</span><br><span class="line">        x_k = X_k[:,i]</span><br><span class="line">        u_k = mpc_prediction(x_k, E, H, N, p)</span><br><span class="line">        x_k = A @ x_k + B @ u_k</span><br><span class="line">        X_k[:,i+<span class="number">1</span>] = x_k</span><br><span class="line">        U_k[:,i] = u_k</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制结果</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_k.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.plot(X_k[i, :], label=<span class="string">f&quot;x<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.title(<span class="string">&quot;State Variables&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;Time Step&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;State Value&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二个子图: 控制输入</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(U_k.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.plot(U_k[i, :], label=<span class="string">f&quot;u<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.title(<span class="string">&quot;Control Inputs&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;Time Step&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;Control Value&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调整布局并显示</span></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66d2ef0ed9c307b7e93b80b0.png" alt="img"></p><p>结果如下</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="https://www.bilibili.com/video/BV11B4y1X78N/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">MPC模型预测控制器</a><br>[2]<a href="https://www.youtube.com/watch?v=8U0xiOkDcmw&list=PLn8PRpmsu08ozoeoXgxPSBKLyd4YEHww8">Understanding Model Predictive Control</a><br>[3]<a href="https://github.com/tomcattiger1230/CasADi_MPC_MHE_Python/tree/master">CasADi_MPC_MHE_Python</a><br>[4]<a href="https://github.com/MMehrez/MPC-and-MHE-implementation-in-MATLAB-using-Casadi/tree/master">MPC-and-MHE-implementation-in-MATLAB-using-Casadi</a><br>[5]<a href="https://www.youtube.com/playlist?list=PLK8squHT_Uzej3UCUHjtOtm5X7pMFSgAL">MPC and MHE implementation in Matlab using Casadi</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制理论 </tag>
            
            <tag> 模型预测控制 </tag>
            
            <tag> MPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制障碍函数CBF详解（附带案例实现）</title>
      <link href="/2024/02/21/%E6%8E%A7%E5%88%B6%E9%9A%9C%E7%A2%8D%E5%87%BD%E6%95%B0CBF%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2024/02/21/%E6%8E%A7%E5%88%B6%E9%9A%9C%E7%A2%8D%E5%87%BD%E6%95%B0CBF%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="控制障碍函数CBF详解（附带案例实现）"><a href="#控制障碍函数CBF详解（附带案例实现）" class="headerlink" title="控制障碍函数CBF详解（附带案例实现）"></a>控制障碍函数CBF详解（附带案例实现）</h1><h2 id="1-Control-Affine-System"><a href="#1-Control-Affine-System" class="headerlink" title="1. Control Affine System"></a>1. Control Affine System</h2><p>一个控制仿射系统的典型形式是</p><p>$$<br>\dot{x} &#x3D; F(x,u)<br>$$</p><p>其中，$x\in \mathbb{R}^n$是系统的状态，$u\in\mathbb{R}^m$是系统的控制输入，$F$是Lipschitz连续的，这样就能保证给定一个初始状态$x(t_0)&#x3D;x_0$的时候，动态系统的轨迹$x(t)$存在且唯一。</p><p>我们通常处理的是非线性系统，那么我们可以将非线性的仿射系统写成如下的形式</p><p>$$<br>\dot{x} &#x3D; f(x) + g(x) u<br>$$</p><p>其中$f:\mathbb{R}^n \to \mathbb{R}^n$是系统的漂移向量场，它描述了系统在没有控制输入时的动态行为，$g:\mathbb{R}^n\to\mathbb{R}^{n\times m}$，是系统的控制向量场，它描述了系统的控制输入$u$是如何影响系统的。</p><h2 id="2-Lyapunov-Theory-Nagumo’s-Theory-Invariance-Principle"><a href="#2-Lyapunov-Theory-Nagumo’s-Theory-Invariance-Principle" class="headerlink" title="2. Lyapunov Theory, Nagumo’s Theory, Invariance Principle"></a>2. Lyapunov Theory, Nagumo’s Theory, Invariance Principle</h2><p><strong>Lyapunov Theory</strong></p><p>对于系统$\dot{x}&#x3D;f(x)$而言，$x\in \mathbb{R}^n$是系统的状态，$f:\mathbb{R}^n \to \mathbb{R}^n$是一个系统状态的映射函数。如果</p><p>$$<br>\exists V(x)\<br>\text{s.t. } V(x_e) &#x3D; 0, V(x)&gt;0 \text{ for } x \ne x_e,\<br>\dot{V}(x) &#x3D; \frac{\partial V}{\partial x} f(x) &lt; 0 \text{ for } x\ne x_e<br>$$</p><p>那么系统则是稳定的。并且状态$x$所构成的集合，可以被称为是一个不变集（Invariance set）。</p><p><strong>不变集合：</strong> 集合$\mathcal{C}$被称为不变的，如果系统从$\mathcal{C}$内的任意一点开始演化，那么系统的轨迹始终停留在$\mathcal{C}$内。</p><p><strong>Nagumo’s Theory</strong></p><p>对于系统$\dot{x} &#x3D; f(x)$而言，$x\in \mathbb{R}^n$是系统的状态，$\mathcal{C}&#x3D;{x|h(x)\ge0}$是映射$h:\mathbb{R}^n \to \mathbb{R}$的一个上水平集，如果</p><p>$$<br>\dot{h}(x) \ge 0\<br>\forall x\in\partial\mathcal{C}<br>$$</p><p>那么$\mathcal{C}$是一个不变集。符号的具体含义如下：</p><p>$$<br>\begin{align*}<br>    \mathcal{C} &amp; &#x3D; { x\in D\sub \mathbb{R}^n: h(x) \ge 0 },\<br>    \partial\mathcal{C} &amp; &#x3D; { x\in D\sub \mathbb{R}^n: h(x) &#x3D; 0 }, \<br>    \text{Int}(\mathcal{C}) &amp; &#x3D; { x\in D\sub \mathbb{R}^n: h(x) &gt; 0 },<br>\end{align*}<br>$$</p><p>集合$\mathcal{C}$是安全集，$\partial\mathcal{C}$是安全集的边界，$\text{Int}(\mathcal{C})$是安全集的内部点。</p><h2 id="3-Control-Lyapunov-Function-CLF-and-CLF-QP"><a href="#3-Control-Lyapunov-Function-CLF-and-CLF-QP" class="headerlink" title="3. Control Lyapunov Function (CLF) and CLF-QP"></a>3. Control Lyapunov Function (CLF) and CLF-QP</h2><p><strong>Control Lyapunov Function</strong></p><p>设$V(x):\mathbb{R}^n \to \mathbb{R}$是一个连续可微的函数，如果这里存在一个常量$c&gt;0$使得</p><p>$$<br>\begin{align*}<br>&amp; \text{1) }\Omega_c :&#x3D; { x\in\mathbb{R}^n: V(x) \le c}, \text{ a sublevel set of } V(x) \text{ is bounded}\<br>&amp; \text{2) }V(x)  &gt; 0, \forall s \in\mathbb{R}^n \backslash {x_e}, V(x_e) &#x3D; 0\<br>&amp; \text{3) }\inf_{u\in U} \dot{V}(x,u)  &lt; 0, \forall x \in \Omega_c \backslash {x_e}<br>\end{align*}<br>$$</p><p>1）存在一个子集，使得$V(x)\le c$是有界的</p><p>2）Lyapunov函数不在原点时大于零，在原点时等于零</p><p>3）对于控制量和系统状态来说，总使得$V(x)$的导数$\dot{V}(x)$小于零。</p><p>其中，$V(x)$可以被称为局部控制李雅普诺夫函数，$\Omega_c$是一个引力区（Region of Attraction, ROA），$\Omega_c$中的每一个点都会收敛到$x_e$，整个轨迹就如下图所示，会一直保持在这个区域内，并且最终收敛到$x_e$，这其实就是一种渐进稳定。</p><p><img src="https://pic.imgdb.cn/item/66d2b31dd9c307b7e9ea5788.png" alt="img"></p><p>我们可以将导数显示地写出来</p><p>$$<br>\begin{align*}<br>\dot{V}(x) &amp; &#x3D; \nabla V(x) \dot{x}\<br>&amp; &#x3D; \nabla V(x)f(x) + \nabla V(x)g(x)u\<br>&amp; &#x3D; L_fV(x) + L_g V(x) u<br>\end{align*}<br>$$</p><p>其中$L_p q(x) &#x3D; \nabla q(x) \cdot p(x)$是李导数算子，使得公式更加简洁。</p><p>为了使收敛更加迅速，我们需要考虑收敛的时间限制，指数收敛是一种快速的方式，所以我们希望最终的结果能够按照指数的方式进行收敛。</p><p>我们可以增加一个判断条件，设$V(x):\mathbb{R}^n \to \mathbb{R}$是连续可微、正定、有界的函数，如果$\exists \lambda&gt;0$使得</p><p>$$<br>\text{4) }\inf_{u\in U} \dot{V}(x,u) + \lambda V(x) \le 0<br>$$</p><p>或者写成</p><p>$$<br>\inf_{u\in U} [L_f V(x) + L_gV(x)u] + \lambda V(x) \le 0<br>$$</p><p>那么$V(x)$就是指数稳定的控制李雅普诺夫函数（exponentially stabilizing CLF，ES-CLF），其中$\lambda$是$V(x(t))$上界的衰减率。</p><p><img src="https://pic.imgdb.cn/item/66d2b481d9c307b7e9eddffb.png" alt="img"></p><p><strong>Control Lyapunov Function  Quadratic Program</strong></p><p><img src="https://pic.imgdb.cn/item/66d2b493d9c307b7e9ee1147.png" alt="img"></p><p>CLF约束对于$u$是线性的，因此用最小范数控制器，二次规划的目标位最小化控制量，受限制为，满足李雅普诺夫函数收敛的上界以及控制量 $u$在解集内。由于这个优化为一个凸优化问题，因此其实时性是可以被保证的，CLF约束通常用松弛变量来保证问题的可行性，如果没有松弛变量，控制器将指数稳定到系统原点$x_e$</p><h2 id="4-Control-Barrier-Function-CBF-and-CBF-CLF-QP"><a href="#4-Control-Barrier-Function-CBF-and-CBF-CLF-QP" class="headerlink" title="4. Control Barrier Function (CBF) and CBF-CLF-QP"></a>4. Control Barrier Function (CBF) and CBF-CLF-QP</h2><p>设$B(x):\mathbb{R}^n \to \mathbb{R}$是连续、可微的函数，$\mathcal{C}&#x3D;{x|B(x)\ge 0}$是该函数的零上水平集，并且$\nabla B(x)\ne 0,\forall x\in\partial\mathcal{C}$，如果$\exists \gamma$使得$\forall x\in\mathcal{C}$</p><p>$$<br>\sup_{u \in U}[L_fB(x) + L_g B(x)u] + \gamma B(x) \ge 0<br>$$</p><p>那么$B(x)$就被称作Control Barrier Function</p><p><img src="https://pic.imgdb.cn/item/66d2b4a8d9c307b7e9ee4dd5.png" alt="img"></p><p>因此这个二次规划问题就变成了</p><p><img src="https://pic.imgdb.cn/item/66d2b4c1d9c307b7e9ee98ff.png" alt="img"></p><h2 id="5-A-Toy-Example"><a href="#5-A-Toy-Example" class="headerlink" title="5. A Toy Example"></a>5. A Toy Example</h2><p>我们考虑一个简单的例子，在这个例子中有两辆车辆，分别是<code>lead vehicle</code>和<code>ego vehicle</code>，如下图所示</p><p><img src="https://pic.imgdb.cn/item/66d2b4d7d9c307b7e9eeca7a.png" alt="img"></p><p>下面我们先推导一下，然后再进行仿真验证。</p><h3 id="5-1-Derivation"><a href="#5-1-Derivation" class="headerlink" title="5.1 Derivation"></a>5.1 Derivation</h3><p>设计我们的状态量为：$x &#x3D; [p, v, z]^T \in \mathbb{R}^3$，系统的微分方程为：</p><p>$$<br>\begin{align*}<br>    \dot{p} &amp; &#x3D; v\<br>    \dot{v} &amp; &#x3D; \frac{u - F_r(v)}{m}, \quad F_r(v) &#x3D; f_0 + f_1 v + f_2 v^2 \<br>    \dot{z} &amp; &#x3D; v_0 - v<br>\end{align*}<br>$$</p><p>其中<code>F_r(v)</code>是摩擦力，将微分方程写成矩阵的形式</p><p>$$<br>\dot{x} &#x3D;<br>\begin{bmatrix}<br>    \dot{p}\<br>    \dot{v} \<br>    \dot{z}\<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>    v\<br>    -\frac{1}{m} F_r(v)\<br>    v_0 - v<br>\end{bmatrix} +<br>\begin{bmatrix}<br>    0\<br>    \frac{1}{m}\<br>    0<br>\end{bmatrix} u<br>$$</p><p>为了保障系统的安全性，给系统的输入做如下的限制</p><p>$$<br>-mc_dg \le u \le mc_ag<br>$$</p><p><code>ego vehicle</code>的目标速度为</p><p>$$<br>v \to v_d<br>$$</p><p>最小安全距离必须满足时间前瞻量的限制$T_h$</p><p>$$<br>z \ge T_h v<br>$$</p><p>系统的平衡点$x_e &#x3D; [\cdot, v_d, \cdot]^T$设计Lyapunov Function $V(x)$</p><p>$$<br>\begin{align*}<br>    V(x) &amp; &#x3D; (v - v_d)^2\<br>    \dot{V}(x) &amp; &#x3D; \nabla V(x) \dot{x}\<br>\end{align*}<br>$$</p><p>其中</p><p>$$<br>\nabla V(x) &#x3D; [0, 2(v-v_d), 0]\<br>\dot{x} &#x3D;<br>\begin{bmatrix}<br>    v\<br>    -\frac{1}{m} F_r(v)\<br>    v_0 - v<br>\end{bmatrix} +<br>\begin{bmatrix}<br>    0\<br>    \frac{1}{m}\<br>    0<br>\end{bmatrix}u<br>$$</p><p>然后我们可以获得</p><p>$$<br>L_f V(x) &#x3D; -\frac{2}{m} F_r(v)(v-v_d)\<br>L_g V(x) &#x3D; \frac{2}{m} (v-v_d)<br>$$</p><p>所以CLF的约束$\inf_{u\in U} \quad[L_f V(x) + L_g V(x)u] + \lambda V(x) \le 0$可以表示为</p><p>$$<br>\inf_{u\in U} \quad(v-v_d) [\frac{2}{m} (u-F_r) + \lambda (v-v_d)] \le 0<br>$$</p><p>保障安全性的目标是$z\ge T_h V$，则设计CBF</p><p>$$<br>B(x) &#x3D; z - T_h V<br>$$</p><p>则有</p><p>$$<br>\nabla B(x) &#x3D; [0, -T_h, 1]\<br>L_f B(x) &#x3D; \frac{T_h}{m} F_r + (v_0 - v), \quad L_g B(x) &#x3D; -\frac{T_h}{m}<br>$$</p><p>所以CBF的约束$\sup_{u\in U} \quad [L_f B(x) + L_g B(x)u] + \gamma B(x) \ge 0$ 可以表示为</p><p>$$<br>\frac{T_h}{m}(F_r - u) + (v_0 - v) + \gamma (z - T_h v) \ge 0<br>$$</p><p>忽略$F_r$，当$u&#x3D;-mc_dg$的时候，CBF的约束可以表示为</p><p>$$<br>T_h c_d g + v_0 + \gamma z - (1+T_h \gamma)v<br>$$</p><p>当$v$足够大的时候，可能会导致CBF的约束小于0，所以我们需要重新设计CBF</p><p>$$<br>B(x) &#x3D; z - T_hv - \textcolor{blue}{\frac{1}{2} \frac{(v-v_0)^2}{c_dg}}<br>$$</p><p>则有</p><p>$$<br>\dot{B}(x,u) &#x3D; \frac{1}{m} (T_h + \textcolor{blue}{\frac{v-v_0}{c_dg}})(F_r(v) - u) + (v_0 - v)<br>$$</p><p>当$u&#x3D;-mc_dg$的时候，$\dot{B}(x,u) &#x3D; \frac{1}{m}T_h F_r + T_h c_dg &gt; 0$，所以此CBF是一个可行的CBF，那么我们最终获得的CLF-CBF-QP为</p><p>$$<br>\begin{align*}<br>    \arg\min &amp; \quad u^T Hu\<br>    \text{s.t.} &amp; \quad (v-v_d)[\frac{2}{m}(u-F_r) + \lambda(v-v_d)]\le 0\<br>    &amp; \quad \frac{1}{m}(T_h + \frac{(v-v_0)}{c_d g})(F_r - u) + (v_0 - v) + \gamma (z - T_h v) \ge 0\<br>    &amp; \quad -m c_d g \le u \le m c_a g<br>\end{align*}<br>$$</p><h3 id="5-2-Simulation"><a href="#5-2-Simulation" class="headerlink" title="5.2 Simulation"></a>5.2 Simulation</h3><p>使用python来编写脚本代码，使用<code>cvxopt</code>凸优化的库来进行求解，具体可以参考<a href="https://cvxopt.org/">cvxopt的wiki官网</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> cvxopt <span class="keyword">import</span> matrix, solvers</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulation parameters</span></span><br><span class="line">dt = <span class="number">0.02</span></span><br><span class="line">T = <span class="number">30</span></span><br><span class="line">length = <span class="built_in">int</span>(np.ceil(T / dt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># System initialization</span></span><br><span class="line">p = np.zeros((length + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">v = np.zeros((length + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">z = np.zeros((length + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">u = np.zeros((length, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">sys = &#123;</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span>: <span class="number">1650</span>,</span><br><span class="line">    <span class="string">&#x27;g&#x27;</span>: <span class="number">9.81</span>,</span><br><span class="line">    <span class="string">&#x27;v0&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="string">&#x27;vd&#x27;</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="string">&#x27;f0&#x27;</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&#x27;f1&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;f2&#x27;</span>: <span class="number">0.25</span>,</span><br><span class="line">    <span class="string">&#x27;ca&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;cd&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>: <span class="number">1.8</span>,</span><br><span class="line">    <span class="string">&#x27;clf_rate&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;cbf_rate&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;weight_input&#x27;</span>: <span class="number">2</span> / <span class="number">1650</span>**<span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;weight_slack&#x27;</span>: <span class="number">2e-2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sys[<span class="string">&#x27;u_max&#x27;</span>] = sys[<span class="string">&#x27;ca&#x27;</span>] * sys[<span class="string">&#x27;m&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">sys[<span class="string">&#x27;u_min&#x27;</span>] = -sys[<span class="string">&#x27;cd&#x27;</span>] * sys[<span class="string">&#x27;m&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial conditions</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">v[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">z[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulation loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    current_p = p[i, <span class="number">0</span>]</span><br><span class="line">    current_v = v[i, <span class="number">0</span>]</span><br><span class="line">    current_z = z[i, <span class="number">0</span>]</span><br><span class="line">    x = np.array([current_p, current_v, current_z])</span><br><span class="line">    </span><br><span class="line">    F_r = sys[<span class="string">&#x27;f0&#x27;</span>] + sys[<span class="string">&#x27;f1&#x27;</span>] * current_v + sys[<span class="string">&#x27;f2&#x27;</span>] * current_v**<span class="number">2</span></span><br><span class="line">    f = np.array([current_v, -F_r / sys[<span class="string">&#x27;m&#x27;</span>], sys[<span class="string">&#x27;v0&#x27;</span>] - current_v])</span><br><span class="line">    g = np.array([<span class="number">0</span>, <span class="number">1</span> / sys[<span class="string">&#x27;m&#x27;</span>], <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    V = (current_v - sys[<span class="string">&#x27;vd&#x27;</span>])**<span class="number">2</span></span><br><span class="line">    dV = np.array([<span class="number">0</span>, <span class="number">2</span> * (current_v - sys[<span class="string">&#x27;vd&#x27;</span>]), <span class="number">0</span>])</span><br><span class="line">    LfV = np.dot(dV, f)</span><br><span class="line">    LgV = np.dot(dV, g)</span><br><span class="line">    B = current_z - sys[<span class="string">&#x27;T&#x27;</span>] * current_v - <span class="number">0.5</span> * (current_v - sys[<span class="string">&#x27;v0&#x27;</span>])**<span class="number">2</span> / (sys[<span class="string">&#x27;cd&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">    dB = np.array([<span class="number">0</span>, -sys[<span class="string">&#x27;T&#x27;</span>] - (current_v - sys[<span class="string">&#x27;v0&#x27;</span>]) / (sys[<span class="string">&#x27;cd&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>]), <span class="number">0</span>])</span><br><span class="line">    LfB = np.dot(dB, f)</span><br><span class="line">    LgB = np.dot(dB, g)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Quadratic program</span></span><br><span class="line">    H_ = np.array([[sys[<span class="string">&#x27;weight_input&#x27;</span>], <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">0</span>, sys[<span class="string">&#x27;weight_slack&#x27;</span>]]])</span><br><span class="line">    f_ = np.array([-sys[<span class="string">&#x27;weight_input&#x27;</span>] * F_r, <span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    A_ = np.array([[LgV, -<span class="number">1</span>], </span><br><span class="line">                   [-LgB, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                   [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    b_ = np.array([-LfV - sys[<span class="string">&#x27;clf_rate&#x27;</span>] * V, </span><br><span class="line">                   LfB + sys[<span class="string">&#x27;cbf_rate&#x27;</span>] * B,</span><br><span class="line">                   sys[<span class="string">&#x27;u_max&#x27;</span>],</span><br><span class="line">                   -sys[<span class="string">&#x27;u_min&#x27;</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Convert to cvxopt format</span></span><br><span class="line">    P = matrix(H_)</span><br><span class="line">    q = matrix(f_)</span><br><span class="line">    G = matrix(A_)</span><br><span class="line">    h = matrix(b_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve QP problem using cvxopt</span></span><br><span class="line">    sol = solvers.qp(P, q, G, h)</span><br><span class="line">    u_opt = sol[<span class="string">&#x27;x&#x27;</span>][<span class="number">0</span>] <span class="comment"># Second term is the slack variable</span></span><br><span class="line"></span><br><span class="line">    dx = f + g * u_opt</span><br><span class="line">    x_n = x + dx * dt</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save data</span></span><br><span class="line">    u[i, <span class="number">0</span>] = u_opt</span><br><span class="line">    <span class="keyword">if</span> i &lt; length:</span><br><span class="line">        p[i + <span class="number">1</span>, <span class="number">0</span>] = x_n[<span class="number">0</span>]</span><br><span class="line">        v[i + <span class="number">1</span>, <span class="number">0</span>] = x_n[<span class="number">1</span>]</span><br><span class="line">        z[i + <span class="number">1</span>, <span class="number">0</span>] = x_n[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plotting</span></span><br><span class="line">time = np.arange(<span class="number">0</span>, T + dt, dt)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(time, p)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time, v)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(time, z)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">plt.plot(time[:-<span class="number">1</span>], u)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time (s)&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最后的结果如下</p><p><img src="https://pic.imgdb.cn/item/66d2b4f7d9c307b7e9ef2b78.png" alt="img"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="https://www.youtube.com/watch?v=_Tkn_Hzo4AA&t=3550s">Jason Choi – Introduction to Control Lyapunov Functions and Control Barrier Functions</a><br>[2]<a href="https://github.com/HybridRobotics/CBF-CLF-Helper">CBF-CLF-Helper</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制理论 </tag>
            
            <tag> 控制障碍函数 </tag>
            
            <tag> CBF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp复习 Chapter 5 类的继承、虚函数、抽象基类</title>
      <link href="/2024/02/15/Cpp%E5%A4%8D%E4%B9%A0-Chapter-5-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
      <url>/2024/02/15/Cpp%E5%A4%8D%E4%B9%A0-Chapter-5-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-Chapter-5-类的继承、虚函数、抽象基类"><a href="#Cpp复习-Chapter-5-类的继承、虚函数、抽象基类" class="headerlink" title="Cpp复习 Chapter 5 类的继承、虚函数、抽象基类"></a>Cpp复习 Chapter 5 类的继承、虚函数、抽象基类</h1><hr><center><font color=“#EEFFAA” size=56>Cpp系列笔记目录</font></center><p><strong><a href="https://blog.csdn.net/qq_44940689/article/details/140938473?spm=1001.2014.3001.5502">【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140951702?spm=1001.2014.3001.5502">【Cpp筑基】二、声明 vs 定义、头文件、存储持续性作用域和链接性、名称空间</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140962363?spm=1001.2014.3001.5502">【Cpp筑基】三、对象和类</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141018490?spm=1001.2014.3001.5501">【Cpp筑基】四、重载运算符、友元、类的转换函数</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141067994?spm=1001.2014.3001.5501">【Cpp筑基】五、类的继承、虚函数、抽象基类</a></strong></p><hr><h2 id="1-类的继承"><a href="#1-类的继承" class="headerlink" title="1. 类的继承"></a>1. 类的继承</h2><p>在C++中，类的继承（inheritance）是一种创建新类（派生类）的方式，该新类可以从现有的类（基类）中继承属性和方法。继承是面向对象编程的一个核心特性，允许代码复用并提供了实现多态性的基础。从一个类派生出另一个类时，原始类被称为基类，继承类被称为派生类。</p><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><p>C++中，继承使用的是冒号<code>:</code>来指明基类。派生类从基类继承成员（成员变量和成员函数）。语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="comment">// 基类成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> : access-specifier BaseClass &#123;</span><br><span class="line">    <span class="comment">// 派生类成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>access-specifier</code>用于指定访问控制权限，可以指定三种访问控制权限：</p><ul><li><code>public</code>继承：基类的<code>public</code>成员在派生类中保持为<code>public</code>，<code>protected</code>成员保持为<code>protected</code>，<code>private</code>成员不可访问。</li><li><code>protected</code>继承：基类的<code>public</code>成员和<code>protected</code>成员在派生类中都变为<code>protected</code>，<code>private</code>成员不可访问。</li><li><code>private</code>继承：基类的<code>public</code>成员和<code>protected</code>成员在派生类中都变为<code>private</code>，<code>private</code>成员不可访问。</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePlus</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar -&gt; public</span></span><br><span class="line">    <span class="comment">// protectedVar -&gt; protected</span></span><br><span class="line">    <span class="comment">// privateVar -&gt; 不可访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在完成继承之后，派生类储存了基类的数据成员（派生类继承了基类的实现）；派生类对象可以使用基类的方法（派生类继承了基类的接口）。</p><h3 id="1-2-派生类的构造和析构函数"><a href="#1-2-派生类的构造和析构函数" class="headerlink" title="1.2 派生类的构造和析构函数"></a>1.2 派生类的构造和析构函数</h3><p>在C++中的继承关系中，构造函数和析构函数的调用顺序和方式有其特定的规则。这些规则确保了基类和派生类的对象在构造和销毁时都能正确初始化和清理。下面将详细介绍这些规则以及构造和析构函数在继承中的使用方式</p><ul><li>构造函数：&#x3D;&#x3D;派生类的构造函数调用时，会首先调用基类的构造函数。基类构造函数可以在初始化列表中显式调用&#x3D;&#x3D;。</li><li>析构函数：&#x3D;&#x3D;析构函数的调用顺序与构造函数相反，首先调用派生类的析构函数，然后自动调用基类的析构函数&#x3D;&#x3D;。</li></ul><p>派生类不能直接访问基类中的私有<code>private</code>成员，而必须通过基类方法进行访问（即必须使用基类的方法来访问私有的基类成员变量），这就意味着&#x3D;&#x3D;派生类的构造函数必须使用基类的构造函数&#x3D;&#x3D;。当你创建派生类的对象时，基类的构造函数总是会被调用。这是因为派生类继承了基类的成员，基类部分需要在派生类的构造函数执行之前被初始化。</p><p><font color=blue>显式调用</font>：在派生类的构造函数中，你可以通过初始化列表显式调用基类的某个构造函数。这在你需要传递参数给基类的构造函数时是必要的。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// 基类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">Base</span>(x) &#123;  <span class="comment">// 显式调用基类构造函数</span></span><br><span class="line">        <span class="comment">// 派生类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color=blue>隐式调用</font>：如果你在派生类的构造函数中没有显式调用基类的构造函数，编译器会自动调用基类的默认构造函数（如果存在）。但如果基类没有默认构造函数，而你又没有在派生类中显式调用基类的其他构造函数，那么代码将无法编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        <span class="comment">// 基类默认构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="comment">// 派生类构造函数，隐式调用Base()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类构造函数的要点如下：</p><ul><li>首先创建基类对象；</li><li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；</li><li>派生类构造函数应初始化派生类新增的数据成员。</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal Constructor: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string furColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 使用基类的构造函数来初始化基类的成员，然后初始化派生类的成员</span></span><br><span class="line">    <span class="built_in">Mammal</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; furColor)</span><br><span class="line">        : <span class="built_in">Animal</span>(name, age), <span class="built_in">furColor</span>(furColor) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Mammal Constructor: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-基类和派生类的关系"><a href="#1-3-基类和派生类的关系" class="headerlink" title="1.3 基类和派生类的关系"></a>1.3 基类和派生类的关系</h3><p>派生类和基类之间存在一些关系：</p><ul><li>派生类可以使用基类的非私有<code>private</code>方法；</li><li>基类指针可以在不进行显示类型转换的情况下指向派生类；</li><li>基类引用可以在不进行显示类型转换的情况下引用派生类；</li><li>基类指针或引用只能调用基类的方法，而不能调用派生类的方法。（这一点非常好理解，因为派生类会存在一些基类没有的成员变量，当派生类方法可能会操作这些变量，所以基类方法不能调用派生类的方法）</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal是基类, Dog是派生类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// 基类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; makes a sound!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类：Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写基类方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; barks!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wagTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is wagging its tail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 1. 基类指针可以指向派生类对象</span></span><br><span class="line">    Animal* animalPtr = &amp;myDog;</span><br><span class="line">    <span class="comment">// 2. 基类引用可以引用派生类对象</span></span><br><span class="line">    Animal&amp; animalRef = myDog;</span><br><span class="line">    <span class="comment">// 调用基类方法</span></span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();  <span class="comment">// 输出: Buddy makes a sound!</span></span><br><span class="line">    animalRef.<span class="built_in">displayInfo</span>(); <span class="comment">// 输出: Animal Name: Buddy</span></span><br><span class="line">    <span class="comment">// 注意：通过基类指针或引用，不能直接调用派生类的方法</span></span><br><span class="line">    <span class="comment">// animalPtr-&gt;wagTail(); // 错误：Animal类没有wagTail方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-多态公有继承"><a href="#1-4-多态公有继承" class="headerlink" title="1.4 多态公有继承"></a>1.4 多态公有继承</h3><p>派生类可能会遇到这样的情况，希望同一个方法在派生类和基类中的行为是不同的，换句话来说，方法的行为应该取决于调用该方法的对象，这种较为复杂的行为称为多态——具有多种形态，即同一个方法随上下文而异。有两种方式可以实现多态公有继承：</p><ul><li>在派生类中&#x3D;&#x3D;重写override，也称为覆盖&#x3D;&#x3D;基类方法</li><li>使用虚函数（在下一节中介绍）</li></ul><p><font color=blue>在派生类中重写基类方法</font>，如上面的例子中，我们在派生来<code>Dog</code>中覆盖了基类<code>Animal</code>中的<code>makeSound()</code>方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; makes a sound!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类：Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 覆盖基类方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; barks!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>)</span></span>;</span><br><span class="line">Animal* animalPtr = &amp;myDog;</span><br><span class="line">Dog* dogPtr = &amp;myDog;</span><br><span class="line"><span class="comment">// 基类指针调用基类方法，不能调用派生类方法</span></span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();  <span class="comment">// 输出: Buddy makes a sound!</span></span><br><span class="line">    <span class="comment">// 派生类指针调用派生类方法</span></span><br><span class="line">    dogPtr-&gt;<span class="built_in">makeSound</span>();<span class="comment">// 输出: Buddy barks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单区别一下重载与覆盖</p><ul><li>&#x3D;&#x3D;重载（Overloading）&#x3D;&#x3D;：在同一个类中，具有相同名称但参数列表不同的方法被称为重载。</li><li>&#x3D;&#x3D;覆盖（Overriding）&#x3D;&#x3D;：派生类中的方法与基类的方法具有相同的名称和参数列表，但派生类的方法会“覆盖”基类的方法。这种覆盖通常通过<code>virtual</code>关键字来实现动态多态性。<br>如果你不使用<code>virtual</code>，那么派生类的方法虽然可以覆盖基类的方法，但当你通过基类指针或引用调用这个方法时，不会调用派生类的方法，而是调用基类的方法。这是因为在没有<code>virtual</code>的情况下，方法调用是&#x3D;&#x3D;静态绑定&#x3D;&#x3D;的。</li></ul><h2 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2. 虚函数"></a>2. 虚函数</h2><p>虚函数（Virtual Function）是一个在基类中使用 virtual 关键字声明的成员函数，它允许派生类重写这个函数。虚函数的主要目的是支持&#x3D;&#x3D;运行时多态&#x3D;&#x3D;性，使得通过基类指针或引用可以调用派生类的重写版本，而不是基类的版本。</p><p>在上面的例子中，我们希望当我们使用基类指针指向派生类对象的时候，能够调用派生类的方法，这样我们就可以使用基类指针来管理派生类的对象了。这就需要用到<code>virtual</code>关键字所代表的虚函数，我们将上述例子中的<code>makeSound()</code>函数改写成虚函数的形式，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal是基类, Dog,Cat是派生类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// 基类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; makes a sound!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类：Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写基类方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; barks!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wagTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is wagging its tail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类：Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写基类方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; miao!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;Buddy&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Cat <span class="title">myCat</span><span class="params">(<span class="string">&quot;Kitty&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 1. 基类指针可以指向派生类对象</span></span><br><span class="line">    Animal* animalPtr = &amp;myDog;</span><br><span class="line">    <span class="comment">// 2. 基类引用可以引用派生类对象</span></span><br><span class="line">    Animal&amp; animalRef = myCat;</span><br><span class="line">    <span class="comment">// 调用基类方法</span></span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();  <span class="comment">// 输出: Buddy barks!</span></span><br><span class="line">    animalRef.<span class="built_in">makeSound</span>(); <span class="comment">// 输出: Kitty miao!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意上面例子中<code>virtual</code>与<code>override</code>关键字的用法，<code>virtual</code>关键字用于指定函数在运行时支持动态绑定，这意味着通过基类指针或引用调用该函数时，会调用派生类中对应的重写函数，而不是基类版本。<code>override</code>关键字用于派生类的成员函数定义中，指示该函数是对基类中虚函数的重写，但注意在某些Cpp标准中，<code>override</code>不是必须的，但是尽量需要加上<code>override</code>用于指定该成员函数是重写基类的虚函数。</p><h3 id="2-1-静态联编与动态联编"><a href="#2-1-静态联编与动态联编" class="headerlink" title="2.1 静态联编与动态联编"></a>2.1 静态联编与动态联编</h3><p>程序调用函数时，将使用哪个可执行代码呢？编译器负责回答这个问题，将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding），在C语言中，这非常简单，因为每个函数名都对应一个不同的函数，在Cpp中，由于函数重载的缘故，这项任务更复杂，编译器必须查看函数参数以及函数名才能确定使用哪个函数，然而，C&#x2F;C++编译器可以在编译过程中完成这种联编，在编译过程中进行联编被称为&#x3D;&#x3D;静态联编（static binding）&#x3D;&#x3D;。然而虚函数的出现让这项工作变得困难，所以编译器必须能够在程序运行时选择正确的虚函数方法的代码，这被称为&#x3D;&#x3D;动态联编（dynamic binding）&#x3D;&#x3D;。</p><p>这里存在一个类型提升的问题，&#x3D;&#x3D;将派生类引用或指针转为基类引用或指针被称为向上强制转换（upcasting）&#x3D;&#x3D;，这是因为派生类是继承自基类，拥有基类对象的所有数据成员和成员函数，这种转换是可以允许的，举个例子，现在有基类<code>Animal</code>和派生类<code>Cat</code>，我们可以这样做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBasePtr</span><span class="params">(Animal an)</span></span>;</span><br><span class="line">Cat mycat;</span><br><span class="line"><span class="built_in">useBasePtr</span>(mycat);<span class="comment">//相当于，(Animal)mycat，将mycat对象从Cat类型转化为Animal类型了</span></span><br></pre></td></tr></table></figure><p>相反的过程——&#x3D;&#x3D;将基类指针或引用转换为派生类指针或引用被称为向下强制转换（downcasting）&#x3D;&#x3D;，如果不使用显示类型转换，则向下类型转换是不被允许的。举一个完整的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal是基类, Dog是派生类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// 基类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; makes a sound!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类：Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重写基类方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; miao!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fr</span><span class="params">(Animal* an)</span> </span>&#123;</span><br><span class="line">    an-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fp</span><span class="params">(Animal&amp; an)</span> </span>&#123;</span><br><span class="line">    an.<span class="built_in">makeSound</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fv</span><span class="params">(Animal an)</span> </span>&#123;</span><br><span class="line">    an.<span class="built_in">makeSound</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Cat <span class="title">myCat</span><span class="params">(<span class="string">&quot;Kitty&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">fr</span>(&amp;myCat);         <span class="comment">// use Cat::makeSound()</span></span><br><span class="line">    <span class="built_in">fp</span>(myCat);          <span class="comment">// use Cat::makeSound()</span></span><br><span class="line">    <span class="built_in">fv</span>(myCat);          <span class="comment">// use Animal::makeSound(),向上强制转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-虚函数表与虚函数指针"><a href="#2-2-虚函数表与虚函数指针" class="headerlink" title="2.2 虚函数表与虚函数指针"></a>2.2 虚函数表与虚函数指针</h3><p>在C++中，虚函数的实现依赖于两个重要的概念：虚函数表（Virtual Table，vtable）和虚函数指针（Virtual Table Pointer，vptr）。它们是实现动态联编和多态性的核心机制。</p><p><strong>虚函数表</strong>是编译器为每一个包含虚函数的类生成的一个隐式结构。这个结构包含了指向该类的虚函数实现的指针列表。每个包含虚函数的类（或派生类）都会有一个虚函数表。</p><p><strong>特点</strong>：</p><ul><li>虚函数表是一个表格，包含了该类中所有虚函数的地址。</li><li>如果一个类没有虚函数，那么它不会有虚函数表。</li><li>派生类继承了基类的虚函数表，并且可以覆盖或扩展虚函数表。</li></ul><p><strong>工作方式</strong>：</p><ul><li>当程序运行时，如果通过基类指针或引用调用虚函数，编译器会查找对象的虚函数表，并使用其中的函数指针调用实际的函数实现。</li></ul><p><strong>虚函数指针</strong>是每个对象中隐含的指针，指向该对象所属类的虚函数表。每个包含虚函数的对象都有一个虚函数指针（vptr），这个指针在对象的构造函数中被自动初始化，指向正确的虚函数表。</p><p><strong>特点</strong>：</p><ul><li>vptr是对象的一部分，通常由编译器隐式管理。</li><li>当对象创建时，构造函数会设置vptr指向正确的虚函数表。</li><li>在派生类对象中，vptr指向派生类的虚函数表。</li></ul><p><strong>工作方式</strong>：</p><ul><li>当对象调用虚函数时，编译器通过vptr查找到对应的虚函数表，并根据表中的指针调用适当的函数实现。</li><li>如果派生类重写了基类的虚函数，派生类的虚函数表会指向新的函数实现，而不是基类的实现。</li></ul><h3 id="2-2-构造函数与析构函数，谁应该是虚函数？"><a href="#2-2-构造函数与析构函数，谁应该是虚函数？" class="headerlink" title="2.2 构造函数与析构函数，谁应该是虚函数？"></a>2.2 构造函数与析构函数，谁应该是虚函数？</h3><p>&#x3D;&#x3D;构造函数不能是虚函数&#x3D;&#x3D;，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将构造函数声明为虚<code>virtual</code>的没有意义。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base show()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived show()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;  <span class="comment">// 构造顺序：Base Constructor -&gt; Derived Constructor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;析构函数应该是虚函数&#x3D;&#x3D;，原因是在面向对象编程中，如果通过基类指针删除一个派生类对象，而基类的析构函数不是虚函数，程序将只调用基类的析构函数，派生类的析构函数不会被调用。这会导致派生类中动态分配的资源没有被正确释放，造成内存泄漏等问题。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> basePtr;  <span class="comment">// 正确调用Base和Derived的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-抽象基类"><a href="#3-抽象基类" class="headerlink" title="3. 抽象基类"></a>3. 抽象基类</h2><p>在C++中，纯虚函数和抽象基类是实现抽象和接口的一种机制，用于创建不能直接实例化的类，并强制派生类提供具体的实现。这是面向对象编程中的关键概念，尤其在设计框架、库和接口时非常有用。</p><h3 id="3-1-纯虚函数"><a href="#3-1-纯虚函数" class="headerlink" title="3.1 纯虚函数"></a>3.1 纯虚函数</h3><p>纯虚函数是一种没有实现的虚函数。它只在基类中声明，必须在派生类中被重写。&#x3D;&#x3D;纯虚函数的存在使得一个类成为抽象类，不能被直接实例化&#x3D;&#x3D;。</p><p>特点：</p><ul><li>纯虚函数在声明时没有函数体（即可以不提供抽象基类的函数体），用<code>=0</code>来表示。</li><li>任何包含一个或多个纯虚函数的类都是抽象类，不能直接创建该类的对象。</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拥有纯虚函数就称为了抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，没有实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-抽象基类"><a href="#3-2-抽象基类" class="headerlink" title="3.2 抽象基类"></a>3.2 抽象基类</h3><p>抽象基类是指包含至少一个纯虚函数的类。抽象基类不能直接实例化，它的目的是为派生类提供接口或基本行为。派生类必须实现抽象基类中的所有纯虚函数，才能实例化派生类对象。</p><p>特点：</p><ul><li>抽象基类通常用作接口定义，强制派生类实现特定的功能。</li><li>抽象基类可以包含普通的成员函数和数据成员，这些成员可以在派生类中继承。</li><li>抽象基类无法实例化，但可以用于定义指向派生类对象的指针或引用，从而实现多态性。</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，派生类必须实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类，实现了抽象基类中的纯虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类，实现了抽象基类中的纯虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Square</span>();</span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出：Drawing a circle</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出：Drawing a square</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>= default</code>是 C++11 引入的一种语法，用于指示编译器生成默认的构造函数、析构函数或拷贝&#x2F;移动操作符。这是一种显式要求编译器为我们生成函数体的方式。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhjwpku.com/assets/pdf/books/C++.Primer.Plus.6th.Edition.Oct.2011.pdf">《C++ Primier Plus》</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Cpp Primer Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp复习 Chapter 4 重载运算符、友元、类的转换函数</title>
      <link href="/2024/02/14/Cpp%E5%A4%8D%E4%B9%A0-Chapter-4-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%8F%8B%E5%85%83%E3%80%81%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
      <url>/2024/02/14/Cpp%E5%A4%8D%E4%B9%A0-Chapter-4-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%8F%8B%E5%85%83%E3%80%81%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-Chapter-4-重载运算符、友元、类的转换函数"><a href="#Cpp复习-Chapter-4-重载运算符、友元、类的转换函数" class="headerlink" title="Cpp复习 Chapter 4 重载运算符、友元、类的转换函数"></a>Cpp复习 Chapter 4 重载运算符、友元、类的转换函数</h1><hr><center><font color=“#EEFFAA” size=56>Cpp系列笔记目录</font></center><p><strong><a href="https://blog.csdn.net/qq_44940689/article/details/140938473?spm=1001.2014.3001.5502">【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140951702?spm=1001.2014.3001.5502">【Cpp筑基】二、声明 vs 定义、头文件、存储持续性作用域和链接性、名称空间</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140962363?spm=1001.2014.3001.5502">【Cpp筑基】三、对象和类</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141018490?spm=1001.2014.3001.5501">【Cpp筑基】四、重载运算符、友元、类的转换函数</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141067994?spm=1001.2014.3001.5501">【Cpp筑基】五、类的继承、虚函数、抽象基类</a></strong></p><hr><h2 id="1-重载运算符"><a href="#1-重载运算符" class="headerlink" title="1. 重载运算符"></a>1. 重载运算符</h2><p>在C++中，运算符重载（operator overloading）允许开发者定义或重新定义标准运算符的行为，使其可以用于自定义类型（例如类）。通过运算符重载，可以让用户定义的类型与内置类型一样自然地进行运算操作，提高代码的可读性和易用性。</p><p>运算符重载是在C++中提供的一种特性，允许为用户定义的类型（例如类或结构体）定义新的运算符行为。几乎所有的运算符都可以被重载，但是有一些例外，如<code>::</code>域解析运算符）， <code>.</code>（成员访问运算符）和<code>*</code>（成员指针访问运算符）不能被重载。</p><p>运算符重载通过在类中定义特定的成员函数或友元函数来实现。重载的函数名是<code>operator</code>后跟要重载的运算符，例如要重载<code>+</code>（加号运算符），我们就写成<code>operator+</code>。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 这里访问 other.real 和 other.imag 是合法的，因为</span></span><br><span class="line">        <span class="comment">// operator+ 是 Complex 类的成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.5</span>, <span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;<span class="comment">// 使用重载运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意一点，类的成员函数可以访问同类的所有对象的私有和保护成员，这就是为什么这里我们可以直接访问<code>other.real</code>和<code>other.imag</code>的原因。</p><p>为了方便使用<code>std::cout</code>进行输出，我们通常也需要重载<code>&lt;&lt;</code>运算符，我们应该返回一个<code>std::ofstream&amp;</code>对象，提供给<code>std::cout</code>进行调用，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">real</span>(<span class="number">0</span>), <span class="built_in">imag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 这里访问 other.real 和 other.imag 是合法的，因为</span></span><br><span class="line">        <span class="comment">// operator+ 是 Complex 类的成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.5</span>, <span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c2: &quot;</span> &lt;&lt; c2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c3: &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待会我们再解释这里为什么需要使用友元<code>friend</code>。</p><h2 id="2-友元"><a href="#2-友元" class="headerlink" title="2. 友元"></a>2. 友元</h2><h3 id="2-1-为什么需要友元，一个简单的例子"><a href="#2-1-为什么需要友元，一个简单的例子" class="headerlink" title="2.1 为什么需要友元，一个简单的例子"></a>2.1 为什么需要友元，一个简单的例子</h3><p>友元（Friend）是C++中一种特殊的函数或类，它可以访问另一个类的私有和保护成员。友元关系是单向的，不是互相的，也不能继承。友元机制提供了一种灵活的访问控制方式，使得可以在不破坏类封装性的情况下，允许特定的函数或类访问类的私有数据。</p><p>友元分为三种：</p><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><p>考虑我们以下的一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">real</span>(<span class="number">0</span>), <span class="built_in">imag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 这里访问 other.real 和 other.imag 是合法的，因为</span></span><br><span class="line">        <span class="comment">// operator+ 是 Complex 类的成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 * 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="type">double</span> time) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real * time, imag * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex A, C;</span><br><span class="line">    Complex B&#123; <span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    A = B * <span class="number">2.5</span>;</span><br><span class="line">    <span class="comment">// C = 2.5 * B;     // 未定义的行为</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; A &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果应该输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: (7.5, 10)</span><br></pre></td></tr></table></figure><p>为什么<code>A = B * 2.5</code>就可以，而<code>C = 2.5 * B</code>就不行呢？这是因为<code>A = B * 2.5</code>将会被转化成<code>A = B.operator*(2.5)</code>，而<code>A = 2.5 * B</code>不能找到对应的函数原型，所以这样是未定义的行为，但是我们重载乘法运算符<code>*</code>的目的就是为了能够同时使用这两种乘法的方式，那我们应该如何做到呢？这就需要引入友元<code>friend</code>的概念。</p><p>创建友元函数的第一步是将其函数原型放在类的声明中，并且函数原型的前面加上关键字<code>friend</code>，例如，在这里我们可以这样进行修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="type">double</span> time, <span class="type">const</span> Complex&amp; other);<span class="comment">// 友元函数原型放在类的声明中</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;友元函数是被声明为另一个类的友元的函数。友元函数不是类的成员函数，但它可以访问该类的私有和保护成员&#x3D;&#x3D;。在这个例子中：</p><ul><li>虽然<code>operator*()</code>函数是再类声明中声明的，但是它不是成员函数，因此不能使用成员函数运算符<code>.</code>来调用 </li><li>虽然<code>operator*()</code>函数不是成员函数，但是它与成员函数的访问权限相同。</li></ul><p>了解了这一点之后，我们可以这样修改上述的成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">real</span>(<span class="number">0</span>), <span class="built_in">imag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 这里访问 other.real 和 other.imag 是合法的，因为</span></span><br><span class="line">        <span class="comment">// operator+ 是 Complex 类的成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 * 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="type">double</span> time) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real * time, imag * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 友元函数，不属于成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="type">double</span> time, <span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(other.real * time, other.imag * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex A, C;</span><br><span class="line">    Complex B&#123; <span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    A = B * <span class="number">2.5</span>;</span><br><span class="line">    C = <span class="number">2.5</span> * B;     <span class="comment">// 未定义的行为</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; A &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C: &quot;</span> &lt;&lt; C &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: (7.5, 10)</span><br><span class="line">C: (7.5, 10)</span><br></pre></td></tr></table></figure><p>这样我们就成功解决了上述问题，另外，&#x3D;&#x3D;友元函数是可以被重载的（前提是函数的特征标不同）&#x3D;&#x3D;，因此，我们也可以这样来解决，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">real</span>(<span class="number">0</span>), <span class="built_in">imag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载 + 运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 这里访问 other.real 和 other.imag 是合法的，因为</span></span><br><span class="line">        <span class="comment">// operator+ 是 Complex 类的成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 * 运算符，不能同时提供两种解决方式</span></span><br><span class="line">    <span class="comment">//Complex operator*(double time) const &#123;</span></span><br><span class="line">    <span class="comment">//    return Complex(real * time, imag * time);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">// 友元函数，不属于成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="type">double</span> time, <span class="type">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(other.real * time, other.imag * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载友元函数，不属于成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex&amp; other, <span class="type">double</span> time) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(other.real * time, other.imag * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex A, C;</span><br><span class="line">    Complex B&#123; <span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    A = B * <span class="number">2.5</span>;</span><br><span class="line">    C = <span class="number">2.5</span> * B;     <span class="comment">// 未定义的行为</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; A &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C: &quot;</span> &lt;&lt; C &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-重载"><a href="#2-2-重载" class="headerlink" title="2.2 重载&lt;&lt;运算符"></a>2.2 重载&lt;&lt;运算符</h3><p>为什么需要重载<code>&lt;&lt;</code>运算符，很重要的是，我们重载了<code>&lt;&lt;</code>运算符之后可以使之与<code>cout</code>一起来显示对象的内容，但是这里有一个很重要的问题是，当我们使用<code>cout &lt;&lt; Complex</code>的时候，实际调用的不是<code>Complex.operator&lt;&lt;(cout)</code>，我们使用<code>Complex &lt;&lt; cout</code>才调用<code>Complex.operator&lt;&lt;(cout)</code>，这就导致了无法正确使用，所以这个时候我们就需要使用友元<code>friend</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，返回类型是<code>std::ostream &amp;</code>，这意味着该函数返回<code>ostream</code>对象的引用，具体地说，它将返回一个指向调用对象（这里是<code>cout</code>）的引用，因此，表达式<code>cout &lt;&lt; x</code>本身就是<code>ostream</code>对象<code>cout</code>，从而可以用于<code>&lt;&lt;</code>运算符的左侧。</p><h3 id="2-3-重载运算符：作为成员函数还是非成员函数"><a href="#2-3-重载运算符：作为成员函数还是非成员函数" class="headerlink" title="2.3 重载运算符：作为成员函数还是非成员函数"></a>2.3 重载运算符：作为成员函数还是非成员函数</h3><p>对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载，一般来说，非成员函数应该是友元函数，这样它才能直接访问类的私有数据。</p><p>注意：</p><p>&#x3D;&#x3D;非成员版本的重载运算符函数所需的形参数目与运算符使用的操作数数目相同；而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象&#x3D;&#x3D;。</p><p>举个例子，<code>T1 = T2 + T3</code>将被转换成下面两个的任何一个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1 = T2.<span class="keyword">operator</span>+(T3);<span class="comment">// member function</span></span><br><span class="line">T1 = <span class="keyword">operator</span>+(T2, T3);<span class="comment">// nonmember function</span></span><br></pre></td></tr></table></figure><h2 id="3-类的转换函数"><a href="#3-类的转换函数" class="headerlink" title="3. 类的转换函数"></a>3. 类的转换函数</h2><p>在C++中，类的转换函数（conversion function）是指将类的对象转换为其他类型的函数。这种类型转换是通过定义一个特殊的成员函数实现的，该成员函数不带返回类型，但会返回一个指定的类型。这些函数通常是用来将自定义类类型转换为内置类型或其他用户定义类型。</p><p>首先，我们先复习一下Cpp是如何处理内置类型转换的。将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++将自动完成将这个值转换成接受变量的类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count = <span class="number">8</span>;<span class="comment">// convert int value 8 to long type</span></span><br><span class="line"><span class="type">double</span> time = <span class="number">11</span>;<span class="comment">// cocnvert int value 11 to double type</span></span><br></pre></td></tr></table></figure><p>强制类型转换具有两种风格，一种是C风格，一种是C++风格：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> b = (<span class="type">double</span>)a;<span class="comment">// C风格</span></span><br><span class="line"><span class="type">double</span> c = <span class="built_in">double</span>(a);<span class="comment">// C++风格</span></span><br></pre></td></tr></table></figure><p>C++风格是为了让强制类型转换像函数调用一样。</p><h3 id="3-1-转换函数"><a href="#3-1-转换函数" class="headerlink" title="3.1 转换函数"></a>3.1 转换函数</h3><p>转换函数的语法是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>operator</code>是关键字。</li><li><code>type</code>是要转换到的目标类型。</li><li><code>const</code>是可选的，表示该函数不会修改对象的状态。</li></ul><p>&#x3D;&#x3D;我们编写转换函数的目的就是让我们可以使用C++风格的方式来转换自定义类的类型&#x3D;&#x3D;。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    <span class="comment">// 转换函数：将 Complex 对象转换为 double（返回实部）</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换函数：将 Complex 对象转换为 bool（如果实部和虚部都为零，则返回 false，否则返回 true）</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> real != <span class="number">0</span> || imag != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载 &lt;&lt; 运算符用于输出</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 使用转换函数</span></span><br><span class="line">    <span class="type">double</span> realPart = c1;   <span class="comment">// 转换为double类型</span></span><br><span class="line">    <span class="type">bool</span> isNonZero1 = c1;   <span class="comment">// 转换为bool类型</span></span><br><span class="line">    <span class="type">bool</span> isNonZero2 = c2;   <span class="comment">// 转换为bool类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1: &quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;, realPart: &quot;</span> &lt;&lt; realPart &lt;&lt; <span class="string">&quot;, isNonZero1: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; isNonZero1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c2: &quot;</span> &lt;&lt; c2 &lt;&lt; <span class="string">&quot;, isNonZero2: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; isNonZero2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1: (3, 4), realPart: 3, isNonZero1: true</span><br><span class="line">c2: (0, 0), isNonZero2: false</span><br></pre></td></tr></table></figure><h3 id="3-2-explicit关键字"><a href="#3-2-explicit关键字" class="headerlink" title="3.2 explicit关键字"></a>3.2 explicit关键字</h3><p>&#x3D;&#x3D;关键字<code>explicit</code>用于指示构造函数或转换运算符是显式的，必须显示使用&#x3D;&#x3D;。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 带一个参数的构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">value</span>(x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">42</span>; <span class="comment">// 隐式调用构造函数</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">50</span>);    <span class="comment">// 隐式转换发生</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，<code>MyClass obj1 = 42;</code> 和 <code>printValue(50);</code>，相当于<code>MyClass obj1 = MyClass(42);</code>和<code>printValue(MyClass(50))</code>， 都隐式调用了 <code>MyClass</code> 的构造函数。这可能会导致意外的类型转换和难以调试的问题。为了防止这种情况可以使用<code>expilcit</code>关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用 explicit 关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 显式调用构造函数</span></span><br><span class="line">    <span class="comment">// printValue(50);   // 编译错误：需要显式转换</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">MyClass</span>(<span class="number">50</span>)); <span class="comment">// 显式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《C++ Primer Plus》</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Cpp Primer Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp复习 Chapter 3 对象和类</title>
      <link href="/2024/02/13/Cpp%E5%A4%8D%E4%B9%A0-Chapter-3-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
      <url>/2024/02/13/Cpp%E5%A4%8D%E4%B9%A0-Chapter-3-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-Chapter-3-对象和类"><a href="#Cpp复习-Chapter-3-对象和类" class="headerlink" title="Cpp复习 Chapter 3 对象和类"></a>Cpp复习 Chapter 3 对象和类</h1><hr><center><font color=“#EEFFAA” size=56>Cpp系列笔记目录</font></center><p><strong><a href="https://blog.csdn.net/qq_44940689/article/details/140938473?spm=1001.2014.3001.5502">【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140951702?spm=1001.2014.3001.5502">【Cpp筑基】二、声明 vs 定义、头文件、存储持续性作用域和链接性、名称空间</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140962363?spm=1001.2014.3001.5502">【Cpp筑基】三、对象和类</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141018490?spm=1001.2014.3001.5501">【Cpp筑基】四、重载运算符、友元、类的转换函数</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141067994?spm=1001.2014.3001.5501">【Cpp筑基】五、类的继承、虚函数、抽象基类</a></strong></p><hr><h2 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h2><p>Cpp相比于C语言新增了类的概念，因此Cpp是一种面向对象的编程语言而C语言只是一种面向过程的编程语言。类是一种将抽象转换为用于自定义的Cpp工具，它将数据表示和操纵数据的方法组合成一个整洁的包。</p><p>一般来说，类规范由两部分组成：</p><ul><li>类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。</li><li>类的方法定义：描述如何实现类成员函数。</li></ul><h3 id="1-1-类的一个简单示例"><a href="#1-1-类的一个简单示例" class="headerlink" title="1.1 类的一个简单示例"></a>1.1 类的一个简单示例</h3><p>简单来说，类声明提供了类的蓝图，而方法定义则提供了类实现的细节。举一个例子：</p><p><code>my_class.h</code>文件中存放了类的声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_class.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_CLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_CLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> age);</span><br><span class="line">    <span class="comment">// 公有接口：成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>my_class.cpp</code>中存放了类的方法定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_class.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_class.h&quot;</span></span></span><br><span class="line"><span class="comment">// 构造函数实现</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// display 方法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setAge 方法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid age!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getAge 方法实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Person::getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-类的访问权限"><a href="#1-2-类的访问权限" class="headerlink" title="1.2 类的访问权限"></a>1.2 类的访问权限</h3><p>Cpp中类的访问权限有三种：</p><ul><li><code>public</code>，公有，类的成员可以从类的外部直接访问。任何对象或函数都可以访问<code>public</code>成员</li><li><code>protected</code>，保护，类的成员不能从类的外部直接访问，但可以被派生类（继承该类的类）访问。</li><li><code>private</code>，私有，访问权限表示成员不能从类的外部直接访问，也不能被派生类访问。只有类的成员函数和友元函数可以访问<code>private</code>成员。</li></ul><p>需要注意的是，&#x3D;&#x3D;在Cpp中访问权限是相对类的外部而言的，在类的内部来说，所有的变量和成员函数都是可以互相访问的&#x3D;&#x3D;。公有<code>public</code>方法也可以访问私有<code>private</code>成员变量和方法，Cpp类的成员函数，无论其访问级别如何，都可以访问该类中的所有成员，包括私有成员，这是因为成员函数被认为是类的一部分，拥有该类的所有细节的权限。</p><p>在Cpp中可以使用关键字<code>struct</code>或者<code>class</code>来声明一个类，它们的使用方式基本相同，唯一不同之处在于<code>struct</code>声明的成员默认访问权限为<code>public</code>，而<code>class</code>声明的成员默认访问权限是<code>private</code>。</p><p>数据隐藏作为面向对象编程（Object Orient Program，OOP）的主要目的，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则就无法从程序中调用这些函数。通常，我们使用私有成员函数来处理不属于公有接口的实现细节。</p><h3 id="1-3-内联方法"><a href="#1-3-内联方法" class="headerlink" title="1.3 内联方法"></a>1.3 内联方法</h3><p>&#x3D;&#x3D;如果在一个类中，其成员函数的定义放在类的声明中，那么该成员函数将被自动转化为内联函数，以减小开销&#x3D;&#x3D;。内联函数是一种建议编译器在每次调用该函数时，将其代码插入到调用点处，而不是进行常规的函数调用。这可以减少函数调用的开销，提高程序执行效率，尤其是对于短小的函数。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在类声明中定义的函数,自动转化成内联函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, Inline Function!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">printMessage</span>(); <span class="comment">// 调用内联函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以手动在类声明之外定义内联成员函数。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 声明时不需要 inline</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义时使用 inline</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MyClass::printMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, Inline Function!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">printMessage</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue>使用<code>new</code>初始化类</font>，使用<code>new</code>在<code>heap</code>区上分配内存来初始化一个类的指针会调用相应的构造函数，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">real</span>(<span class="number">0</span>), <span class="built_in">imag</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Complex</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 new 动态分配对象</span></span><br><span class="line">    Complex* c1 = <span class="keyword">new</span> <span class="built_in">Complex</span>();  <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Complex* c2 = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3.0</span>, <span class="number">4.0</span>);  <span class="comment">// 调用带参数的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用对象</span></span><br><span class="line">    c1-&gt;<span class="built_in">display</span>();</span><br><span class="line">    c2-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span> c1;  <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> c2;  <span class="comment">// 调用析构函数并释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-构造函数和析构函数"><a href="#1-4-构造函数和析构函数" class="headerlink" title="1.4 构造函数和析构函数"></a>1.4 构造函数和析构函数</h3><p>在C++中，构造函数和析构函数是特殊的成员函数，用于在对象的生命周期内执行初始化和清理操作。构造函数在对象创建时自动调用，而析构函数在对象销毁时自动调用。</p><p>&#x3D;&#x3D;构造函数是用于初始化对象的特殊成员函数。构造函数的名称与类名相同，并且没有返回类型。构造函数可以被重载，即一个类可以有多个构造函数，只要它们的参数（特征标）不同&#x3D;&#x3D;。</p><p>构造函数的特点是：</p><ul><li>名称与类名相同</li><li>没有返回类型</li><li>在对象创建时自动调用</li><li>可以被重载</li><li>可以使用初始化列表</li><li>不能成为虚函数</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        x = value;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        x = obj.x;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;              <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>;          <span class="comment">// 调用参数化构造函数</span></span><br><span class="line">    MyClass obj3 = obj2;       <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重载了构造函数，提供了三种构造函数，当类被示例化的时候会从构造函数中选择符合特征标的构造函数进行调用。</p><p><font color=blue>成员名称与参数名</font>，不熟悉构造函数的程序员可能会将类成员名称用作构造函数的参数名，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">// 构造函数参数名与成员变量名相同</span></span><br><span class="line">        x = x; <span class="comment">// 这是错误的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了解决这种问题，我们可以在数据成员名前面增加<code>_</code>或者一些其他的标识，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">// 这是可行的，没有名称冲突</span></span><br><span class="line">        _x = x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者使用<code>this</code>指针来显示地指明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123; <span class="comment">// 这是可行的，使用this指针</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者使用&#x3D;&#x3D;构造函数初始化列表&#x3D;&#x3D;，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">x</span>(x) &#123; <span class="comment">// 使用初始化列表</span></span><br><span class="line">        <span class="comment">// 这样更直观，并且避免了赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果<code>Classy</code>是一个类，且<code>mem1</code>和<code>mem2</code>是其成员变量，那么成员初始化列表的语法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classy::<span class="built_in">Classy</span>(<span class="type">int</span> n, <span class="type">int</span> m): <span class="built_in">mem1</span>(n), <span class="built_in">mem2</span>(m)&#123; &#125;</span><br></pre></td></tr></table></figure><p>从概念上来说，这些初始化工作是在对象创建时完成的，此时还未执行括号中的任何代码，请注意以下几点：</p><ul><li>这种初始化格式只能适用于构造函数；</li><li>必须使用这种格式来初始化非静态<code>const</code>数据成员；</li><li>必须使用这种格式来初始化引用数据成员。</li></ul><p>原因在于<code>const</code>变量和<code>&amp;</code>引用都只能在被创建的时候进行初始化，举个例子：</p><ol><li>初始化非静态<code>const</code>数据成员</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> qsize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> qs): <span class="built_in">qsize</span>(qs) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化引用数据成员</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Agency</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Agency &amp; belong;<span class="comment">// must be initializer list to initialize</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Agent</span>(Agency&amp; a): <span class="built_in">belong</span>(a) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;如果没有提供构造函数，那么编译器会为我们添加一个默认构造函数，只不过这个构造函数什么也不执行；一个默认拷贝构造函数，并且重载赋值运算符<code>=</code>，允许我们直接拷贝已有的对象实例&#x3D;&#x3D;。</p><p><font color=blue>默认的构造函数</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 使用编译器生成的默认构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; obj.x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; obj.y &lt;&lt; std::endl; <span class="comment">// 未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类<code>MyClass</code>中，我们并没有定义构造函数，编译器自动帮我们生成了一个构造函数，这个构造函数什么都不做，所以<code>x</code>和<code>y</code>是没有赋值的，在最后一行的打印语句中将会报错。</p><p><font color=blue>默认拷贝构造函数</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    obj1.x = <span class="number">10</span>;</span><br><span class="line">    obj1.y = <span class="number">20.5</span>;</span><br><span class="line">    </span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 使用编译器生成的默认拷贝构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.x: &quot;</span> &lt;&lt; obj2.x &lt;&lt; <span class="string">&quot;, obj2.y: &quot;</span> &lt;&lt; obj2.y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类<code>MyClass</code>中，我们并没有定义构造函数，编译器自动帮我们生成了一个拷贝构造函数，编译器生成的默认拷贝构造函数会逐个成员地进行浅拷贝。</p><p><font color=blue>重载运算符<code>operator=</code></font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    obj1.x = <span class="number">10</span>;</span><br><span class="line">    obj1.y = <span class="number">20.5</span>;</span><br><span class="line">    </span><br><span class="line">    MyClass obj2;</span><br><span class="line">    obj2 = obj1; <span class="comment">// 使用编译器生成的默认赋值运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.x: &quot;</span> &lt;&lt; obj2.x &lt;&lt; <span class="string">&quot;, obj2.y: &quot;</span> &lt;&lt; obj2.y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器生成的默认赋值运算符（<code>operator=</code>）也会逐个成员地进行浅拷贝。</p><p>&#x3D;&#x3D;在Cpp中，析构函数是一个特殊的成员函数，用于在对象生命周期结束时执行清理工作，析构函数通常用于释放资源（如动态内存、文件句柄、网络连接等），确保对象在销毁时不会造成资源泄露&#x3D;&#x3D;。</p><p>析构函数的特点是：</p><ul><li>名称与类名相同，但前面加上波浪号<code>~</code></li><li>没有返回类型</li><li>没有参数</li><li>在对象生命周期结束时自动调用</li><li>不能被重载，一个类只能有一个析构函数</li><li>不能成为虚函数</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建对象并分配内存</span></span><br><span class="line">    <span class="comment">// 离开作用域时自动调用析构函数，释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没有定义析构函数，那么编译器将会自动生成一个析构函数，该析构函数不执行任何操作，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Simple</span>() : <span class="built_in">x</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simple Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器会生成一个默认析构函数</span></span><br><span class="line">    <span class="comment">// ~Simple() &#123; &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Simple obj; <span class="comment">// 创建对象时调用构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 离开作用域时调用编译器生成的默认析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-C-11列表初始化"><a href="#1-5-C-11列表初始化" class="headerlink" title="1.5 C++11列表初始化"></a>1.5 C++11列表初始化</h3><p>在C++11中，列表初始化语法也可以用于类中，只要提供与某个构造函数的参数列表匹配的内容，就可使用大括号<code>&#123;&#125;</code>进行列表初始化。</p><p><font color=blue>列表初始化类的对象</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructed with x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClass jock &#123;&#125;;<span class="comment">//使用默认构造函数进行初始化</span></span><br><span class="line">MyClass alex &#123;<span class="number">10</span>, <span class="number">2.5</span>&#125;;<span class="comment">//使用构造函数进行初始化</span></span><br><span class="line">MyClass john &#123;<span class="number">2</span>, <span class="number">5.1</span>&#125;;<span class="comment">//使用构造函数进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue>列表初始化类的对象的数组</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructed with x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用列表初始化来初始化类对象数组</span></span><br><span class="line">    MyClass arr[<span class="number">3</span>] = &#123; </span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2.5</span>&#125;, </span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4.5</span>&#125;, </span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6.5</span>&#125;, </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 也可这样来初始化数组</span></span><br><span class="line">MyClass arry[<span class="number">3</span>] = &#123;</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="number">2</span>, <span class="number">2.5</span>),</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="number">3</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="number">4</span>, <span class="number">6.5</span>),</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-const成员函数"><a href="#1-6-const成员函数" class="headerlink" title="1.6 const成员函数"></a>1.6 const成员函数</h3><p>在C++中，<code>const</code>成员函数是指那些不会修改类的成员变量的成员函数。通过在函数声明的末尾加上 <code>const</code>关键字，可以保证该函数不会修改对象的状态。这对于确保某些函数的调用不会意外地改变对象的状态非常有用，并且在设计接口和维护代码的稳定性方面起着重要作用。</p><p><font color=blue><code>const</code>成员函数的基本使用</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 声明为const成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// 可以读取成员变量</span></span><br><span class="line">    <span class="comment">// value = 10; // 错误：不能修改成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue><code>const</code>对象和成员函数</font>，<code>const</code>对象不能调用非<code>const</code>成员函数，而非<code>const</code>对象可以调用所有的成员函数，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    value = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 可以调用非const对象的所有成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MyClass constObj;</span><br><span class="line">    <span class="comment">// constObj.setValue(10); // 错误：不能调用非const成员函数</span></span><br><span class="line">    std::cout &lt;&lt; constObj.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 只能调用const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-this指针"><a href="#1-7-this指针" class="headerlink" title="1.7 this指针"></a>1.7 this指针</h3><p>在C++中，<code>this</code>指针是一个隐含在每个非静态成员函数中的特殊指针。它指向调用成员函数的对象，并且允许成员函数访问调用对象的成员变量和其他成员函数。<code>this</code>指针的主要作用是区分成员变量和局部变量，并在成员函数内部引用对象本身。</p><p><code>this</code>指针的特点</p><ul><li>指向调用对象：<code>this</code>指针指向调用成员函数的对象本身。</li><li>只在非静态成员函数中可用：静态成员函数没有<code>this</code>指针，因为静态成员函数是类级别的，而不是对象级别的。</li><li>类型：<code>this</code>指针的类型是指向类类型的常量指针，例如对于类<code>MyClass</code>，<code>this</code>指针的类型是<code>MyClass* const</code>。</li><li>常量性：<code>this</code>指针是一个常量指针，不能更改它指向的对象，但可以用来修改对象的成员。</li></ul><p><font color=blue>使用<code>this</code>指针区分成员变量和局部变量</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="comment">// 使用this指针区分成员变量和构造函数参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用this指针区分成员变量和函数参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>);</span><br><span class="line">    obj.<span class="built_in">printValue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue>使用<code>this</code>指针实现链式调用（返回<code>*this</code>）</font>，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回对象本身的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">incrementValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回对象本身的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>).<span class="built_in">incrementValue</span>().<span class="built_in">printValue</span>(); <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们实现了对象方法的链式调用，但链式调用更多地用在运算符重载当中，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value</span>(value) &#123;&#125;</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>+=(<span class="type">int</span> other) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value += other;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 返回*this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj += <span class="number">5</span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>(); <span class="comment">// 输出：Value: 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《C++ Primer Plus》</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Cpp Primer Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp复习 Chapter 2 声明vs定义、头文件、存储持续性作用域和链接性、名称空间</title>
      <link href="/2024/02/12/Cpp%E5%A4%8D%E4%B9%A0-Chapter-2-%E5%A3%B0%E6%98%8Evs%E5%AE%9A%E4%B9%89%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E6%80%A7%E3%80%81%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/02/12/Cpp%E5%A4%8D%E4%B9%A0-Chapter-2-%E5%A3%B0%E6%98%8Evs%E5%AE%9A%E4%B9%89%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E6%80%A7%E3%80%81%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-Chapter-2-声明vs定义、头文件、存储持续性作用域和链接性、名称空间"><a href="#Cpp复习-Chapter-2-声明vs定义、头文件、存储持续性作用域和链接性、名称空间" class="headerlink" title="Cpp复习 Chapter 2 声明vs定义、头文件、存储持续性作用域和链接性、名称空间"></a>Cpp复习 Chapter 2 声明vs定义、头文件、存储持续性作用域和链接性、名称空间</h1><hr><center><font color=“#EEFFAA” size=56>Cpp系列笔记目录</font></center><p><strong><a href="https://blog.csdn.net/qq_44940689/article/details/140938473?spm=1001.2014.3001.5502">【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140951702?spm=1001.2014.3001.5502">【Cpp筑基】二、声明 vs 定义、头文件、存储持续性作用域和链接性、名称空间</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140962363?spm=1001.2014.3001.5502">【Cpp筑基】三、对象和类</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141018490?spm=1001.2014.3001.5501">【Cpp筑基】四、重载运算符、友元、类的转换函数</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141067994?spm=1001.2014.3001.5501">【Cpp筑基】五、类的继承、虚函数、抽象基类</a></strong></p><hr><h2 id="1-声明vs定义"><a href="#1-声明vs定义" class="headerlink" title="1. 声明vs定义"></a>1. 声明vs定义</h2><p>什么是声明？什么是定义？</p><p>在C++中，声明（Declaration）和定义（Definition）是两个重要的概念，它们在程序的组织和编译过程中起着不同的作用。声明是告诉编译器某个变量、函数、类或者其他标识符的名称及其类型，但不包含具体的实现或者初始化，声明的主要目的是让编译器知道这些标识符的存在及类型。</p><ul><li>声明（Declaration）：告诉编译器某个变量的名字和类型，但不分配存储空间（除非它也是一个定义）。</li><li>定义（Definition）：不仅告诉编译器变量的名字和类型，还分配存储空间。</li></ul><p>声明我们只需要告诉编译器变量的名字和类型即可，不需要为其分配存储空间，例如：</p><ol><li>变量声明</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;<span class="comment">// 声明一个变量</span></span><br></pre></td></tr></table></figure><ol start="2"><li>函数声明</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;<span class="comment">// 声明一个名为add的函数，接受两个整数参数并返回一个整数</span></span><br></pre></td></tr></table></figure><ol start="3"><li>类声明</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>;<span class="comment">// 声明一个类MyClass，但不定义其成员</span></span><br></pre></td></tr></table></figure><p>在定义中我们需要为变量分配存储空间，例如：</p><ol><li>变量定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">// 定义一个变量，但是没有 为其赋值</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;<span class="comment">// 定义一个变量，并且初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> z = <span class="number">20</span>;<span class="comment">// 定义一个外部变量，并且它会初始化为20</span></span><br></pre></td></tr></table></figure><ol start="2"><li>函数定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 定义add函数</span></span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 实现具体的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">// 定义类MyClass</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2. 头文件"></a>2. 头文件</h2><p>学过C语言的同学都知道头文件，在C++中，头文件（header files）用于声明程序中所需的函数、类、变量和其他标识符，而不进行实际的定义和实现。头文件通常以<code>.h</code>或者<code>.hpp</code>作为扩展名。它们的主要作用是支持代码的模块化和重用，并简化项目的管理和编译过程。头文件的主要内容通常有：</p><ul><li>函数原型</li><li>使用<code>#define</code>或<code>const</code>定义的符号常量</li><li>结构体声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li><li>函数原型</li></ul><p>一个头文件的简单例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 #define 定义的符号常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 定义的符号常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体声明</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYHEADER_H</span></span></span><br></pre></td></tr></table></figure><p>头文件管理</p><blockquote><p>在同一个文件中只能将同一个头文件包含一次，记住这个规则很容易，但是很可能在不知道的情况下将头文件进行了多次包含，例如，可能使用包含了另一个头文件的头文件。有一种标准的C&#x2F;C++技术可以避免多次包含同一个头文件，它是基于预编译指令<code>#ifndef</code>（即if not define的），下面的代码意味着仅当以前没有使用预处理器编译指令<code>#define</code>定义名称<code>MYHEADER_H</code>，才处理<code>#ifndef</code>和<code>endif</code>之间的语句：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line">...<span class="comment">// place include file contents here</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYHEADER_H</span></span></span><br></pre></td></tr></table></figure><blockquote><p>另外，如果头文件包含在尖括号<code>&lt;&gt;</code>中，则Cpp编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号<code>&quot;&quot;</code>中，编译器将首先查找当前的工作目录或者源代码目录，如果没有找到头文件，则将在标准位置进行查找。</p></blockquote><h2 id="3-存储持续性、作用域和链接性"><a href="#3-存储持续性、作用域和链接性" class="headerlink" title="3. 存储持续性、作用域和链接性"></a>3. 存储持续性、作用域和链接性</h2><h3 id="3-1-存储持续性"><a href="#3-1-存储持续性" class="headerlink" title="3.1 存储持续性"></a>3.1 存储持续性</h3><p>Cpp中使用四种不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间，主要分为：</p><ul><li>自动存储持续性（默认）：Cpp中在函数定义中声明的变量（包括函数参数）的存储持续性为自动的，它们在程序开始执行其所属的函数或者代码块时被创建，在执行完函数或代码时被释放。</li><li>静态存储持续性（<code>static</code>）：在函数外定义的变量和使用关键字<code>static</code>定义的变量的存储持续性都为静态，它们在整个程序的运行过程中都存在。</li><li>线程存储持续性（<code>thread_local</code>）：如果变量时使用关键字<code>thread_local</code>声明的，那么其生命周期与所属的线程一样长。</li><li>动态存储持续性（<code>new delete</code>）：使用<code>new</code>运算符分配的内存将一直存在，直到使用<code>delete</code>运算符将其释放或程序结束为止。这种内存的存储持续性为动态的。</li></ul><h3 id="3-2-变量的存储区域"><a href="#3-2-变量的存储区域" class="headerlink" title="3.2 变量的存储区域"></a>3.2 变量的存储区域</h3><p>这里再介绍一下Cpp中的变量存储区域，</p><ul><li>栈区（Stack Segment）：</li></ul><blockquote><p>局部变量：在函数内部声明的变量，通常存储在栈区。<br>函数参数：传递给函数的参数，通常也存储在栈区。<br>特点：栈区内存由编译器自动分配和释放，生命周期是函数调用期间，作用域是当前函数</p></blockquote><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">10</span>;  <span class="comment">// localVar 存储在栈区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆区（Heap Segment）：</li></ul><blockquote><p>动态分配的变量：使用<code>new</code>或<code>malloc</code>动态分配的内存。<br>特点：堆区内存由程序员手动管理（分配和释放），生命周期是从分配到显式释放（如<code>delete</code>或<code>free</code>）。</p></blockquote><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* heapVar = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);  <span class="comment">// heapVar 指向的内存存储在堆区</span></span><br><span class="line">    <span class="keyword">delete</span> heapVar;              <span class="comment">// 手动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局&#x2F;静态区（Data Segment）：</li></ul><blockquote><p>全局变量：在所有函数外部声明的变量。<br>静态变量：使用 static 关键字声明的变量，无论是在函数内部还是在类内部。<br>特点：全局&#x2F;静态区内存在程序开始时分配，程序结束时释放，生命周期贯穿整个程序运行周期。</p></blockquote><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;  <span class="comment">// 全局变量，存储在全局/静态区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">20</span>;  <span class="comment">// 静态变量，存储在全局/静态区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常量区（Text Segment）：</li></ul><blockquote><p>字符串字面量和常量：例如字符串字面量、使用 const 关键字定义的常量。<br>特点：这些常量通常存储在只读内存区，生命周期与程序相同。</p></blockquote><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constVar = <span class="number">30</span>;  <span class="comment">// 常量，存储在常量区</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 字符串字面量，存储在常量区</span></span><br></pre></td></tr></table></figure><h3 id="3-3-作用域"><a href="#3-3-作用域" class="headerlink" title="3.3 作用域"></a>3.3 作用域</h3><p>这里介绍一些常见作用域，&#x3D;&#x3D;代码块&#x3D;&#x3D;用<code>&#123;&#125;</code>来进行表示，其中变量的默认作用域是局部；&#x3D;&#x3D;全局作用域的变量&#x3D;&#x3D;在定义位置开始到文件结尾之间都能使用；&#x3D;&#x3D;自动变量&#x3D;&#x3D;的作用域是局部，&#x3D;&#x3D;静态变量&#x3D;&#x3D;的作用域是全局还是局部取决于它的定义方式；&#x3D;&#x3D;类&#x3D;&#x3D;中声明的成员变量的作用域为整个类。这里举例说明代码块的作用域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> teledeli = <span class="number">5</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; weight &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="comment">// weight变量失效</span></span><br><span class="line">std::cout &lt;&lt; teledeli &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="comment">// teledeli变量失效</span></span><br></pre></td></tr></table></figure><p><strong>寄存器变量</strong></p><p>关键字<code>register</code>是由C语言进行引入的，它建议编译器使用CPU寄存器来存储自动变量，旨在提高变量的访问速度，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> count_faster;<span class="comment">//请求使用寄存器来存储变量count_faster</span></span><br></pre></td></tr></table></figure><h3 id="3-4-链接性"><a href="#3-4-链接性" class="headerlink" title="3.4 链接性"></a>3.4 链接性</h3><p>Cpp中具有三种链接特性</p><ul><li>外部链接（其他文件可访问）</li><li>内部链接（只能当前文件访问）</li><li>无链接（只能当前函数或者代码块访问）</li></ul><p>当前文件中的全局变量都是外部链接属性，当前文件的函数均能访问该变量，其他文件可以使用，使用关键字<code>static</code> 可以将其链接属性改为内部链接，例如：</p><p><code>external_linkage.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1: external_linkage.cpp</span></span><br><span class="line"><span class="type">int</span> global_external = <span class="number">10</span>; <span class="comment">// 具有外部链接性的全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">external_function</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 具有外部链接性的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_internal = <span class="number">20</span>; <span class="comment">// 具有内部链接性的全局变量</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">internal_function</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 具有内部链接性的函数</span></span><br></pre></td></tr></table></figure><p>函数体或者代码块中的变量默认为无链接属性，只能由当前函数体或者代码块进行访问；外部链接需要关键字<code>extern</code>进行声明，则可以在其他文件中进行使用。例如：</p><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件2: main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;external_linkage.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; global_external &lt;&lt; std::endl; <span class="comment">// 可以访问具有外部链接性的global_external</span></span><br><span class="line">    <span class="built_in">external_function</span>(); <span class="comment">// 可以调用具有外部链接性的external_function</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; global_internal &lt;&lt; std::endl; // 错误,global_internal具有内部链接性</span></span><br><span class="line">    <span class="comment">// internal_function(); // 错误,internal_function具有内部链接性</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> local_variable = <span class="number">30</span>; <span class="comment">// 具有无链接性的局部变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-1-extern"><a href="#3-4-1-extern" class="headerlink" title="3.4.1 extern"></a>3.4.1 extern</h4><p>C&#x2F;Cpp中可以使用<code>extern</code>来引用声明变量，与<code>include</code>相比，<code>extern</code>引用另一个文件的范围更小，<code>include</code>可以引用另一个文件的全部内容，<code>extern</code>的引用方式要比包含头文件更加简介。需要注意的是</p><ul><li>定义一个<code>extern</code>变量时，关键字<code>extern</code>是可选的</li><li>声明一个<code>extern</code>变量时，关键字<code>extern</code>是必须的</li></ul><p>举个例子：</p><p><code>file01.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> cats = <span class="number">20</span>;<span class="comment">// definition because of initialization</span></span><br><span class="line"><span class="type">int</span> dogs = <span class="number">22</span>;<span class="comment">// definition</span></span><br></pre></td></tr></table></figure><p><code>file02.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use cats from file01.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> cats;<span class="comment">// declaration</span></span><br></pre></td></tr></table></figure><p><code>file03.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use cats, dogs from file01.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> cats;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> dogs;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-static"><a href="#3-4-2-static" class="headerlink" title="3.4.2 static"></a>3.4.2 static</h4><p>关键字<code>static</code>可以改变变量或者函数的作用域，需要特别注意一下</p><ol><li>静态局部变量</li></ol><p>当 <code>static</code> 关键字用于函数内部的局部变量时，该变量在函数调用之间保持其值，并且只在第一次调用时初始化一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">example</span>();</span><br><span class="line">    <span class="built_in">example</span>();</span><br><span class="line">    <span class="built_in">example</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Count: 1</span><br><span class="line">Count: 2</span><br><span class="line">Count: 3</span><br></pre></td></tr></table></figure><ol start="2"><li>静态全局变量</li></ol><p>当 <code>static</code> 关键字用于全局变量时，该变量的作用域仅限于定义它的文件。它不会被其他文件所访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> globalVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementGlobalVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    globalVar++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GlobalVar: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">incrementGlobalVar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">incrementGlobalVar</span>();  <span class="comment">// 输出 GlobalVar: 1</span></span><br><span class="line">    <span class="built_in">incrementGlobalVar</span>();  <span class="comment">// 输出 GlobalVar: 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>file2.cpp</code> 无法直接访问 <code>globalVar</code>。</p><ol start="3"><li>静态成员变量</li></ol><p>在类中，<code>static</code> 关键字用于声明静态成员变量。静态成员变量属于类而不是类的实例。所有类的实例共享同一个静态成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Example::staticVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example::staticVar = <span class="number">5</span>;</span><br><span class="line">    Example obj1;</span><br><span class="line">    Example obj2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; obj1.staticVar &lt;&lt; std::endl;  <span class="comment">// 输出 5</span></span><br><span class="line">    std::cout &lt;&lt; obj2.staticVar &lt;&lt; std::endl;  <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    obj1.staticVar = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; obj2.staticVar &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>静态成员函数</li></ol><p>静态成员函数可以在不创建对象的情况下调用，因为它们不属于任何特定对象。静态成员函数只能访问静态成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StaticVar: &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Example::staticVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example::staticVar = <span class="number">5</span>;</span><br><span class="line">    Example::<span class="built_in">staticFunction</span>();  <span class="comment">// 输出 StaticVar: 5</span></span><br><span class="line"></span><br><span class="line">    Example obj;</span><br><span class="line">    obj.<span class="built_in">staticFunction</span>();  <span class="comment">// 输出 StaticVar: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>静态全局函数</li></ol><p>在 C++ 中，如果在文件作用域内使用 <code>static</code> 修饰函数（必须同时在函数原型和定义处使用关键字<code>static</code>），该函数的作用域将被限制在定义它的文件中。这种方法用于实现文件私有的函数，避免函数名在多个文件之间冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is a static function in file1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callStaticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">staticFunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">callStaticFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">callStaticFunction</span>();  <span class="comment">// 输出 This is a static function in file1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>staticFunction</code> 仅在 <code>file1.cpp</code> 内部可见，无法在 <code>file2.cpp</code> 中直接调用。这避免了同名函数在多个文件中冲突的问题。</p><p><strong>总结</strong></p><ul><li><strong>静态局部变量</strong>：在函数内声明，具有静态存储期，在函数调用之间保持值。</li><li><strong>静态全局变量</strong>：在文件作用域内声明，仅在定义它的文件中可见。</li><li><strong>静态成员变量</strong>：在类内声明，属于类而不是类的实例，所有实例共享。</li><li><strong>静态成员函数</strong>：在类内声明，属于类而不是类的实例，只能访问静态成员。</li></ul><h4 id="3-4-3-语言链接性"><a href="#3-4-3-语言链接性" class="headerlink" title="3.4.3 语言链接性"></a>3.4.3 语言链接性</h4><p>另一种形式的链接性被称为语言链接性（language linking），这种链接性对程序也有影响。首先解释为什么需要语言链接性，链接程序要求每个不同的函数都有不同的符号名，在<code>C</code>语言中，一个名称只对应一个函数，因此很容易满足，为了满足内部需要，<code>C</code>语言编译器可能将<code>spiff</code>这样的函数名翻译为<code>_spiff</code>，但是在<code>Cpp</code>中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的函数名，因此我们需要指定当前的函数时按照什么方式进行编译的。</p><p>Cpp主要提供了两种语言链接性：</p><ul><li>C语言链接性(C language linkage)，使用<code>extern &quot;C&quot; &#123;...&#125;</code></li><li>C++语言链接性(C++ language linkage），使用<code>extern &quot;C++&quot; &#123;...&#125;</code></li></ul><p>举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">c_function</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这不是一种常用的方式，通常我们一个文件中的所有函数都需要使用C语言链接性或者是C++语言链接性，我们可以这样使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluspluss</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#enif</span></span><br><span class="line">...<span class="comment">//这里存放函数体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpluspluss</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#enif</span></span><br></pre></td></tr></table></figure><h2 id="4-名称空间"><a href="#4-名称空间" class="headerlink" title="4. 名称空间"></a>4. 名称空间</h2><p>Cpp中关于全局变量和局部变量的规则定义了一种名称空间层次，每个声明区域都可声明名称，这些名称独立于在其他声明区域中声明的名称，在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。</p><p>在C++中,名称空间(Namespace)是一个用来组织和管理代码中标识符(变量、函数、类等)的机制。它可以帮助我们避免命名冲突,提高代码的可读性和可维护性。</p><h3 id="4-1-名称空间的定义"><a href="#4-1-名称空间的定义" class="headerlink" title="4.1 名称空间的定义"></a>4.1 名称空间的定义</h3><ul><li>名称空间使用<code>namespace</code>关键字定义。</li><li>名称空间可以包含变量、函数、类、枚举、<code>typedef</code>等声明。</li><li>名称空间可以嵌套,即一个名称空间可以包含另一个名称空间</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="type">int</span> variable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">        <span class="comment">// 类定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-名称空间的使用"><a href="#4-2-名称空间的使用" class="headerlink" title="4.2 名称空间的使用"></a>4.2 名称空间的使用</h3><p>我们需要使用作用域解析运算符<code>::</code>来访问名称空间中的标识符，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNamespace::variable = <span class="number">20</span>;</span><br><span class="line">MyNamespace::<span class="built_in">function</span>();</span><br><span class="line">MyNamespace::MyClass obj;</span><br></pre></td></tr></table></figure><p>也可以直接使用<code>using namespace</code>声明可以将名称空间中的标识符引入到当前作用域，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MyNamespace;</span><br><span class="line">variable = <span class="number">20</span>; <span class="comment">// 可以直接使用变量</span></span><br><span class="line"><span class="built_in">function</span>(); <span class="comment">// 可以直接调用函数</span></span><br><span class="line">MyClass obj; <span class="comment">// 可以直接创建对象</span></span><br></pre></td></tr></table></figure><p>也可以仅引入名称空间中的特定标识符,使用<code>using</code>声明，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyNamespace::variable;</span><br><span class="line"><span class="keyword">using</span> MyNamespace::function;</span><br><span class="line">variable = <span class="number">20</span>;<span class="comment">// 可以使用引入的变量</span></span><br><span class="line"><span class="built_in">function</span>();<span class="comment">// 可以使用引入的函数</span></span><br></pre></td></tr></table></figure><p>名称空间还支持嵌套，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Outer &#123;</span><br><span class="line">    <span class="type">int</span> variable = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">namespace</span> Inner &#123;</span><br><span class="line">        <span class="type">int</span> variable = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; Outer::variable &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; variable &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《C++ Prime Plus》</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Cpp Primer Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp复习 Chapter 1 内联函数、引用变量、函数重载、函数模板</title>
      <link href="/2024/02/11/Cpp%E5%A4%8D%E4%B9%A0-Chapter-1-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E3%80%81%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/02/11/Cpp%E5%A4%8D%E4%B9%A0-Chapter-1-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E3%80%81%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-Chapter-1-内联函数、引用变量、函数重载、函数模板"><a href="#Cpp复习-Chapter-1-内联函数、引用变量、函数重载、函数模板" class="headerlink" title="Cpp复习 Chapter 1 内联函数、引用变量、函数重载、函数模板"></a>Cpp复习 Chapter 1 内联函数、引用变量、函数重载、函数模板</h1><hr><center><font color=“#EEFFAA” size=56>Cpp系列笔记目录</font></center><p><strong><a href="https://blog.csdn.net/qq_44940689/article/details/140938473?spm=1001.2014.3001.5502">【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140951702?spm=1001.2014.3001.5502">【Cpp筑基】二、声明 vs 定义、头文件、存储持续性作用域和链接性、名称空间</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/140962363?spm=1001.2014.3001.5502">【Cpp筑基】三、对象和类</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141018490?spm=1001.2014.3001.5501">【Cpp筑基】四、重载运算符、友元、类的转换函数</a><br><a href="https://blog.csdn.net/qq_44940689/article/details/141067994?spm=1001.2014.3001.5501">【Cpp筑基】五、类的继承、虚函数、抽象基类</a></strong></p><hr><h1 id="【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板"><a href="#【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板" class="headerlink" title="【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板"></a>【Cpp筑基】一、内联函数、引用变量、函数重载、函数模板</h1><h2 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1. 内联函数"></a>1. 内联函数</h2><p>C++提供了一种内联函数，在 C++ 中，内联函数（inline function）是一种特殊的函数，其定义使用 <code>inline</code> 关键字来提示编译器将函数调用直接替换为函数体，以减少函数调用的开销。内联函数通常用于简短、频繁调用的函数。</p><p>要使用内联函数，必须：</p><ul><li>在函数声明前加上关键字<code>inline</code></li><li>在函数定义前加上关键字<code>inline</code></li></ul><p>注意内联函数不能递归。内联函数的基本语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> return_type <span class="title">function_name</span><span class="params">(parameters)</span></span>&#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 7</span><br></pre></td></tr></table></figure><p><code>inline</code>工具是C++新增的特性，C语言使用预处理器语句<code>#define</code>来提供宏——内联代码的原始实现。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br></pre></td></tr></table></figure><p><code>inline</code>和<code>#define</code>的主要区别是：</p><ol><li>实现机制：<ul><li>内联函数是由编译器在编译时展开的,是一种编译时的语言特性。编译器会在调用内联函数的地方直接替换函数体。</li><li>而<code>#define</code>宏是在预处理阶段展开的,是一种文本替换的机制。预处理器会在编译前把宏展开。</li></ul></li><li>类型检查：<ul><li>内联函数有类型检查,编译器会检查参数类型是否匹配。</li><li><code>#define</code>宏是简单的文本替换,没有类型检查,容易出现类型错误。</li></ul></li><li>时间和空间开销：<ul><li>内联函数在编译时展开,没有函数调用的开销,但会增加程序的大小，增加空间成本。</li><li><code>#define</code>宏在预处理阶段展开,没有函数调用开销,但可能会导致代码膨胀。</li></ul></li></ol><h2 id="2-引用变量"><a href="#2-引用变量" class="headerlink" title="2. 引用变量"></a>2. 引用变量</h2><p>C++新增了一种复合类型——引用变量，使用运算符<code>&amp;</code>，引用变量的主要用途是作为函数参数列表中的形参。例如，创建一个引用变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：引用必须在声明时进行初始化，而不能像指针一样，先声明再赋值。引用一旦与变量进行关联，就一直指向这个变量。</p><p>C++11中新增了另一种引用——&#x3D;&#x3D;右值引用&#x3D;&#x3D;（rvalue reference)，这种引用可以指向<strong>右值</strong>，使用<code>&amp;&amp;</code>进行声明。</p><p>在 C++ 中，“<strong>左值</strong>”（lvalue）和“<strong>右值</strong>”（rvalue）是用来描述表达式值类型的一对术语。理解它们的概念对于掌握 C++ 语言的赋值、引用、移动语义等方面的内容非常重要。</p><p>左值（lvalue，locatable value）是指能够定位的值，它表示存储在内存中的某个位置的对象。因此，左值是可以取地址的，可以出现在赋值操作的左侧。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;   <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span> *p = &amp;x;  <span class="comment">// 可以取地址</span></span><br><span class="line">x = <span class="number">20</span>;       <span class="comment">// 可以出现在赋值操作的左侧</span></span><br></pre></td></tr></table></figure><p>右值（rvalue，readable value）是指不具有持久存储位置的临时值，它通常是表达式求值的结果。右值不能取地址，也不能出现在赋值操作的左侧。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>;     <span class="comment">// 10 是右值</span></span><br><span class="line"><span class="type">int</span> z = y + <span class="number">5</span>;  <span class="comment">// (y + 5) 是右值</span></span><br><span class="line"><span class="type">int</span> *p = &amp;<span class="number">10</span>;   <span class="comment">// 错误，不能对右值取地址</span></span><br></pre></td></tr></table></figure><p>左值引用是对左值的引用，用于绑定左值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = a;  <span class="comment">// 左值引用</span></span><br><span class="line">ref = <span class="number">20</span>;      <span class="comment">// 可以通过引用修改 a 的值</span></span><br></pre></td></tr></table></figure><p>右值引用是对右值的引用，用于绑定右值。这是 C++11 引入的特性，主要用于实现移动语义和完美转发，以提高性能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rref = <span class="number">10</span>;  <span class="comment">// 右值引用</span></span><br><span class="line">rref = <span class="number">20</span>;        <span class="comment">// 可以通过引用修改右值</span></span><br></pre></td></tr></table></figure><p>新增右值引用主要是用于<strong>移动语义</strong>和<strong>完美转发</strong>，理解左值和右值的区别是掌握 C++ 高级特性（如移动语义和完美转发）的基础。</p><p>&#x3D;&#x3D;引用常用于函数的参数传递&#x3D;&#x3D;，这样可以避免不必要的拷贝，并且允许函数修改传入的参数值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap</span>(x, y); <span class="comment">// x 和 y 的值被交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在使用引用进行函数的参数传递的时候，我们应该尽可能使用<code>const</code>，将引用参数声明为常量数据的引用的理由有三个:</p><ul><li>使用<code>const</code>可以避免无意中修改数据的编程错误</li><li>使用<code>const</code>使函数能够处理<code>const</code>和非<code>const</code>实参，否则将只能接受非<code>const</code>数据</li><li>使用<code>const</code>引用使函数能够正确生成并使用临时变量</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 const 引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Non-const reference: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    s = <span class="string">&quot;modified&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 const 引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printConstString</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Const reference: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// s = &quot;modified&quot;; // 错误,无法修改 const 引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用非 const 引用</span></span><br><span class="line">    <span class="built_in">printString</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After printString(): &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 const 引用</span></span><br><span class="line">    <span class="built_in">printConstString</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After printConstString(): &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Non-const reference: hello</span><br><span class="line">After printString(): modified</span><br><span class="line">Const reference: modified</span><br><span class="line">After printConstString(): modified</span><br></pre></td></tr></table></figure><p><strong>什么时候使用引用和指针呢？</strong></p><p>使用引用参数的主要原因有两个：</p><ul><li>程序员能够修改调用函数中的数据对象</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li></ul><p>对于使用传递的值而不做修改的函数：</p><ul><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为<code>const</code></li></ul><h2 id="3-函数重载"><a href="#3-函数重载" class="headerlink" title="3. 函数重载"></a>3. 函数重载</h2><p>C++实现&#x3D;&#x3D;多态&#x3D;&#x3D;有两种方式，</p><ul><li>编译时多态Compile-time Polymorphism（通过函数重载和模板实现）</li><li>运行时多态Runtime Polymorphism（通过继承和虚函数实现）</li></ul><p>函数重载的关键是函数的<strong>参数列表（也称为特征标）</strong>，如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是不重要的。C++允许定义相同名称的函数前提是他们的特征标不同。</p><p>举个例子，编译时多态可以通过函数重载或者是通过模板进行实现：</p><ol><li><p>通过函数重载进行实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数重载实现多态</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">42</span>);         <span class="comment">// 调用 void print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);       <span class="comment">// 调用 void print(double)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);    <span class="comment">// 调用 void print(const std::string&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过函数模板进行实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">42</span>);          <span class="comment">// T 被推断为 int</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);        <span class="comment">// T 被推断为 double</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// T 被推断为 const char*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>C++中的运行时多态（Runtime Polymorphism）是通过继承和虚函数（virtual functions）实现的。这种多态性允许在运行时根据对象的实际类型调用适当的方法，而不是在编译时决定调用哪个函数。运行时多态的核心是使用基类指针或引用来操作派生类对象。</p><p>运行时多态主要依赖以下的几个概念：</p><ul><li>继承（Inheritance）：允许一个类继承另一个类的属性和方法。</li><li>虚函数（Virtual Functions）：在基类中声明为virtual的函数，可以在派生类中被重写。</li><li>虚函数表（Virtual Table, vtable）：编译器为包含虚函数的类生成的一个表，表中存储了类的虚函数指针。每个对象包含一个指向其类的虚函数表的指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，定义接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// = 0 表示纯虚函数，必须在派生类中实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;            <span class="comment">// 虚析构函数，以确保派生类的析构函数被调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Circle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Rectangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Rectangle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建基类指针数组，指向派生类对象</span></span><br><span class="line">    Shape* shapes[<span class="number">2</span>];</span><br><span class="line">    shapes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组并调用虚函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        shapes[i]-&gt;<span class="built_in">draw</span>(); <span class="comment">// 根据对象的实际类型调用相应的draw方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> shapes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数模板"><a href="#4-函数模板" class="headerlink" title="4. 函数模板"></a>4. 函数模板</h2><p>函数模板有两种定义方式，第一种使用关键字<code>template</code>和<code>typename</code>，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span> <span class="params">(T &amp; a)</span></span>;<span class="comment">// 随便定义一个函数</span></span><br></pre></td></tr></table></figure><p>第二种是使用关键字<code>template</code>和<code>class</code>，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span> <span class="params">(T &amp; a)</span></span>;<span class="comment">// 随便定义一个函数</span></span><br></pre></td></tr></table></figure><p>其中，<code>template&lt;typename T&gt;</code> 是模板头，表示这个函数是一个模板函数，<code>T</code>是一个类型参数，可以是任意合法的类型。<code>T</code>可以用在函数的返回类型、参数列表和函数体内。</p><ol><li><p>模板类型可以有多种形式，不仅限于一个，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>, <span class="string">&quot; apples&quot;</span>);     <span class="comment">// T1 被推断为 int，T2 被推断为 const char*</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>, <span class="number">42</span>);          <span class="comment">// T1 被推断为 double，T2 被推断为 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了类型参数，模板还可以具有非类型参数，例如：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getArrayElement</span><span class="params">(T (&amp;arr)[N], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getArrayElement</span>(arr, <span class="number">2</span>) &lt;&lt; std::endl;  <span class="comment">// 输出 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>N</code>是一个非类型模板参数，它表示数组的大小。</p><ol start="3"><li>模板参数也可以有默认值，例如</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">int</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;    <span class="comment">// 使用默认类型 int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3.14</span>, <span class="number">2.0</span>) &lt;&lt; std::endl; <span class="comment">// 显式指定类型为 double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模板还允许提供具体化版本，即对特定的类型提供不同的版本，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 std::string 的完全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">std::string <span class="built_in">add</span>&lt;std::string&gt;(std::string a, std::string b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&quot; specialized &quot;</span> + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;          <span class="comment">// 输出 7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">2.1</span>) &lt;&lt; std::endl;      <span class="comment">// 输出 5.6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>&lt;std::string&gt;(<span class="string">&quot;Hello, &quot;</span>, <span class="string">&quot;World!&quot;</span>) &lt;&lt; std::endl;  <span class="comment">// 输出 Hello,  specialized World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板具有显式具体化机制，显式具体化就是为特定的类型提供函数模板的特化版本，这里针对<code>std::string</code>类型提供了一个不同版本的<code>add</code>函数。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《C++ Prime Plus》</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Cpp Primer Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Algo学习笔记 1. 复杂度分析 + 栈</title>
      <link href="/2024/01/18/Hello-Algo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/18/Hello-Algo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-Algo学习笔记-1-复杂度分析-栈"><a href="#Hello-Algo学习笔记-1-复杂度分析-栈" class="headerlink" title="Hello Algo学习笔记 1. 复杂度分析 + 栈"></a>Hello Algo学习笔记 1. 复杂度分析 + 栈</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>​递归 recursion 和常用的循环迭代不一样，这种策略算法通过调用自身来解决问题，它主要包含两个方面：</p><ol><li>递：程序不断深入调用自身，通常传入更下或更简化的参数，直到达到“终止条件”</li><li>归：出发“终止条件”之后，程序从最深处开始逐层返回，并且汇聚每一层的结果。</li></ol><p>从实现的角度来说，设计递归算法主要需要三个主要的条件</p><ol><li>终止条件：什么条件下终止“递”，从而开始“归”</li><li>递归调用：对应“递”，函数里应该不断调用自身，通常传入更小的参数</li><li>返回递归的结果：对应“归”，将当前递归层级的结果返回到上一级中。</li></ol><p>虽然从计算的角度来看，迭代与递归可以获得相类似的结果，但是它们是两种完全不同的思考和解决问题的范式。</p><ul><li>迭代：“自下而上”地解决问题，从基础的步骤开始，然后不断重复或者累加这些步骤，直到完成任务。</li><li>递归：”自上而下“地解决问题，如果问题和其子问题具有相同的形式，将原问题拆分为更小的部分，通过确定终止条件和返回结果来完成递归的调用。</li></ul><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>​递归函数每次调用自身的时候，系统都会为其开启新的函数分配内存，来存储局部变量、调用地址和其他信息，这就会导致递归比迭代更消耗内存空间。</p><ul><li>函数的上下文数据都存储在称为”栈帧空间“的内存区域中，直到函数返回之后才会被释放。</li><li>递归函数会产生额外的开销。因此递归通常比循环的时间效率更低。</li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>​如果函数在返回前的最后一步才进行递归调用，则这种递归就被称为<strong>尾递归 tail recursion</strong>，这种尾递归可以通过编译器来实现自动优化，递归和迭代的特点对比如下：</p><table><thead><tr><th align="left"></th><th align="left">迭代</th><th align="left">递归</th></tr></thead><tbody><tr><td align="left">实现方式</td><td align="left">循环结构</td><td align="left">函数调用自身</td></tr><tr><td align="left">时间效率</td><td align="left">效率通常较高，无函数调用开销</td><td align="left">每次函数调用都会产生开销</td></tr><tr><td align="left">内存使用</td><td align="left">通常使用固定大小的内存空间</td><td align="left">累积函数调用可能使用大量的栈帧空间</td></tr><tr><td align="left">适用问题</td><td align="left">适用于简单循环任务，代码直观、可读性好</td><td align="left">适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td></tr></tbody></table><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>​我们常说的时间复杂度，其实是指算法的渐进上界，其数学定义如下：</p><p>若存在正实数$c$和实数$n_0$，使得对于所有的$n&gt; n_0$，均有$T(n)\le c \cdot f(n)$，则可以认为$f(n)$给出了$T(n)$的一个渐进上界，记为$T(n)&#x3D;O(f(n))$。</p><p>计算渐进上界其实就是寻找一个函数$f(n)$，使得当$n$趋于$\infty$的时候，$T(n)$和$f(n)$处于相同的增长级别。</p><p>​计算时间复杂度，可以遵循下列的计算技巧：</p><ul><li>忽略$T(n)$中的常数项，因为常数项对时间复杂度都不产生影响</li><li>省略所有系数</li><li>循环嵌套的时候使用乘法</li><li>时间复杂度由$T(n)$中的最高阶项来决定</li></ul><p>常见的时间复杂度类型有：<br>$$<br>O(1) &lt; O(\log n) &lt; O(n) &lt; O(n\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)<br>$$<br>指数阶对应的是每次增加一倍的情况，类似与”细胞分裂“的过程，而对数阶对应的是每次缩减一倍的情况。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>​空间复杂度的推算方法与时间复杂度大致相同，只是将统计的对象从“操作数”变为了“使用内存大小”，与时间复杂度不同，我们只需要关注于最差空间复杂度，因为内存空间是一项硬性要求，我们必须确保所有的输入数据都有足够的内存空间预留。最差空间复杂度表示以算法运行中的峰值内存为准。</p><h2 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h2><p>原码、反码和补码的引入都为了加速计算机的运算，所有的数字都是以“补码”的形式存储在计算机中的，三者的定义如下：</p><ul><li>原码 sign-magnitude：将数字的最高位视为符号位，用0表示正数，1表示负数，其余的位置用于存放数字</li><li>反码 1’s complement：除了最高位符号位不变，其余位置均取反</li><li>补码 2’s complement：将反码+1</li></ul><p>出现反码的原因是计算为了方便计算减法，直接使用反码相加就能够同时计算加法和减法；为了解决0在存储的过程中出现+0和-0的区别，使用补码来让0的补码也是0，消除了零正负奇异的问题。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组array是一种线性的数据结构，其将相同类型的数据存储在连续的内存空间当中，我们将元素在数组中的位置称为该元素的索引index，索引本质上是<strong>内存地址的偏移量</strong>，所以数组中的第一个元素的索引是0。由于索引的设计，我们访问数组中的任意一个元素的时间复杂度为$O(1)$。<strong>数组支持随机访问</strong>。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表linked list是一种线性数据结构，其中每一个元素都是一个节点，各个节点通过“引用”（指针）相连接，引用记录了下一个节点的物理地址。链表的设计使得其可以分散在内存的各处，并且它们的内存地址无须连续。</p><p>用python实现链表的Node：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val<span class="comment">#当前节点值</span></span><br><span class="line">        self.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span> <span class="comment">#指向下一个节点的指针</span></span><br></pre></td></tr></table></figure><p><strong>链表不支持随机访问</strong>，访问元素的时间复杂度为$O(n)$。</p><p>表 4-1  数组与链表的效率对比</p><table><thead><tr><th align="left"></th><th align="left">数组</th><th align="left">链表</th></tr></thead><tbody><tr><td align="left">存储方式</td><td align="left">连续内存空间</td><td align="left">分散内存空间</td></tr><tr><td align="left">容量扩展</td><td align="left">长度不可变</td><td align="left">可灵活扩展</td></tr><tr><td align="left">内存效率</td><td align="left">元素占用内存少、但可能浪费空间</td><td align="left">元素占用内存多</td></tr><tr><td align="left">访问元素</td><td align="left">$O(1)$</td><td align="left">$O(n)$</td></tr><tr><td align="left">添加元素</td><td align="left">$O(n)$</td><td align="left">$O(1)$</td></tr><tr><td align="left">删除元素</td><td align="left">$O(n)$</td><td align="left">$O(n)$</td></tr></tbody></table><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈stack是一种先进后出的数据结构，栈一般包括如下的一些操作：</p><p>表 5-1  栈的操作效率</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push()</code></td><td align="left">元素入栈（添加至栈顶）</td><td align="left">$O(1)$</td></tr><tr><td align="left"><code>pop()</code></td><td align="left">栈顶元素出栈</td><td align="left">$O(1)$</td></tr><tr><td align="left"><code>peek()</code></td><td align="left">访问栈顶元素</td><td align="left">$O(1)$</td></tr></tbody></table><p>栈的实现有几种方式，第一种是基于链表的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于链表的栈实现&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._peek: LinkNode | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">        self._size: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._peek</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;栈为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._peek.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        node = LinkNode(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self._peek</span><br><span class="line">        self._peek = node</span><br><span class="line">        self._size += <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        val = self.peek()</span><br><span class="line">        self._peek = self._peek.<span class="built_in">next</span></span><br><span class="line">        self._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;转换成list方便调试&quot;&quot;&quot;</span></span><br><span class="line">        arr = []</span><br><span class="line">        node = self._peek</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            arr.append(node.val)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> arr.reverse()</span><br></pre></td></tr></table></figure><p>第二种是基于列表的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._stack: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self._stack == []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item: <span class="built_in">int</span></span>):</span><br><span class="line">        self._stack.append(item)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;栈为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._stack.pop()</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empy():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;栈为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self._stack</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.hello-algo.com/">Hello算法</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Data Structure </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客 教程(三)客制化butterfly主题</title>
      <link href="/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%89-%E5%AE%A2%E5%88%B6%E5%8C%96butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%89-%E5%AE%A2%E5%88%B6%E5%8C%96butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-Hexo-Github-Build-Your-Blog-教程-三-客制化butterfly主题"><a href="#Use-Hexo-Github-Build-Your-Blog-教程-三-客制化butterfly主题" class="headerlink" title="Use Hexo + Github Build Your Blog 教程(三)客制化butterfly主题"></a>Use Hexo + Github Build Your Blog 教程(三)客制化butterfly主题</h1><h2 id="参考官方的配置教程"><a href="#参考官方的配置教程" class="headerlink" title="参考官方的配置教程"></a>参考官方的配置教程</h2><p>每个主题都有自己的配置方法，官方都有详细的说明，可以参考官方的说明文档。这里以博主使用的<code>butterfly</code>主题为例。<code>butterfly</code>的官方配置教程在这里<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>我们的大部分修改要在主题文件的<code>_config.yml</code>和hexo目录中的<code>_config.yml</code>文件中进行。</p><h2 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h2><p>在<code>_config.yml</code>中找到字段<code>Site</code>，修改基本信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">网站的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">网站作者名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># en # zh-TW</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>在<code>themes/butterfly/_config.yml</code>进行修改，具体的修改方式可以参考官方的说明文档<a href="https://butterfly.js.org/">https://butterfly.js.org/</a>。这里不再赘述了。</p><h2 id="为butterfly主题添加Gitalk评论功能"><a href="#为butterfly主题添加Gitalk评论功能" class="headerlink" title="为butterfly主题添加Gitalk评论功能"></a>为butterfly主题添加Gitalk评论功能</h2><p>使用gitalk评论系统，原因是因为它可以直接在github上管理评论，不需要在别的平台注册，并且有github的背书，所以安全性更高。</p><h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><p>点开Github头像，点击<code>Settings</code>，然后点击<code>Developer settings</code>，再点<code>OAuth Apps</code>，然后点击<code>New OAuth App</code>。</p><p>填写相关信息，注意<code>Homepage URL</code>和<code>Authorization callback URL</code>要填写博客的地址。</p><img src="https://pic.imgdb.cn/item/658ce904c458853aefb3205f.jpg" class="" title="注册OAuth Application"><img src="https://pic.imgdb.cn/item/658ce99dc458853aefb4ba76.jpg" class="" title="Client ID"><h3 id="配置Gitalk"><a href="#配置Gitalk" class="headerlink" title="配置Gitalk"></a>配置Gitalk</h3><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>comments</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span></span><br><span class="line">  <span class="attr">use:</span>  <span class="string">Gitalk</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><p>然后找到<code>gitalk</code>字段，修改如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitalk</span></span><br><span class="line"><span class="comment"># https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxxxxxxxxxxx</span> <span class="string">your</span> <span class="string">client</span> <span class="string">id</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxxxxxxxxxxxxxxxxxx</span> <span class="string">your</span> <span class="string">client</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">shenmuxin.github.io</span> <span class="comment"># 博客的仓库名称(注意不是地址)</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">shenmuxin</span> <span class="comment"># github用户名</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">shenmuxin</span> <span class="comment"># github用户名</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>这样就成功配置了<code>Gitalk</code>，效果如下</p><img src="https://pic.imgdb.cn/item/658ceac7c458853aefb81024.jpg" class="" title="Gitalk效果"><h2 id="为butterfly配置加载动画preloader"><a href="#为butterfly配置加载动画preloader" class="headerlink" title="为butterfly配置加载动画preloader"></a>为butterfly配置加载动画preloader</h2><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>preloader</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loading Animation (加載動畫)</span></span><br><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source</span></span><br><span class="line">  <span class="comment"># 1. fullpage-loading</span></span><br><span class="line">  <span class="comment"># 2. pace (progress bar)</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># pace theme (see https://codebyzach.github.io/pace/)</span></span><br><span class="line">  <span class="attr">pace_css_url:</span></span><br></pre></td></tr></table></figure><h2 id="为butterfly配置打字副标题"><a href="#为butterfly配置打字副标题" class="headerlink" title="为butterfly配置打字副标题"></a>为butterfly配置打字副标题</h2><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>subtitle</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主頁subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js (配置typed.js)</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span></span><br><span class="line">  <span class="comment"># source 調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  調用一句網（簡體） https://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Your</span> <span class="string">slogan.</span></span><br></pre></td></tr></table></figure><h2 id="为butterfly配置local-search"><a href="#为butterfly配置local-search" class="headerlink" title="为butterfly配置local search"></a>为butterfly配置local search</h2><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>local_search</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">-1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure><p>然后前往博客的根目录，安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h2 id="使用更好的渲染器"><a href="#使用更好的渲染器" class="headerlink" title="使用更好的渲染器"></a>使用更好的渲染器</h2><p>首先安装<code>Mathjax</code>插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>然后更改Hexo的Markdown渲染器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>修改转义配置进入<code>node_modules\kramed\lig\rules\inline.js</code><br>找到<code>escape</code>字段，修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>找到<code>em</code>字段，修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/qisi007/p/13731562.html">https://www.cnblogs.com/qisi007/p/13731562.html</a><br><a href="https://blog.misaka.rest/2023/02/01/hexo-gitalk/">https://blog.misaka.rest/2023/02/01/hexo-gitalk/</a><br><a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br><a href="https://shanhainanhua.github.io/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/">https://shanhainanhua.github.io/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客 教程(二)配置github与自选主题</title>
      <link href="/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%BA%8C-%E9%85%8D%E7%BD%AEgithub%E4%B8%8E%E8%87%AA%E9%80%89%E4%B8%BB%E9%A2%98/"/>
      <url>/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%BA%8C-%E9%85%8D%E7%BD%AEgithub%E4%B8%8E%E8%87%AA%E9%80%89%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-Hexo-Github-Build-Your-Blog-教程-二-配置github与自选主题"><a href="#Use-Hexo-Github-Build-Your-Blog-教程-二-配置github与自选主题" class="headerlink" title="Use Hexo + Github Build Your Blog 教程(二)配置github与自选主题"></a>Use Hexo + Github Build Your Blog 教程(二)配置github与自选主题</h1><h2 id="配置github远端连接"><a href="#配置github远端连接" class="headerlink" title="配置github远端连接"></a>配置github远端连接</h2><p>我们需要在<code>Github</code>上新建一个仓库来托管我们的网页，需要注意<code>Github</code>只能使用一个同名的仓库名来托管一个静态的站点，所以我新建的仓库名字应该和我们的用户名一致，比如我的用户名是<code>shenmuxin</code>，那么我的仓库名应该为<code>shenmuxin.github.io</code>，具体可以参考下图</p><img src="https://pic.imgdb.cn/item/658cde5bc458853aef90518d.jpg" class="" title="创建github仓库"><p>然后我们需要配置SSH key，这样我们就可以通过SSH来连接<code>Github</code>了，具体操作如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your email(和上面的邮箱一致)&quot;</span></span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，便可以生成SSH key，可以采用以下的指令来查看自己生成的SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>也可以手动打开<code>~/.ssh/id_rsa.pub</code>文件来查看，复制SSH key的全部内容</p><img src="https://pic.imgdb.cn/item/658cdf64c458853aef941ad2.jpg" class="" title="ssh key的路径"><p>然后将SSH key添加到<code>Github</code>上，在<code>Github</code>上找到<code>Settings</code>，然后找到<code>SSH and GPG keys</code>，点击<code>New SSH key</code>，将SSH key的内容粘贴到<code>Key</code>中，然后点击<code>Add SSH key</code></p><img src="https://pic.imgdb.cn/item/658cdfdcc458853aef956abe.jpg" class="" title="添加ssh key"><p>然后在<code>_config.yml</code>文件中进行配置，</p><img src="https://pic.imgdb.cn/item/658ce091c458853aef976745.jpg" class="" title="配置_config.yml"><p>将<code>deploy</code>的配置修改为如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/your name/your name.github.io.git</span><br><span class="line">  brach: master</span><br></pre></td></tr></table></figure><p>然后再安装一个部署从插件<code>hexo-deployer-git</code>,在博客文件中使用<code>Git Bash Here</code>打开终端，输入以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行如下的两条命令就能够部署上传了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时用浏览器打开<code>your name.github.io</code>就能访问你的网页了。</p><h2 id="配置好看的主题"><a href="#配置好看的主题" class="headerlink" title="配置好看的主题"></a>配置好看的主题</h2><p>Hexo官方收录了许多好看主题，可以在这里找到<a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a>，笔者使用的主题是<code>butterfly</code>，<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>。<br>直接下载主题文件夹，然后放置在<code>themes</code>文件夹下，在<code>themes/butterfly/_config.yml</code>文件中进行配置，选择当前使用的主题名字</p><img src="https://pic.imgdb.cn/item/658ce2fec458853aef9ebfa0.jpg" class="" title="配置主题"><p>然后我们可以进行渲染</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>查看当前的主题效果。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br><a href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;d02fb26eb2345ac42c054db0bb8d8864</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客 教程(一)搭建基本环境与基本操作</title>
      <link href="/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%80-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%80-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-Hexo-Github-Build-Your-Blog-教程-一-搭建基本环境与基本操作"><a href="#Use-Hexo-Github-Build-Your-Blog-教程-一-搭建基本环境与基本操作" class="headerlink" title="Use Hexo + Github Build Your Blog 教程(一)搭建基本环境与基本操作"></a>Use Hexo + Github Build Your Blog 教程(一)搭建基本环境与基本操作</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先笔者使用的操作系统环境为<code>windows11</code>,以下默认的安装环境为<code>windows11</code>。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>首先下载Git，<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>下载完成后直接安装即可。然后在git中进行基本配置，首先绑定自己的<code>Github</code>账号，鼠标右键点击<code>Git Bash Here</code>打开Git的终端，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><p>将相应位置替换为你自己的<code>Github</code>账号信息。配置完成之后可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>查看一下配置是否正确。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>然后，下载Nodejs，<a href="https://nodejs.org/en">https://nodejs.org/en</a><br>下载完成后直接安装即可。安装完成之后，查看安装是否正确，同样用<code>Git Bash Here</code>打开终端，然后在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果出现了相应的版本号，则说明安装成功。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装Hexo，在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>等待安装完成后，查看版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>如果出现了相应的版本号，则说明安装成功。</p><h2 id="初始化Blog文件"><a href="#初始化Blog文件" class="headerlink" title="初始化Blog文件"></a>初始化Blog文件</h2><ul><li>使用Hexo初始化一个博客文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init YourBlogFileName</span><br><span class="line"><span class="built_in">cd</span> YourBlogFileName</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>等待安装完成，我们可以直接进行渲染，看安装是否正确</p><ul><li>开启Hexo服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment">#或者缩写成 hexo s</span></span><br></pre></td></tr></table></figure><p>如果过程无误，可以打开本地的端口<code>http://localhost:4000/</code>查看网页的效果，那么显示的结果应该如下所示</p><img src="https://pic.imgdb.cn/item/658cdac6c458853aef83433f.png" class="" width="1000" height="600" title="渲染结果"><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>使用Hexo初始化blog</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init YourBlogFileName</span><br><span class="line"><span class="built_in">cd</span> YourBlogFileName</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li>新建一个page</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;YourPageName&quot;</span></span><br></pre></td></tr></table></figure><ul><li>新建一个post</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;YourPostName&quot;</span></span><br></pre></td></tr></table></figure><ul><li>生成静态文件（可以理解为编译）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment"># 缩写为 hexo g</span></span><br></pre></td></tr></table></figure><ul><li>渲染（开启服务）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 缩写为 hexo s</span></span><br></pre></td></tr></table></figure><ul><li>清除构建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 缩写为 hexo c</span></span><br></pre></td></tr></table></figure><ul><li>推送到远端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy <span class="comment"># 缩写为 hexo d</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;d02fb26eb2345ac42c054db0bb8d8864</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 5. Monte Carlo Learning]</title>
      <link href="/2023/07/24/Reinforcement-Learning-with-Code-Chapter-5-Monte-Carlo-Learning/"/>
      <url>/2023/07/24/Reinforcement-Learning-with-Code-Chapter-5-Monte-Carlo-Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code"></a>Reinforcement Learning with Code</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-5-Monte-Carlo-Learning"><a href="#Chapter-5-Monte-Carlo-Learning" class="headerlink" title="Chapter 5. Monte Carlo Learning"></a>Chapter 5. Monte Carlo Learning</h2><p>​What is Monte Carlo estimation? Monte Carlo estimation refers to a broad class of techniques that use stochastic samples to solve approximation problems using the <font color=blue>Law of Large Numbers</font>. </p><p>​ChatGpt tells us that “Monte Carlo estimation is a statistical method used to estimate unknown quantities or solve problems by generating random samples and using the law of large numbers to approximate the true value.”</p><h3 id="5-1-Law-of-large-numbers"><a href="#5-1-Law-of-large-numbers" class="headerlink" title="5.1 Law of large numbers"></a>5.1 Law of large numbers</h3><p>​(Law of Large Numbers) <em>For a random variable</em> $X$. <em>Suppose</em> ${x_i}<em>{i&#x3D;1}^n$ <em>are some independent and indentically distribution (iid) samples</em>. <em>Let</em> $\bar{x}&#x3D;\frac{1}{n}\sum</em>{i&#x3D;1}^n x_i$ <em>be the average of the samples. Then</em>,<br>$$<br>\mathbb{E}[\bar{x}] &#x3D; \mathbb{E}[X]\<br>\mathrm{var}[\bar{x}] &#x3D; \frac{1}{n} \mathrm{var}[X]<br>$$<br>The above two equations indicate that $\bar{x}$ is an <em>unbiased estimate</em> of $\mathbb{E}[X]$ and its variance decreases to zero as $n$ increases to infinity.</p><p>​<strong>Proof</strong>, First, $\mathbb{E}[\bar{x}] &#x3D; \mathbb{E}[\frac{1}{n}\sum_{i&#x3D;1}^n x_i]&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n\mathbb{E}[x_i]&#x3D;\frac{1}{n}n\mathbb{E}[X]&#x3D;\mathbb{E}[X]$, where the last equability is because the samples are <em>independent and indentically distribution (iid)</em> (that is, $\mathbb{E}[x_i]&#x3D;\mathbb{E}[X]$).</p><p>​Second, $\mathrm{var}[\bar{x}]&#x3D;\mathrm{var}[\frac{1}{n}\sum_{i&#x3D;1}^n x_i]&#x3D;\frac{1}{n^2}\sum_{i&#x3D;1}^n\mathrm{var}[x_i]&#x3D;\frac{1}{n^2}n*\mathrm{var}[X]&#x3D;\frac{1}{n}\mathrm{var}[X]$, where the second equality is because the samples are <em>independent and indentically distribution (iid)</em> (that is, $\mathrm{var}[x_i]&#x3D;\mathrm{var}[X]$)</p><h3 id="5-2-Simple-example"><a href="#5-2-Simple-example" class="headerlink" title="5.2 Simple example"></a>5.2 Simple example</h3><p>​Consider a problem that we need to calculate the expectation $\mathbb{E}[X]$ of random variable $X$ which takes value in the finite set $\mathcal{X}$. There are two ways. </p><p>​First, <em>model-based</em> approach, we can use the definition of expectation that<br>$$<br>\mathbb{E}[X] &#x3D; \sum_{x\in\mathcal{X}} p(x)x<br>$$<br>​Second, <em>model-free</em> approach, if the probability of distribution is unknown we can use the <em>Law of Large Numbers</em> to estimate the expectation.<br>$$<br>\mathbb{E}[X]\approx \bar{x} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n x_i<br>$$<br>The example gives us an intutition that: When the system model is available, the expectation can be calculated based on the model.</p><p>When the model is unavailable, the expectation can be estimated approximately using stochastic samples.</p><h3 id="5-3-Monte-Carlo-Basic"><a href="#5-3-Monte-Carlo-Basic" class="headerlink" title="5.3 Monte Carlo Basic"></a>5.3 Monte Carlo Basic</h3><p><strong>Review policy iteration</strong>:</p><p>​The simplest Monte Carlo learning also called Monte Carlo Basic (MC Basic) just replaces the policy iteration model-based part by MC estimation. Recall the <font color=blue>matrix-vector form of policy iteration</font></p><p>$$<br>\begin{aligned}<br>    v_{\pi_k}^{(j+1)} &amp; &#x3D; r_{\pi_k} + \gamma P_{\pi_k} v_{\pi_k}^{(j)}\quad \text{(policy evaluation)} \<br>    \pi_{k+1} &amp; &#x3D; \arg \max_{\pi_k}(r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k})\quad \text{(policy improvement)}<br>\end{aligned}<br>$$</p><p>The <font color=blue>elementwise form of policy iteration</font> is</p><p>$$<br>\begin{aligned}<br>    v_{\pi_k}^{(j+1)}(s) &amp; &#x3D; \sum_a \pi_k(a|s) \Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k}^{(j)} (s^\prime)\Big)\quad \text{(policy evaluation)}\<br>    \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k}  \sum_a \pi(a|s)<br>    \underbrace{<br>    \Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k} (s^\prime)\Big)}<em>{q</em>{\pi_k}(s,a)}<br>    \quad \text{(policy improvement)}\<br>    \to \pi_{k+1}(s) &amp; &#x3D;  \sum_a \pi(a|s) \arg \max_a q_{\pi_k}(s,a)<br>\end{aligned}<br>$$</p><p>Its obvious that the core is to calculate the action values by usting<br>$$<br>q_{\pi_k}(s,a) &#x3D; \sum_r p(r|s,a)r + \sum_{s^\prime}p(s^\prime|s,a)v_{\pi_k}(s^\prime)<br>$$<br>​However, the above equation needs the model of the environment (that  $p(r|s,a)$ and $p(s^\prime|s,a)$ are required). We can replace this part by Monte Carlo estimation. Recall the definition of action value refer to section 2.5.<br>$$<br>q_\pi(s,a) \triangleq \mathbb{E}[G_t|S_t&#x3D;s, A_t&#x3D;a]<br>$$<br>Action value can be interpreted as <font color=blue>average return</font> along trajectory generated by <font color=blue>policy $\pi$ </font> after taking a <font color=blue>specific action $a$</font>.</p><p><strong>Convert to model free</strong>:</p><p>​Suppose there are $n$ episodes sampling starting at state $s$ and takeing action $a$,  and then denote the $i$ th episode return as $\textcolor{blue}{g^{(i)}(s,a)}$. Then using the idea of Monte Carlo estimation and Law of Large Numbers, the action values can be approxiamte as<br>$$<br>q_\pi(s,a) \triangleq \mathbb{E}[G_t|S_t&#x3D;s, A_t&#x3D;a] \textcolor{blue}{\approx \frac{1}{n} \sum_{j&#x3D;1}^n g^{(j)}(s,a)}<br>$$<br>Suppose the number of episodes $n$ is sufficiently large. So, the above equation is the unbiased estimation of action value $q_\pi(s,a)$.</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658bfa94c458853aef6a9405.png" class="" width="800" height="400" title="state-transform"><p>​Here are some questions.  <font color=red>Why does the MC Basic algorithm estimate action values instead of state values?</font> That is because state value cannot be used to improve policies directly. Even if we are given state values, we still need to calculate action values from these state value using $q_{\pi_k}(s,a) &#x3D; \sum_r p(r|s,a)r + \sum_{s^\prime}p(s^\prime|s,a)v_{\pi_k}(s^\prime)$. But this calculation requires the system model. Therefore, when models are not available, we should directly estimate action values.</p><h3 id="5-4-Monte-Carlo-Exploring-Starts"><a href="#5-4-Monte-Carlo-Exploring-Starts" class="headerlink" title="5.4 Monte Carlo Exploring Starts"></a>5.4 Monte Carlo Exploring Starts</h3><p><strong>Some concepts</strong>:</p><ul><li><p><font color=blue>Vist</font>: a state-action pair appears in the episode, it is called a <em>vist</em> of the state-action pair. Such as<br>$$<br>\textcolor{blue}{s_1 \xrightarrow{a_2}} s_2 \xrightarrow{a_4} \textcolor{blue}{s_1 \xrightarrow{a_2}} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots<br>$$<br>$(s_1,a_2)$ is called a visit.</p></li><li><p><font color=blue>First visit</font>: In the above trajectory $(s_1,a_2)$ is visited twice. If we only count the first-time visit, such kind of strategy is called <em>first-visit</em>.</p></li><li><p><font color=blue>Every visit</font>: If every time state-action pair is visited and the rest of the episode is used to estimate its action value, such a strategy is called <em>every-visit</em>.</p></li></ul><p>​For example,</p><p>$$<br>\begin{aligned}<br>    s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_4} s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\textcolor{blue}{\text{origianl episode}}]\<br>    s_2 \xrightarrow{a_4} s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\text{episode starting from }(s_2,a_4)]\<br>    s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\textcolor{red}{\text{episode starting from }(s_1,a_2)}]\<br>    s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\text{episode starting from }(s_2,a_3)]\<br>    s_5 \xrightarrow{a_13}\cdots &amp; \quad [\text{episode starting from }(s_2,a_4)]<br>\end{aligned}<br>$$</p><p>Suppose we need to estimate the action value $q_\pi(s_1,a_2)$. The <em>first-visit</em> only counts the first visit of $(s_1,a_2)$. So we need a huge numbers of episodes starting from $(s_1,a_2)$. As the blue one episode in the above equations. The <em>every-visi</em>t counts every time the visit of $(s_1,a_2)$. Hence, we can use the blue one and the red one to estimate the action value $q_\pi(s_1,a_2)$. In this way, the samples in the episode are utilized more sufficiently.</p><p><strong>Using sample more efficiently</strong>:</p><p>​From the example, we are informed that <font color=blue>if an episode is sufficiently long so that it can visit all the state-action pairs many times, then this single episode is sufficient to estimate all the action values by using the every-visit strategy</font>. However, one single episode is pretty ideal result. Because the samples obtained by the <em>every-visit</em> is relevant due to the trajectory starting from the second visit is merely a subset of the trajectory starting from the first. Nevertheless, if the two visits are far away from each other, which means there is a siginificant non-overlap portion, the relevance would not be strong. Moreover, the relevance can be further suppressed due to the discount rate. <font color=blue>Therefore, when there are few episodes and each episode is very long, the every-visit strategy is a good option</font>.</p><p><strong>Using estimation more efficiently</strong>:</p><p>​The first startegy in MC Basic, in the policy evaluation step, to collect all the episodes starting from the same state-action pair and then approximate the action value using the average return of these episodes. The drawback of the strategy is that the agent must wait until all episodes have been collected.</p><p>​The second strategy, which can overcome the drawback, is to <font color=blue>use the return of a single episode to approximate the corresponding action value</font> (the idea of stochastic estimation). In this way, we can improve the policy in an <font color=blue>episode-by-episode</font> fasion.</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658bfac5c458853aef6b25fb.png" class="" width="800" height="500" title="state-transform"><p><font color=blue>MC Exploring Starts algorithm compared to MC Basic, the sample usage and estimation update are more efficient</font>.</p><h3 id="5-5-Monte-Carlo-epsilon-Greedy"><a href="#5-5-Monte-Carlo-epsilon-Greedy" class="headerlink" title="5.5 Monte Carlo $\epsilon$-Greedy"></a>5.5 Monte Carlo $\epsilon$-Greedy</h3><p>​Why is exploring starts important? In theory, exploring starts is necessary to find optimal policies. Only if every state-action pair is well explored, can we select optimal policies. However, in practice, exploring starts is difficult to achieve. Because its difficult to collect episodes starting from every state-action pair.</p><p>​We can use <em>soft policy</em> to remove the requirement of exploring starts. There are many soft policies. The most common one is $\textcolor{blue}{\epsilon}$<font color=blue>-greedy</font>. The $\epsilon$-greedy has the form of<br>$$<br>\pi(a|s) &#x3D;<br>\left {<br>    \begin{aligned}<br>    1 - \frac{\epsilon}{|\mathcal{A}(s)|}(|\mathcal{A(s)}|-1), &amp; \quad \text{for the geedy action}\<br>    \frac{\epsilon}{|\mathcal{A}(s)|}, &amp; \quad \text{for the other } |\mathcal{A}(s)|-1 \text{ actions}<br>    \end{aligned}<br>\right.<br>$$<br>where $|\mathcal{A}(s) |$ denotes the number of actions associated with $s$. It is worth noting taht the probability to take the greedy action is always greater than other action, because<br>$$<br>1 - \frac{\epsilon}{|\mathcal{A}(s)|}(|\mathcal{A(s)}|-1) &#x3D;<br>1 - \epsilon + \frac{\epsilon}{|\mathcal{A}(s)|} \ge<br>\frac{\epsilon}{|\mathcal{A}(s)|}<br>$$<br>for any $\epsilon\in[0,1]$, when $\epsilon&#x3D;0$ the $\epsilon$-greedy becomes greedy policy.</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658bfae1c458853aef6b7740.png" class="" width="800" height="500" title="state-transform"><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 4. Value Iteration and Policy Iteration]</title>
      <link href="/2023/07/23/Reinforcement-Learning-with-Code-Chapter-4-Value-Iteration-and-Policy-Iteration/"/>
      <url>/2023/07/23/Reinforcement-Learning-with-Code-Chapter-4-Value-Iteration-and-Policy-Iteration/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code"></a>Reinforcement Learning with Code</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-4-Value-Iteration-and-Policy-Iteration"><a href="#Chapter-4-Value-Iteration-and-Policy-Iteration" class="headerlink" title="Chapter 4. Value Iteration and Policy Iteration"></a>Chapter 4. Value Iteration and Policy Iteration</h2><p>​Value iteration and policy iteration have a common name called <font color=blue>dynamic programming</font>. Dynamic programming is model-based algorithm, which is the simplest RL algorithm. Its helpful to us to understand the model-free algorithm.</p><h3 id="4-1-Value-iteration"><a href="#4-1-Value-iteration" class="headerlink" title="4.1 Value iteration"></a>4.1 Value iteration</h3><p>​Value iteration is solving the Bellman optimal equation directly.</p><p><strong>Matrix-vector form</strong>:</p><p>​The <font color=red>value iteration</font> is exactly the algorithm suggested by the contraction mapping in chapter 3. Value iteration concludes two parts. First, in every iteration is called <em>policy update</em>. </p><p>$$<br>\pi_{k+1} &#x3D; \arg \textcolor{red}{\max_{\pi_k}(r_{\pi_k} + \gamma P_\pi v_k)}<br>$$<br>Second, the step is <em>value update</em>. Mathematically, it is to substitute $\pi_{k+1}$ and do the following operation:</p><p>$$<br>v_{k+1} &#x3D; r_{\pi_{k+1}} + \gamma P_{\pi_{k+1}}v_k<br>$$</p><p>The above algorithm is matrix-vector form which is useful to understand the core idea. <font color=red>The above equation is iterative which means we calculate</font> $v_{k+1}$ <font color=red>is only one step calculation</font>.</p><p>There is a <font color=red>misunderstanding</font> that we doesn’t use Bellman equation to calculate state value $v_{k+1}$ directly. Instead, when we use greedy policy update strategy the state value $v_{k+1}$ is actually the maximum action value $\max_a q_k(s,a)$.</p><p>The value iteration includes solving the Bellman optimal equation part as show in red.</p><p><strong>Elementwise form</strong>:</p><p>​First, the elementwise form <em>policy update</em> is </p><p>$$<br>\begin{aligned}<br>\pi_{k+1} &amp; &#x3D; \arg \max_{\pi_k}(r_{\pi_k} + \gamma P_\pi v_k)\quad \text{(matrx-vector form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k} \sum_a \pi_k(a|s)<br>\Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_k(s^\prime)\Big) \quad \text{(elementwise  form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k} \sum_a \pi_k(a|s) q_{\pi_k}(s,a)\newline<br>\to \pi_{k+1}(s) &amp; &#x3D;  \sum_a \pi_k(a|s) \arg \max_{a_k}q_{\pi_k}(s,a)<br>\end{aligned}<br>$$</p><p>Then use the greedy policy update algorithm, when $a&#x3D;a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 1$, when $a\ne a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 0$, where $a_k^*(s) &#x3D; \arg\max_a q_k(a,s)$.</p><p>​Second, the elementwise form <em>value update</em> is </p><p>$$<br>\begin{aligned}<br>    v_{k+1} &amp; &#x3D; r_{\pi_{k+1}} + \gamma P_{\pi_{k+1}}v_k\quad \text{(matrx-vector form)}\newline<br>    \to v_{k+1}(s) &amp; &#x3D; \sum_a \pi_{k+1}(a|s)<br>    \underbrace{<br>    \Big(\sum_r p(r|s,a)r+ \gamma \sum_{s^\prime}p(s^\prime|s,a)v_k(s^\prime) \Big)}_{q_k(s,a)}\quad \text{(elementwise  form)}<br>\end{aligned}<br>$$</p><p><font color=blue>Since $\pi_{k+1}$ is a greedy policy, the above equation is simply</font></p><p>$$<br>v_{k+1}(s) &#x3D; \max_a q_k(s,a)<br>$$</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658be0b6c458853aef1b95ef.png" class="" width="800" height="400" title="state-transform"><h3 id="4-2-Policy-iteration"><a href="#4-2-Policy-iteration" class="headerlink" title="4.2 Policy iteration"></a>4.2 Policy iteration</h3><p>​The <font color=red>policy iteration</font> is not an algorithm directly solving the Bellman optimality equation. However, it has an intimate relationship to value iteration. The policy iteration includes two parts <font color=blue>policy evaluation</font> and <font color=blue>policy improvement</font>.</p><p><strong>Policy evaluation</strong>:</p><p>​The first step is policy evaluation. Mathematically, it is to sovle Bellman equation of $\pi_k$:</p><p>$$<br>v_{\pi_k} &#x3D; r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k}<br>$$</p><p>This is the matrix-vector form of the Bellman equation, where $r_{\pi_k}$ and $P_{\pi_k}$ are known. Here, $v_{\pi_k}$ is the state value to be solved.</p><p><font color=blue>How to calculate state value</font> $v_{\pi_k}$ is important. In section 2.4 we have already introduced how to solve Bellman equation to get state value $v_{\pi_k}$ as following</p><p>$$<br>\textcolor{blue}{v_{\pi_k}^{(j+1)} &#x3D; r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k}^{(j)}}, \quad j&#x3D;0,1,2,\dots<br>$$</p><p><font color=red>Its clear that policy iteration is directly calculate the state value using the above equation, which means the calculation is infity step calculation</font>.</p><p><strong>Policy improvement</strong>:</p><p>​The second step is to imporve the policy. How to do that? Once $v_{\pi_k}$ is calculated in the first step, a new and improved policy could be obtained as </p><p>$$<br>\pi_{k+1} &#x3D; \arg \max_\pi (r_\pi + \gamma P_\pi v_{\pi_k})<br>$$</p><p> <strong>Elementwise form</strong>:</p><p>​The policy evaluation step is to solve $v_{\pi_k}$ from the Bellman equation dirctly.</p><p>$$<br>\begin{aligned}<br>    v_{\pi_k}^{(j+1)} &amp; &#x3D; r_{\pi_k} + \gamma P_{\pi_k} v_{\pi_k}^{(j)}\quad \text{(matrix-vector form)} \newline<br>    \to v_{\pi_k}^{(j+1)}(s) &amp; &#x3D; \sum_a \pi_k(a|s) \Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k}^{(j)} (s^\prime)\Big) \quad \text{(elementwise form)}<br>\end{aligned}<br>$$<br>where $j&#x3D;0,1,2,\dots$</p><p>The policy improvement step is to solve $\pi_{k+1}&#x3D;\arg \max_\pi (r_\pi + \gamma P_{\pi_k}v_{\pi_k})$.</p><p>$$<br>\begin{aligned}<br>\pi_{k+1} &amp; &#x3D;\arg \max_{\pi_k} (r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k})\quad \text{(matrix-vector form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k}  \sum_a \pi(a|s)<br>\Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k} (s^\prime)\Big)<br>\quad \text{(elementwise form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D;  \sum_a \pi(a|s) \arg \max_a q_{\pi_k}(s,a)<br>\end{aligned}<br>$$</p><p>Let $a^*<em>k(s) &#x3D; \text{arg} \max_a q</em>{\pi_k}(s,a)$. The greedy optimal policy is when $a&#x3D;a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 1$, when $a\ne a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 0$, where $a_k^*(s) &#x3D; \arg\max_a q_k(a,s)$.</p><p><strong>Pesudocode:</strong></p><img src="https://pic.imgdb.cn/item/658be0dfc458853aef1c2798.png" class="" width="800" height="400" title="state-transform"><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 3. Optimal State Value and Bellman Optimal Equation]</title>
      <link href="/2023/07/23/Reinforcement-Learning-with-Code-Chapter-3-Optimal-State-Value-and-Bellman-Optimal-Equation/"/>
      <url>/2023/07/23/Reinforcement-Learning-with-Code-Chapter-3-Optimal-State-Value-and-Bellman-Optimal-Equation/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code."></a>Reinforcement Learning with Code.</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-3-Optimal-State-Value-and-Bellman-Optimality-Equation"><a href="#Chapter-3-Optimal-State-Value-and-Bellman-Optimality-Equation" class="headerlink" title="Chapter 3. Optimal State Value and Bellman Optimality Equation"></a>Chapter 3. Optimal State Value and Bellman Optimality Equation</h2><h3 id="3-1-How-to-define-optimal"><a href="#3-1-How-to-define-optimal" class="headerlink" title="3.1 How to define optimal"></a>3.1 How to define optimal</h3><p>​One core idea is that we use the action value to judge the optimality of the action. If we update the policy to select the action with the <em>greatest action value</em>, we could find a better policy.</p><p>​(<font color=blue>Optimal policy and optimal state value</font>). <em>A policy</em> $\pi^*$ <em>is optimal if</em> $v_{\pi^*}(s) \ge v_\pi(s)$ <em>for all</em> $s\in\mathcal{S}$ <em>and for any other policy</em> $\pi$. <em>The state values of</em>  $\pi^*$ <em>are the optimal state values</em>.</p><p><font color=blue>Why does the definition works? One intuitive explanation is that state value $v_\pi(s)$ denote the mean of return along the trajectory following policy $\pi$. If the policy $\pi^*$ has greatest expectation of return, hence we can believe that the policy $\pi^*$ is optimal.</font></p><h3 id="3-2-Bellman-optimal-equation-BOE"><a href="#3-2-Bellman-optimal-equation-BOE" class="headerlink" title="3.2 Bellman optimal equation (BOE)"></a>3.2 Bellman optimal equation (BOE)</h3><p>​The Bellamn optimal eqaution (BOE) is </p><p>$$<br>\begin{aligned}<br>v(s) &amp; &#x3D; \max_\pi \sum_a \pi(a|s) \Big[ \sum_r p(r|s,a)r + \gamma \sum_{s^\prime} p(s^{\prime}|s,a) v_\pi(s^{\prime}) \Big] \newline<br>\textcolor{red}{v(s)} &amp; \textcolor{red}{&#x3D; \max_\pi \sum_a \pi(a|s) q_\pi(s,a)}<br>\end{aligned}<br>$$</p><p>There is a problem that the BOE has two unknown variables $q_\pi(s,a)$ and $\pi(a|s)$. How can we solve the BOE?</p><p>​The idea is that we can <font color=blue>fix one variable</font> and solve the maximization problem. For Bellman optimal equation, we can <font color=blue>fix variable $\pi(a|s)$ for all $a\in\mathcal{A}(s)$</font> and then by maximize the state value to find the optimal policy $\pi$.</p><p>​Before analysis, we consider one example first. Suppose $x_1,x_2,x_3\in\mathbb{R}$ are given. Find $c_1^*,c_2^*,c_3^*$ solving<br>$$<br>\max_{c_1,c_2,c_3} c_1x_1+c_2x_2+c_3x_3\newline<br>\text{subject to } c_1+c_2+c_3&#x3D;1<br>$$<br>Without generality, suppose $x_3 \ge x_1, x_2$. Then, the optimal solution is $c_3^*&#x3D;1$ and $c_1^*&#x3D;c_2^*&#x3D;0$. This is because for any $c_1,c_2,c_3$<br>$$<br>x_3 &#x3D; (c_1+c_2+c_3)x_3 &#x3D; c_1x_3 + c_2x_3 + c_3x_3 \ge c_1x_1 +c_2x_2+c_3x_3<br>$$<br>​Hence, inspired by the above example, considering that $\sum_a \pi(a|s)&#x3D;1$, we have</p><p>$$<br>\begin{aligned}<br>v(s) &amp; &#x3D; \max_\pi \sum_a \pi(a|s) q_\pi(s,a) \newline<br>&amp; &#x3D; \sum_a \pi(a|s) \max_\pi q_\pi(s,a) \quad \text{by fix } \pi(a|s) \newline<br>&amp; &#x3D; \sum_a \pi(a|s) \max_{a\in\mathcal{A}} q_\pi(s,a) \newline<br>&amp; \le \max_{a\in\mathcal{A}} q_\pi(s,a)<br>\end{aligned}<br>$$</p><p>where the equality is achieved when $a&#x3D;a^*$, $\pi(a|s)&#x3D;1$ when $a\ne a^*$, $\pi(a|s)&#x3D;0$.</p><p>$$<br>a^* &#x3D; \text{arg} \max_a q(s,a)<br>$$</p><p>This policy is often called <font color=blue>greedy policy</font>.</p><h3 id="3-3-Matrix-vector-form-of-Bellman-optimal-equation"><a href="#3-3-Matrix-vector-form-of-Bellman-optimal-equation" class="headerlink" title="3.3 Matrix-vector form of Bellman optimal equation"></a>3.3 Matrix-vector form of Bellman optimal equation</h3><p>Refering to matrix-vector form of Bellman equation, it’s obvious to get matrix-vector form of Bellman optimal equation as follows<br>$$<br>\textcolor{blue} {v &#x3D; \max_\pi (r_\pi +\gamma P_\pi v)}<br>$$<br>where $v\in\mathbb{R^{|\mathcal{S}|}}$. The structure of $r_\pi$ and $P_\pi$ are the same as those in the matrix-vector form of Bellman equation:</p><p>$$<br>[r_\pi]_s \triangleq \sum_a \pi(a|s) \sum_r p(r|s,a)r<br>$$</p><p>$$<br>[P_\pi]<em>{s, s^\prime} &#x3D; \sum_a \pi(a|s) \sum</em>{s^\prime} p(s^\prime|s,a)<br>$$</p><p>Furthermore, denote the right hand side as </p><p>$$<br>f(v) \triangleq \max_\pi(r_\pi + \gamma P_\pi v)<br>$$</p><p>Hence, we have the Bellman optimal equation as</p><p>$$<br>v&#x3D;f(v) \newline<br>f(v) - v &#x3D; 0<br>$$</p><p><font color=blue>It turns solving Bellman optimal equation to solving find the root of function</font> $\textcolor{blue}{f(v) - v &#x3D;0}$.</p><h3 id="3-4-Contraction-mapping-theorem"><a href="#3-4-Contraction-mapping-theorem" class="headerlink" title="3.4 Contraction mapping theorem"></a>3.4 Contraction mapping theorem</h3><p>​<font color=red>Fixed point</font>: consider a function $f(x)$ where $x\in\mathbb{R}^b$ and $f:\mathbb{R}^b\to\mathbb{R}^b$. A point $x^*$ is called a fixed point if<br>$$<br>f(x^*) &#x3D; x^*<br>$$<br>The function $f$ is called a <font color=red>contracting mapping</font> if there <font color=blue>exists</font> $\gamma\in(0,1)$ such that<br>$$<br>||f(x_1)-f(x_2)|| \le \gamma ||x_1 - x_2||<br>$$<br>for any $x_1, x_2\in \mathbb{R}$.</p><p>​(<font color=red>Contraction mapping theorem</font>) For any equation that has the form of $x&#x3D;f(x)$ where $x$ and $f(x)$ are real vectors, if $f$ is a contraction mapping, then</p><ul><li><p>Existence: There exists a fixed point $x^*$ satisfying $f(x^*)&#x3D;x^*$.</p></li><li><p>Uniqueness: The fixed point $x^*$ is unique.</p></li><li><p>Algorithm: Consider the iterative process:<br>$$<br>x_{k+1} &#x3D; f(x_k)<br>$$<br>where $k&#x3D;0,1,2,\dots$. Then , $x_k\to x^*$ as $k\to \infty$ for any initial guess $x_0$. Moreover, the convergence rate is exponentially fast.</p></li></ul><h3 id="3-5-Solution-of-BOE"><a href="#3-5-Solution-of-BOE" class="headerlink" title="3.5 Solution of BOE"></a>3.5 Solution of BOE</h3><p>​(Contraction property of BOE). The function $f(v) \triangleq \max_\pi(r_\pi + \gamma P_\pi v)$ in the BOE is a contraction mapping statisfying<br>$$<br>||f(v_1)-f(v_2)|| \le \gamma ||v_1 - v_2||<br>$$<br>where $v_1,v_2\in\mathbb{R}^{|\mathcal{S}|}$ are any two vectors and $\gamma\in(0,1)$ is the discounted rate.</p><p>The proof is omitted.</p><p>​Using contraction mapping theorem to solve BOE, we have the following theorem:</p><p>​(<font color=red>Existence, Uniqueness, Algorithm</font>). <em>For the BOE</em> $v&#x3D;f(v) \triangleq \max_\pi(r_\pi + \gamma P_\pi v)$, <em>there always exists a unique solution</em> $v^*$, <em>which can be solved iteratively by</em><br>$$<br>v_{k+1} &#x3D; f(v_k) &#x3D; \max_\pi(r_\pi + \gamma P_\pi v_k), \quad k&#x3D;0,1,\dots<br>$$<br><em>The sequence</em> ${v(k)}$ <em>converges to optimal solution of BOE</em> $v^*$ <em>exponentially fast given any inital guess</em> $v_0$.</p><p>This algorithm is actually called <font  color=blue>value iteration</font>. </p><p>​<font color=blue>First</font>, following the algorithm above will give us the optimal state value $v^*$. <font color=blue>Second</font>, we solve the unknown policy $\pi$ in the BOE. Suppose $v^*$ has been obtained and<br>$$<br>\pi^* &#x3D; \text{arg}\max_\pi(r_\pi+\gamma P_\pi v^*)<br>$$<br>Then, $v^*$ and $\pi^*$ statisfy<br>$$<br>v^* &#x3D; r_{\pi^*} + \gamma P_{\pi^*} v^*<br>$$<br>​(<font color=blue>Greedy optimal policy</font>). <em>For any</em> $s\in\mathcal{S}$, <em>the deterministic greedy policy</em> </p><p>where the equality is achieved when $a&#x3D;a^*$, $\pi(a|s)&#x3D;1$ when $a\ne a^*$, $\pi(a|s)&#x3D;0$.</p><p><em>is an optimal policy solving the BOE. Here</em><br>$$<br>a^*(s) &#x3D; \text{arg} \max_a q^*(a,s)<br>$$<br><em>where</em><br>$$<br>q^*(s,a) \triangleq \sum_r p(r|s,a)r + \gamma \sum_{s^\prime} p(s^{\prime}|s,a) v^*(s)<br>$$<br>​The matrix-vecotr form of the optimal policy is $\pi^*&#x3D;\text{arg}\max_\pi(r_\pi+\gamma P_\pi v^*(s))$. Its <font color=blue>elementwise form</font> is</p><p>$$<br>\begin{aligned}<br> \pi^* &amp; &#x3D; \text{arg}\max_\pi(r_\pi+\gamma P_\pi v^*)\newline<br> \to \pi^*(s) &amp; &#x3D; \text{arg}\max_\pi \sum_a \pi(a|s) \Big( \sum_r p(r|s,a)r + \gamma \sum_{s^\prime} p(s^{\prime}|s,a) v^*(s)\Big)\newline<br> \to \pi^*(s) &amp; &#x3D; \text{arg}\max_\pi \sum_a \pi(a|s) q^*(s,a),\quad \text{for s}\in\mathcal{S}<br>\end{aligned}<br>$$</p><p>It is clear that $\sum_a \pi(a|s)q^*(s,a)$ is maximized if $\pi(s)$ selects the action with the greatest value of $q^*(s,a)$.</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 2. State Value and Bellman Equation]</title>
      <link href="/2023/07/21/Reinforcement-Learning-with-Code-Chapter-2-State-Value-and-Bellman-Equation/"/>
      <url>/2023/07/21/Reinforcement-Learning-with-Code-Chapter-2-State-Value-and-Bellman-Equation/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code."></a>Reinforcement Learning with Code.</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-2-State-Value-and-Bellman-Equation"><a href="#Chapter-2-State-Value-and-Bellman-Equation" class="headerlink" title="Chapter 2. State Value and Bellman Equation"></a>Chapter 2. State Value and Bellman Equation</h2><h3 id="2-1-State-value"><a href="#2-1-State-value" class="headerlink" title="2.1 State value"></a>2.1 State value</h3><ul><li><p><font color=red>State value</font> is defined as the mean of <font color=blue>all possible returns</font> starting from a state, which is actually the <font color=blue>expectation of return</font> from a specific state.</p></li><li><p>The mathematical definition is as follows:</p><p>Note that the capital letters denote <em>random variables</em>, such as $S_t, S_{t+1}, A_t, R_{t+1}$. In particular, $S_t,S_{t+1}\in\mathcal{S},A_t\in\mathcal{A}(S_t)$ and $R_{t+1}\in\mathcal{R}(S_t,A_t)$. $G_t$ denote the random variable of return.</p><p>Starting from $t$, we can obtain a state-action-reward trajectory:</p><p>$$<br>S_t \xrightarrow{A_t} S_{t+1},R_{t+1} \xrightarrow{A_{t+1}} S_{t+2},R_{t+2} \xrightarrow{A_{t+2}} S_{t+3},R_{t+3} \cdots<br>$$</p><p>The discounted return along the trajectory is </p><p>$$<br>G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma R_{t+3} + \cdots<br>$$</p><p>The state value is defined as:</p><p>$$<br>\textcolor{blue}{v_\pi(s)\triangleq \mathbb{E}[G_t|S_t&#x3D;s]}<br>$$</p><p>which means <font color=blue>start from state</font> $s$ can get the <font color=blue>expectation return</font> along the trajecotry generated by <font color=blue>policy $\pi$ </font>. </p><p>$v_\pi(s)$ is also called <font color=blue>state-value funtion</font>.</p></li></ul><h3 id="2-2-Bellman-Equation"><a href="#2-2-Bellman-Equation" class="headerlink" title="2.2 Bellman Equation"></a>2.2 Bellman Equation</h3><ul><li><p>Bellman equation is a set of linear equations <font color=blue>describing the relationship among the values of all the states</font>.</p><p>For example,</p></li></ul><img src="https://pic.imgdb.cn/item/658bd598c458853aeff51217.png" class="" width="400" height="400" title="state-transform"><p>  Let $v_i$ denote the return obtained starting from $s_i$. The return starting from the four states in figure can be respectively calculated as </p><p>$$<br>v_1 &#x3D; r_1 + \gamma r_2 + \gamma^2 r_3 + \cdots \newline<br>v_2 &#x3D; r_2 + \gamma r_3 + \gamma^2 r_4 + \cdots \newline<br>v_3 &#x3D; r_3 + \gamma r_4 + \gamma^2 r_1 + \cdots \newline<br>v_4 &#x3D; r_4 + \gamma r_1 + \gamma^2 r_2 + \cdots<br>$$</p><p> Using the idea of <em>bootstrapping</em>, we can rewrite it to</p><p>$$<br>v_1 &#x3D; r_1 + \gamma (r_2 + \gamma r_3) + \cdots &#x3D; r_1 + \gamma v_2 \newline<br>v_2 &#x3D; r_2 + \gamma (r_3 + \gamma r_4) + \cdots &#x3D; r_2 + \gamma v_3 \newline<br>v_3 &#x3D; r_3 + \gamma (r_4 + \gamma r_1) + \cdots &#x3D; r_3 + \gamma v_4 \newline<br>v_4 &#x3D; r_4 + \gamma (r_1 + \gamma r_2) + \cdots &#x3D; r_4 + \gamma v_1<br>$$</p><p>  Then rewrite it into matrix form</p><p>$$<br>\textbf{v} &#x3D;  \begin{bmatrix} v_1 \newline v_2 \newline v_3 \newline v_4 \end{bmatrix} , \textbf{r} &#x3D; \begin{bmatrix} r_1 \newline r_2 \newline r_3 \newline r_4 \end{bmatrix}, \textbf{v} &#x3D;  \begin{bmatrix} v_1 \newline v_2 \newline v_3 \newline v_4 \end{bmatrix}<br>$$</p><p>$$<br>\textbf{P} &#x3D;  \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \newline 0 &amp; 0 &amp; 1 &amp; 0 \newline 0 &amp; 0 &amp; 0 &amp; 1 \newline 1 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}<br>$$</p><p> The equation $\textbf{v}&#x3D;\textbf{r}+\gamma\textbf{P}\textbf{v}$ is called Bellman equation.</p><ul><li>Then we can derive Bellman equation from scratch as follows:</li></ul><p>Note that the discounted return random variable $G_t$ can be rewritten as </p><p>$$<br>\begin{aligned}<br>G_t &amp; &#x3D;  R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \cdots\newline<br>&amp; &#x3D;  R_{t+1} + \gamma(R_{t+2}+\gamma R_{t+3} + \cdots) \newline<br>&amp; &#x3D;  R_{t+1} + \gamma G_{t+1}<br>\end{aligned}<br>$$</p><p> where $G_{t+1} &#x3D; R_{t+2} + \gamma R_{t+3} + \cdots$ . This equation establishes the relationship between $G_t$ and $G_{t+1}$. Then the state value can be rewritten as </p><p>$$<br>\begin{aligned}<br>v_\pi(s) &amp; &#x3D;  \mathbb{E}[G_t|S_t&#x3D;s] \newline<br>&amp; &#x3D;  \mathbb{E}[R_{t+1} + \gamma G_{t+1} | S_t&#x3D;s] \newline<br>&amp; &#x3D;  \mathbb{E}[R_{t+1}|S_t&#x3D;s] + \gamma \mathbb{E}[G_{t+1}|S_t&#x3D;s]<br>\quad \text{(linear property of expectation)}<br>\end{aligned}<br>$$</p><p> The <font color = blue> mean of immediate reward</font> can be written as (use 2.3 conditional expectation)</p><p>$$<br>\begin{aligned}<br>\mathbb{E}[R_{t+1}|S_t&#x3D;s] &amp; &#x3D;  \sum_a \pi(a|s) \mathbb{E}[R_{t+1} | S_t&#x3D;s,A_t&#x3D;a] \quad \text{(conditional expectation)}\newline<br>&amp; &#x3D;  \sum_a \pi(a|s) \sum_r p(r|s,a)r<br>\end{aligned}<br>$$</p><p>  The <font color = blue>mean of future reward</font> can be written as </p><p>$$<br>\begin{aligned}<br>\gamma \mathbb{E}[G_{t+1}|S_t&#x3D;s] &amp; &#x3D;  \gamma \sum_a \pi(a|s) \mathbb{E}[G_{t+1}|S_t&#x3D;s, A_t&#x3D;a]\quad \text{(conditional expectation)}\newline<br>&amp; &#x3D;  \gamma \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\newline<br>\end{aligned}<br>$$</p><p>Then the state value can be rewritten as <font color=red>Bellman equation (BE)</font> form </p><p>$$<br>\begin{aligned}<br>v_\pi(s) &amp; &#x3D;  \mathbb{E}[G_t|S_t&#x3D;s] \newline<br>&amp; &#x3D;  \mathbb{E}[R_{t+1}|S_t&#x3D;s] + \gamma \mathbb{E}[G_{t+1}|S_t&#x3D;s] \newline<br>&amp; &#x3D;<br>\sum_a \pi(a|s) \sum_r p(r|s,a)r </p><p>+<br>\gamma \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\newline<br>&amp; &#x3D;  \sum_a \pi(a|s) \Big[\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\Big], \quad \text{for all } s\in\mathcal{S}<br>\end{aligned}<br>$$</p><p>Next, we will introduce the matrix vector form of Bellman equation in terms of state value. Let $v_\pi&#x3D;[v_\pi(s_1),v_\pi(s_2),\cdots]^T\in\mathbb{R}^n$, $r_\pi&#x3D;[r_\pi(s_1),r_\pi(s_2),\cdots]^T\in\mathbb{R}^n$, and $P_\pi\in\mathbb{R}^{n\times n}$. Then we have the matrix-vector form of Bellman equation in terms of state value.</p><p>$$<br>\textcolor{red}{v_\pi &#x3D; r + \gamma P_\pi v_\pi} \quad \text{(matrix-vector form)}<br>$$</p><p>where</p><p>$$<br>[r_\pi]<em>s \triangleq \sum_a \pi(a|s) \sum_r p(r|s,a)r,<br>[P_\pi]</em>{s,s^\prime} &#x3D; \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a)<br>$$</p><h3 id="2-3-Review-conditional-expectaion"><a href="#2-3-Review-conditional-expectaion" class="headerlink" title="2.3 Review conditional expectaion"></a>2.3 Review conditional expectaion</h3><ul><li>The definition of conditional expectation is</li></ul><p>$$<br>\mathbb{E} &#x3D; [X|A&#x3D;a] &#x3D; \sum_{x}xp(x|a)<br>$$</p><p>  Similar to the law of total probability, we have the law of total expectation:</p><p>$$<br>\mathbb{E}[X] &#x3D; \sum_a p(a) \mathbb{E}[X|A&#x3D;a]<br>$$</p><p>  <em>Proof</em></p><p>  By definition of expectation the right hand side can be written as </p><p>$$<br>\begin{aligned}<br>\mathbb{E}[X] &amp; &#x3D;  \sum_a p(a) \sum_x x p(x|a)\newline<br>&amp; &#x3D;  \sum_x \sum_a p(x|a) p(a)  \quad \text{(law of total probability)}\newline<br>&amp; &#x3D;  \sum_x p(x)\newline<br>&amp; &#x3D;  \mathbb{E}[X]<br>\end{aligned}<br>$$</p><h3 id="2-4-Solve-Bellman-Equation"><a href="#2-4-Solve-Bellman-Equation" class="headerlink" title="2.4 Solve Bellman Equation"></a>2.4 Solve Bellman Equation</h3><p>​From the analysis above we are informed that Bellman equation is</p><p>$$<br>\textcolor{blue}{v_\pi(s)&#x3D;\sum_a \pi(a|s) \Big[\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\Big]}<br>$$</p><p>We can rewrite it into the follow form</p><p>$$<br>v_\pi(s) &#x3D; r_\pi(s) + \gamma \sum_{s^\prime} p_\pi(s^\prime|s) v_\pi(s^\prime)<br>$$</p><p>where</p><p>$$<br>\begin{aligned}<br>r_\pi(s) \triangleq \sum_a \pi(a|s) \sum_r p(r|s,a)r\newline<br>\newline<br>\newline<br>\newline<br>\end{aligned} \qquad<br>\begin{aligned}<br>p_\pi(s^\prime|s) &amp; \triangleq \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a)\newline<br>&amp; &#x3D; \sum_{s^\prime} \sum_a \pi(a|s) p(s^\prime|s,a)\newline<br>&amp; &#x3D; p_\pi(s^\prime|s)<br>\end{aligned}<br>$$</p><p>​Suppose the states are indexed as $s_i$. For state $s_i$, the Bellman equation is </p><p>$$<br>v_\pi(s_i) &#x3D; r_\pi(s_i) + \gamma \sum_{s_j} p_\pi(s_j|s_i) v_\pi(s_j)<br>$$</p><p>Let $v_\pi&#x3D;[v_\pi(s_1),\dots,v_\pi(s_n)]^T \in \mathbb{R}^n$, $r_\pi&#x3D;[r_\pi(s_1),\dots,r_\pi(s_n)]^T \in \mathbb{R}^n$, and $P_\pi \in \mathbb{R}^{n\times n}$, where $[P_\pi]_{ij} &#x3D; p_\pi(s_j|s_i)$. Hence we have the matrix form as </p><p>$$<br>v_\pi &#x3D; r_\pi + \gamma P_\pi v_\pi<br>$$</p><p>For example, consider four states $s_i$ and four actions $a_i$ the matrix form can be</p><p>$$<br>\underbrace{<br>\begin{bmatrix}<br>v_\pi(s_1) \newline<br>v_\pi(s_2) \newline<br>v_\pi(s_3) \newline<br>v_\pi(s_4)<br>\end{bmatrix}<br>}<em>{v_\pi} &#x3D;<br>\underbrace{<br>\begin{bmatrix}<br>r_\pi(s_1) \newline<br>r_\pi(s_1) \newline<br>r_\pi(s_1) \newline<br>r_\pi(s_1)<br>\end{bmatrix}<br>}</em>{r_\pi} + \gamma<br>\underbrace{<br>\begin{bmatrix}<br>p_\pi(s_1|s_1) &amp; p_\pi(s_2|s_1) &amp; p_\pi(s_3|s_1) &amp; p_\pi(s_4|s_1) \newline<br>p_\pi(s_1|s_2) &amp; p_\pi(s_2|s_2) &amp; p_\pi(s_3|s_2) &amp; p_\pi(s_4|s_2) \newline<br>p_\pi(s_1|s_3) &amp; p_\pi(s_2|s_3) &amp; p_\pi(s_3|s_3) &amp; p_\pi(s_4|s_3) \newline<br>p_\pi(s_1|s_4) &amp; p_\pi(s_2|s_4) &amp; p_\pi(s_3|s_4) &amp; p_\pi(s_4|s_4) \newline<br>\end{bmatrix}<br>}<em>{P_\pi}<br>\underbrace{<br>\begin{bmatrix}<br>v_\pi(s_1) \newline<br>v_\pi(s_2) \newline<br>v_\pi(s_3) \newline<br>v_\pi(s_4)<br>\end{bmatrix}<br>}</em>{v_\pi}<br>$$</p><p><strong>Conclusions</strong>:</p><ul><li>So we have the <font color=blue>closed form</font> of the solution as $v_\pi &#x3D; (I-\gamma P_\pi)^{-1}r_\pi$. However the inverse operation is hard to implement.</li><li>We seek for other iterative solving methods.</li></ul><p><strong>Iterative solution</strong></p><p>​We can directly sovle the Bellman equation using the following iterative algorithm:</p><p>$$<br>\textcolor{blue}{v_{k+1} &#x3D; r_\pi + \gamma P_\pi v_k}<br>$$</p><p>The proof is omitted.</p><h3 id="2-5-Action-value"><a href="#2-5-Action-value" class="headerlink" title="2.5 Action value"></a>2.5 Action value</h3><p>​<font color=red>Action value</font> is denoted by $q_\pi(s,a)$ which is defined as</p><p>$$<br>q_\pi(s,a) \triangleq \mathbb{E}[G_t|S_t&#x3D;s, A_t&#x3D;a]<br>$$</p><p>for all $s \in \mathcal{S}, a\in \mathcal{A}(s)$. </p><p>Action value can be interpreted as <font color=blue>average return</font> along trajectory generated by <font color=blue>policy $\pi$ </font> after taking a <font color=blue>specific action $a$</font>.</p><p>​From the conditional expectation property that</p><p>$$<br>\underbrace{\mathbb{E}[G_t|S_t&#x3D;s]}<em>{v_\pi(s)} &#x3D; \sum_a \pi(a|s) \underbrace{\mathbb{E}[G_t|S_t&#x3D;s,A_t&#x3D;a]}</em>{q_\pi(s)}<br>$$</p><p>Hence, </p><p>$$<br>v_\pi(s) &#x3D; \sum_a \pi(a|s) q_\pi(s)<br>$$</p><p>So we can obtain the mathematical definition of action value as</p><p>$$<br>\textcolor{blue}{q_\pi(s)&#x3D;\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)}<br>$$</p><p>Substituting $(1)$ into $(2)$ we have</p><p>$$<br>q_\pi(s,a)&#x3D;\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) \sum_{a^\prime \in \mathcal{A}(s^\prime)}\pi(a^\prime|s^\prime) q_\pi(s^\prime,a^\prime)<br>$$</p><p>​Suppose each state has the same number of actions. The matrix-vecotr form of Bellman eqaution in terms of action value is</p><p>$$<br>\textcolor{red}{q_\pi &#x3D; \tilde{r} + \gamma P \Pi q_\pi}\quad \text{(matrix-vector form)}<br>$$</p><p>where $q_\pi \in \mathbb{R}^{|\mathcal{S}||\mathcal{A}|}$ is the action value vector indexed by state-action pairs. In particular, the $(s,a)$th element is </p><p>$$<br>[q_\pi]_{(s,a)} &#x3D; q_\pi(s,a)<br>$$</p><p>Here, $\tilde{r}\in\mathbb{R}^{|\mathcal{S} ||\mathcal{A} |}$ is the immediate reward vector indexed by state-action pairs. In paricular, the $(s,a)$th reward is</p><p>$$<br>[\tilde{r}]_{(s,a)} &#x3D; \sum_r p(r|s,a)r<br>$$</p><p>Here, $P\in \mathbb{R}^{|\mathcal{S}||\mathcal{A}|\times|\mathcal{S}| }$ is the probability transition matrix, whose row is indexed by state-action pairs and column indexed by states. In particular</p><p>$$<br>[P]_{(s,a),s^\prime} &#x3D; p(s^\prime|s,a)<br>$$</p><p>And $\Pi \in\mathbb{R}^{|\mathcal{S}|\times|\mathcal{S}||\mathcal{A}|}$ describes the policy $\pi$. In particular</p><p>$$<br>\Pi_{s^\prime, (s^\prime,a^\prime)} &#x3D; \pi(a^\prime|s^\prime)<br>$$</p><p>and the other entries of $\Pi$ is zero. $\Pi$ is block diagonal matrix with each block as a $1\times|\mathcal{A}|$ vector.</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 1. Basic Concepts]</title>
      <link href="/2023/07/02/Reinforcement-Learning-with-Code-Chapter-1-Basic-Concepts/"/>
      <url>/2023/07/02/Reinforcement-Learning-with-Code-Chapter-1-Basic-Concepts/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code."></a>Reinforcement Learning with Code.</h1><p>This note record how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em> .</p><h2 id="Chapter-1-Basic-Concepts"><a href="#Chapter-1-Basic-Concepts" class="headerlink" title="Chapter 1. Basic Concepts"></a>Chapter 1. Basic Concepts</h2><h3 id="1-1-State-and-action"><a href="#1-1-State-and-action" class="headerlink" title="1.1 State and action"></a>1.1 State and action</h3><ul><li><font color=red><em>State</em> </font>describe the status of the agent with respect to the environment, denoted by $s$.</li><li><font color=red><em>State space</em> </font> is the set of all states, denoted by $\mathcal{S}&#x3D;{s_1, s_2,\dots,s_n}$.</li><li><font color = red><em>Action</em></font> describe the action that the agent may take with respect to the environment, denoted by $a$.</li><li><font color = red><em>Action space</em></font> is the set of all actions, denoted by $\mathcal{A}&#x3D;{a_1, a_2,\dots,a_n}.$</li></ul><h3 id="1-2-State-transition"><a href="#1-2-State-transition" class="headerlink" title="1.2 State transition"></a>1.2 State transition</h3><p>When taking an action, the agent may move from one state to another. Such a process is called <font color=red><em>state transition</em></font>. State trasition can be denoted by<br>$$<br>s_1 \stackrel{a_2}\longrightarrow s_2<br>$$<br>described by $p(s^\prime|s,a)$.</p><p>State trainsition can be both <em>deterministic</em> and <em>stochastic</em>. For example the deterministic state transition is<br>$$<br>p(s_1|s_1,a_2) &#x3D; 0 \<br>p(s_2|s_1,a_2) &#x3D; 1 \<br>p(s_3|s_1,a_2) &#x3D; 0<br>$$<br>For example the stochastic state transition is<br>$$<br>p(s_1|s_1,a_2) &#x3D; 0.5 \<br>p(s_2|s_1,a_2) &#x3D; 0.3 \<br>p(s_3|s_1,a_2) &#x3D; 0.2<br>$$</p><h3 id="1-3-Policy"><a href="#1-3-Policy" class="headerlink" title="1.3 Policy"></a>1.3 Policy</h3><ul><li><font color = red><em>Policy</em></font> tells the agents which actions to take <font color=blue>at each state</font>, denoted by $\pi$.</li><li>Policy is described by conditional probability.</li><li>Policy can be <em>deterministic</em> or <em>stochastic</em>, which means one state has a deterministic action or one state has probability to select other actions.</li></ul><p>Suppose the actions space is $\mathcal{A}&#x3D;{a_1, a_2,a_3}$, such  deterministic policy can be dentoed by<br>$$<br>\pi(a_1|s_1) &#x3D; 0 \<br>\pi(a_2|s_1) &#x3D; 1 \<br>\pi(a_3|s_1) &#x3D; 0<br>$$<br>which indicated the probability of taking action $a_2$ is $1$ and others are zero. </p><p>Such stochastic policy can be denoted by<br>$$<br>\pi(a_1|s_1) &#x3D; 0.5 \<br>\pi(a_2|s_1) &#x3D; 0.3 \<br>\pi(a_3|s_1) &#x3D; 0.2<br>$$</p><h3 id="1-4-Reward"><a href="#1-4-Reward" class="headerlink" title="1.4 Reward"></a>1.4 Reward</h3><ul><li><font color = red><em>Reward</em></font> is one of the most unique concept in RL.</li><li><font color = red><em>Immediate reward</em></font> can be obtained after taking an action.</li><li><font color = red><em>Reward transition</em></font> is the process of getting a reward after taking an action, reward transition can be <em>deterministic</em> or <em>stochastic</em>. Reward transition is described by $p(r|s,a)$</li></ul><p>For example deterministic reward transition can be denoted by<br>$$<br>p(r&#x3D;-1|s_1,a_2) &#x3D; 1, p(r\ne -1|s_1,a_2)&#x3D;0<br>$$<br>which means at state $s_1$ take action $a_2$ the probability to get immediate reward $-1$ is $1$.</p><p>Stochastic reward transition can be denoted by<br>$$<br>p(r&#x3D;1|s_1,a_2) &#x3D; 0.5, p(r&#x3D; 0|s_1,a_2)&#x3D;0.5<br>$$<br>which means at state $s_1$ take action $a_2$ the probability to get immediate reward $1$ is $0.5$, the probability to get immediate reward $0$ is $0.5$.</p><h3 id="1-5-Trajectory-return-episode"><a href="#1-5-Trajectory-return-episode" class="headerlink" title="1.5 Trajectory, return, episode"></a>1.5 Trajectory, return, episode</h3><ul><li><p><font color = red><em>Trajectory</em></font> is a state-action-reward chain, such as $s_1 \underset{r&#x3D;0}{\xrightarrow{a_2}} s_2 \underset{r&#x3D;0}{\xrightarrow{a_3}} s_3 \underset{r&#x3D;0}{\xrightarrow{a_4}} \cdots\underset{r&#x3D;1}{\xrightarrow{a_n}} s_{n}$.</p></li><li><p><font color = red><em>Return</em></font> of this trajecotry is the sum of all the rewards collected along the trajectory, such as $\text{return} &#x3D; 0+0+0+\cdots+1&#x3D;1$. Return is also called <font color=blue><em>total rewards</em></font> or <font color=blue><em>cumulative rewards</em></font>.</p></li><li><p><font color = red><em>Discounted return</em></font> is defined by the <font color=blue><em>discounted rate</em></font>, denoted by $\gamma\in(0,1)$. Such discounted retrun is<br>$$<br>\text{discounted return} &#x3D; 0+\gamma0+\gamma^2 0 + \gamma^3 0 + \cdots + \gamma^n 1<br>$$</p></li><li><p><font color = red><em>Episode</em></font> refers the trajectory that interacting with the enviornment following a policy <font color = blue>until the agent reach the terminal state</font>. An episode is usually assumed to be a finite trajectory,  that task with episodes are called <em>episodic tasks</em>. Some task may have no terminal state, such task is called <em>continuing tasks</em>.</p></li></ul><h3 id="1-6-Markov-decision-process-MDP"><a href="#1-6-Markov-decision-process-MDP" class="headerlink" title="1.6 Markov decision process (MDP)"></a>1.6 Markov decision process (MDP)</h3><p>Markov decision process is a general framework to <font color=blue>describe stochastic dynamical systems</font>. The key ingredients of an MDP are listed:</p><ul><li><p>Sets:</p><ul><li>State set: the set of all states, denoted as $\mathcal{S}$.</li><li>Actions set: a set of actions, denoted as $\mathcal{A}(s)$, is associated for each state $s\in\mathcal{S}$.</li><li>Reward set: a set of rewards, denoted as $\mathcal{R}(s,a)$, is associated for each state action pari $(s,a)$.</li></ul></li><li><p>Model:</p><ul><li>State transition probability: at state $s$, taking actions $a$, the probability to transit to state $s^\prime$ is $p(s^\prime|s,a)$.</li><li>Reward transition probability: at state $s$, taking action $a$, the probability to get reward $r$ is $p(r|s,a)$.</li></ul></li><li><p>Policy: as state $s$, the probability to choose action $a$ is $\pi(a|s)$.</p></li><li><p>Markov property: one key property of MDPs is the <em>Markov property</em>, which refers to the <font color=blue>memoryless property</font> of a stochastic process, which means<br>$$<br>p(s_{t+1}|s_t,a_t,s_{t-1},a_{t-1},\dots,s_0,a_0)&#x3D;p(s_{t+1}|s_t,a_t)\<br>p(r_{t+1}|s_t,a_t,s_{t-1},a_{t-1},\dots,s_0,a_0)&#x3D;p(r_{t+1}|s_t,a_t)\<br>$$</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL简明教程</title>
      <link href="/2024/03/31/C-STL%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2024/03/31/C-STL%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL简明教程"><a href="#C-STL简明教程" class="headerlink" title="C++ STL简明教程"></a>C++ STL简明教程</h1><p>C++ STL（standard template library）标准模板库，是一套强大的C++模板类，提供了通用了模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量<code>vector</code>，队列<code>deque</code>，和映射<code>map</code>等。</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>容器（Containers）</td><td>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td>算法（Algorithms）</td><td>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td>迭代器（Iterators）</td><td>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td></tr></tbody></table><p><img src="https://pic.imgdb.cn/item/66d2b21fd9c307b7e9e772fd.png" alt="img"></p><h2 id="1-1-std-vector"><a href="#1-1-std-vector" class="headerlink" title="1.1 std::vector"></a>1.1 std::vector</h2><p><code>std::vector</code>（向量），是一种变长数组，类似于python中的<code>list</code>，是一种可以“自动改变数组长度的数组”。在要使用<code>std::vector</code>的时候，我们需要添加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//如果没有这句，我们在使用时必须指明命名空间std::vector</span></span><br></pre></td></tr></table></figure><h3 id="1-1-1vector的定义"><a href="#1-1-1vector的定义" class="headerlink" title="1.1.1vector的定义"></a>1.1.1vector的定义</h3><p>可以像定义普通变量一样来定义vector变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;类型名&gt; 变量名;</span><br></pre></td></tr></table></figure><p>可以是各种类型，也同样可以是STL容器，举个例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; my_vector;</span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; my_vector;</span><br><span class="line">std::vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; my_vector;<span class="comment">//这里定义了一个二维的向量</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2vector容器的初始化"><a href="#1-1-2vector容器的初始化" class="headerlink" title="1.1.2vector容器的初始化"></a>1.1.2vector容器的初始化</h3><p>vector容器可以使用C中的<strong>初始化器</strong><code>&#123;&#125;</code>来进行初始化，vector容器也可以使用<strong>构造函数</strong><code>()</code>来进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector;<span class="comment">// 创建一个空的整数向量</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">my_vector</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;<span class="comment">// 创建一个整数向量初始化为5个10</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;<span class="comment">//创建一个整数向量为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h3 id="1-1-3vector容器内元素的访问和修改"><a href="#1-1-3vector容器内元素的访问和修改" class="headerlink" title="1.1.3vector容器内元素的访问和修改"></a>1.1.3vector容器内元素的访问和修改</h3><p><code>std::vector</code>容器一般有两种访问方式：</p><ul><li>通过下标<code>[]</code>来进行访问和修改，这种方式和python高度一致</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">my_vector</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; my_vector[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过迭代器（iterator）访问</li></ul><p>迭代器可以理解为指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;类型名&gt;::iterator 变量名;</span><br></pre></td></tr></table></figure><p>迭代器可以这样声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; my_vector;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">my_vector.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = my_vector.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; my_vector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; it[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>可以将<code>for</code>循环读取部分简写为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = my_vector.<span class="built_in">begin</span>(); it != my_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4vector中的常用函数"><a href="#1-1-4vector中的常用函数" class="headerlink" title="1.1.4vector中的常用函数"></a>1.1.4vector中的常用函数</h3><ul><li><code>push_back()</code>，在vector的末尾添加元素，类似python中<code>list.append()</code>方法</li><li><code>emplace_back()</code>，在vector的末尾添加元素（C++11特性）</li><li><code>pop_back()</code>，删除vector末尾的元素，类似python中<code>list.pop()</code>方法，但是没有返回值</li><li><code>size()</code>，返回vector的长度，类似python中的<code>len(list)</code></li><li><code>clear()</code>，清空vector中的所有元素</li><li><code>insert()</code>，在指定的地址插入元素</li><li><code>back()</code>，访问vector中的最后一个元素</li><li><code>front()</code>，访问vector中的首元</li><li><code>erase()</code>，删除指定地址的元素</li></ul><p><strong>（1）push_back()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> <span class="type">int</span> &amp;__x)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><p><strong>（2）pop_back()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">pop_back</span>()</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加10个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//使用pop_back()弹出5个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>（3）size()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">size_t</span> std::vector&lt;<span class="type">int</span>&gt;::<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加10个元素</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Length of the vector is &quot;</span> &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length of the vector is 10</span><br></pre></td></tr></table></figure><p><strong>（4）clear()</strong></p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);<span class="comment">//使用push_back向vector的末尾添加10个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Length of vector is &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Length of vector is &quot;</span> &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Length of vector is 10</span><br><span class="line">Length of vector is 0</span><br></pre></td></tr></table></figure><p><strong>（5）insert()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(__position, __x);</span><br><span class="line">参数：</span><br><span class="line">    __position: - A const_iterator into the vector.</span><br><span class="line">    __x: - Data to be inserted.</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>(), <span class="number">-1</span>);<span class="comment">// 在索引0的位置添加一个-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>() + <span class="number">1</span>, &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;);<span class="comment">// 用初始化器在索引1的位置，插入两个元素-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; antherVector = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">end</span>(), antherVector.<span class="built_in">begin</span>(), antherVector.<span class="built_in">end</span>());<span class="comment">// 在末尾，插入另一个vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">-1 1 2 3 4 5</span><br><span class="line">-1 -1 -1 1 2 3 4 5</span><br><span class="line">-1 -1 -1 1 2 3 4 5 -1 -1 -1</span><br></pre></td></tr></table></figure><p><strong>（6）erase()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">erase</span>(__position);</span><br><span class="line">参数：</span><br><span class="line">    __position: - A const_iterator into the vector.</span><br></pre></td></tr></table></figure><p>指定删除的区间的时候，这个区间是左闭右闭的。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除索引为1的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>() - <span class="number">1</span>);<span class="comment">//删除一段区间的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">1 3 4 5</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h2 id="1-2-std-string"><a href="#1-2-std-string" class="headerlink" title="1.2 std::string"></a>1.2 std::string</h2><p><code>std::string</code>（字符串），是C++标准库中用于表示和字符串的类，它提供了许多成员函数和操作符，用于处理字符串的各种操作，非常类似于Python中的<code>str</code>数据类型，当我们使用<code>std::string</code>的时候，我们需要提前包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//如果没有这句，我们在使用时必须指明命名空间std::string</span></span><br></pre></td></tr></table></figure><h3 id="1-2-1string的定义"><a href="#1-2-1string的定义" class="headerlink" title="1.2.1string的定义"></a>1.2.1string的定义</h3><p><code>std::string</code>可以像普通类型一样进行定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br></pre></td></tr></table></figure><h3 id="1-2-2string的初始化"><a href="#1-2-2string的初始化" class="headerlink" title="1.2.2string的初始化"></a>1.2.2string的初始化</h3><p><code>std::string</code>可以直接使用字符串字面量来进行初始化，或者使用另一个字符串变量来进行初始化，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello, World!&quot;</span>;<span class="comment">// 使用字符串字面量来初始化</span></span><br><span class="line">std::string str2 = str1;<span class="comment">// 使用另一个字符串变量来初始化</span></span><br></pre></td></tr></table></figure><p>举个能实际运行的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str1 = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">std::string str2 = str1;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="1-2-3string中元素的访问和修改"><a href="#1-2-3string中元素的访问和修改" class="headerlink" title="1.2.3string中元素的访问和修改"></a>1.2.3string中元素的访问和修改</h3><p><code>std::string</code>有两种访问和修改字符的方式，<code>std::string</code>和Python中<code>str</code>数据类型的不同点在于，Python<code>str</code>类型不支持原地修改，而<code>std::string</code>支持，<code>str</code>类型支持切片操作，但是<code>std::string</code>不支持切片操作，可以使用<code>std::string::substr()</code>方法来代替。</p><ul><li>使用<code>[]</code>进行元素访问和修改</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str[<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//使用[]进行元素访问</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;C&#x27;</span>;<span class="comment">//使用[]进行元素修改</span></span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">Cello World!</span><br></pre></td></tr></table></figure><ul><li>使用<code>at</code>进行元素修改和访问</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;<span class="comment">//使用at进行元素访问</span></span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;C&#x27;</span>;<span class="comment">//使用at进行元素修改</span></span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">Cello World!</span><br></pre></td></tr></table></figure><h3 id="1-2-4string的遍历"><a href="#1-2-4string的遍历" class="headerlink" title="1.2.4string的遍历"></a>1.2.4string的遍历</h3><ul><li>range-based for循环遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代器遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用下标遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-5string中连接字符串"><a href="#1-2-5string中连接字符串" class="headerlink" title="1.2.5string中连接字符串"></a>1.2.5string中连接字符串</h3><p><code>std::string</code>可以像Python中<code>str</code>一样进行使用<code>+</code>进行拼接，使用<code>append()</code>方法在末尾添加字符。</p><ul><li>使用<code>+</code>进行拼接，<code>+</code>会返回一个新的字符串</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str1 + str2;<span class="comment">// 使用+进行字符串拼接</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line"> World!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><ul><li>使用<code>append()</code>进行拼接，在原字符串的基础上进行添加</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">std::string str2 = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">str1.<span class="built_in">append</span>(str2);<span class="comment">// 使用append进行字符串拼接</span></span><br><span class="line">cout &lt;&lt; str1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line"> World!</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h3 id="1-2-6string中的常用函数"><a href="#1-2-6string中的常用函数" class="headerlink" title="1.2.6string中的常用函数"></a>1.2.6string中的常用函数</h3><ul><li><code>length()</code>获取字符串的长度，</li><li><code>size()</code>获取字符串的长度，</li><li><code>substr()</code>，获取字符串的子串，第一个参数是索引，第二个参数是子串的长度</li><li><code>find()</code>查找子串的位置</li><li><code>resize()</code>，直接调整<code>string</code>的长度</li><li><code>stoi()</code>，将单个字符串转换成<code>int</code>类型</li><li><code>stoll()</code>，将单个字符串转换成<code>long long</code>类型</li><li><code>push_back()</code>，将单个字符拼接在末尾</li><li><code>pop_back()</code>，弹出末尾的字符</li></ul><p><strong>（1）length()和size()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> std::string::<span class="built_in">length</span>() <span class="type">const</span>;</span><br><span class="line"><span class="type">size_t</span> std::string::<span class="built_in">size</span>() <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 12</span><br></pre></td></tr></table></figure><p><strong>（2）substr()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string std::string::<span class="built_in">substr</span>(<span class="type">size_t</span> __pos, <span class="type">size_t</span> __count) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p><code>substr()</code>是用于获得子串的函数，第一个位置是索引，第二个位置是子串的长度。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hell</span><br></pre></td></tr></table></figure><p><strong>（3）find()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> std::string::<span class="built_in">find</span>(<span class="type">const</span> std::string&amp; __str, <span class="type">size_t</span> __pos = <span class="number">0</span>) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p><code>find()</code>是用于查找子串的位置，返回子串首元出现在母船中的位置。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">std::string substr = <span class="string">&quot;orld&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(substr) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>返回的是<code>orld</code>在字符串<code>Hello World!</code>中首元的位置，在下标<code>7</code>的地方。</p><h2 id="1-3-std-map"><a href="#1-3-std-map" class="headerlink" title="1.3 std::map"></a>1.3 std::map</h2><p><code>std::map</code>是一种键值对容器，在python中这种容器被称为字典<code>dict</code>，在<code>std::map</code>中数据都是成对出现的，每一对中的第一个值被称为关键字<code>key</code>，每个关键字只能在<code>std::map</code>中出现一次，第二个称之为关键的对应值。在使用<code>std::map</code>之前，我们需要包含头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//如果没有这句，我们在使用时必须指明命名空间std::map</span></span><br></pre></td></tr></table></figure><h3 id="1-3-1map的定义"><a href="#1-3-1map的定义" class="headerlink" title="1.3.1map的定义"></a>1.3.1map的定义</h3><p><code>std::map</code>是一个模板类，需要的关键字和存储对象两个模板参数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;关键字的类型名， 存储对象的类型名&gt; 变量名;</span><br></pre></td></tr></table></figure><p>类型名可以是各种类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;string, <span class="type">int</span>&gt; person;<span class="comment">//使用string需要先#include &lt;string&gt;</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mydict;</span><br></pre></td></tr></table></figure><h3 id="1-3-2map的初始化"><a href="#1-3-2map的初始化" class="headerlink" title="1.3.2map的初始化"></a>1.3.2map的初始化</h3><p><code>std::map</code>可以使用初始化列表<code>&#123;&#125;</code>来进行初始化，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-3map的遍历"><a href="#1-3-3map的遍历" class="headerlink" title="1.3.3map的遍历"></a>1.3.3map的遍历</h3><p><code>std::map</code> 并不直接支持使用下标进行遍历，因为它是一种按键排序的关联容器，而不是顺序容器。使用下标遍历会导致元素的顺序混乱，不符合 <code>std::map</code> 的特性。</p><ul><li>使用迭代器遍历</li></ul><p>举个例子，初始化一个<code>std::map</code>然后使用<code>iterator</code>遍历其中的键值对（key-value pair）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (std::map&lt;string, <span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); it++ ) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用 <code>myMap.begin()</code> 获取指向第一个键值对的迭代器，使用 <code>myMap.end()</code> 获取指向最后一个键值对后面位置的迭代器。然后，通过迭代器遍历 <code>std::map</code> 中的键值对，并使用 <code>it-&gt;first</code> 获取键，<code>it-&gt;second</code> 获取值。</p><p>上述代码我们在指定迭代器的时候，手动去指定迭代器的类型，这样十分的麻烦，我们可以使用<code>auto</code>关键字来自动生成符合条件的迭代器，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); it++ ) &#123;<span class="comment">// 使用auto关键字自动生成迭代器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用范围循环遍历</li></ul><p>举个例子，初始化一个<code>std::map</code>然后使用<code>std::pair</code>遍历其中的键值对（key-value pair）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;string, <span class="type">int</span>&gt;&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><p>同样我们也能使用关键字<code>auto</code>来自动推导类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;<span class="comment">// 使用auto关键字自动生成pair</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-4map中元素的访问和修改"><a href="#1-3-4map中元素的访问和修改" class="headerlink" title="1.3.4map中元素的访问和修改"></a>1.3.4map中元素的访问和修改</h3><p>可以使用<code>[]</code>来访问并修改<code>std::map</code>中的元素，就类似于Python的<code>dict</code>一样，举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line">myMap[<span class="string">&quot;One&quot;</span>] = <span class="number">10</span>;<span class="comment">// 修改One对应的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;<span class="comment">// 使用auto关键字自动生成迭代器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 10</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><h3 id="1-3-5map中的常用函数"><a href="#1-3-5map中的常用函数" class="headerlink" title="1.3.5map中的常用函数"></a>1.3.5map中的常用函数</h3><ul><li><code>insert()</code>，向map中插入一个键值对，</li><li><code>erase()</code>，删除指定键的键值对</li><li><code>find()</code>，查找指定键的迭代器</li><li><code>count()</code>，返回指定键在map中的出现次数</li><li><code>size()</code>，返回map的长度</li><li><code>empty()</code>，检查map是否为空</li><li><code>clear()</code>，清空map中的所有键值对</li><li><code>beign()</code>，返回指向第一个键值对的迭代器</li><li><code>end()</code>，返回指向最后一个键值对的迭代器</li></ul><p>这里有很多函数的用法于之前介绍<code>string</code>和<code>vector</code>时的用法类似，这里就不再重复介绍了，</p><p><strong>（1）insert()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::map&lt;Key, T, Compare, Allocator&gt;::<span class="built_in">insert</span>(<span class="type">const</span> std::pair&lt;<span class="type">const</span> Key, T&gt;&amp; __x)</span><br></pre></td></tr></table></figure><p><code>std::map&lt;Key, T, Compare, Allocator&gt;</code> 表示 <code>std::map</code> 的模板参数，其中 <code>Key</code> 是键的类型，<code>T</code> 是值的类型，<code>Compare</code> 是用于比较键的比较函数类型，<code>Allocator</code> 是分配器的类型。</p><p>而 <code>insert()</code> 函数的原型部分 <code>const std::pair&lt;const Key, T&gt;&amp; __x</code> 表示参数 <code>__x</code> 是一个常量引用，类型为 <code>std::pair&lt;const Key, T&gt;</code>，即键值对的类型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;Four&quot;</span>, <span class="number">4</span> &#125;);<span class="comment">//插入单个键值对</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;Five&quot;</span>, <span class="number">5</span>));<span class="comment">//插入std::pair键值对</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Six&quot;</span>, <span class="number">6</span>));<span class="comment">//使用std::make_pair插入键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br><span class="line"></span><br><span class="line">Key: Five       Value: 5</span><br><span class="line">Key: Four       Value: 4</span><br><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Six        Value: 6</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br></pre></td></tr></table></figure><p><strong>（2）erase()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::map&lt;Key, T, Compare, Allocator&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; __x)</span><br></pre></td></tr></table></figure><p><code>std::map&lt;Key, T, Compare, Allocator&gt;</code> 表示 <code>std::map</code> 的模板参数，其中 <code>Key</code> 是键的类型，<code>T</code> 是值的类型，<code>Compare</code> 是用于比较键的比较函数类型，<code>Allocator</code> 是分配器的类型。</p><p>而 <code>erase()</code> 函数的原型部分 <code>const Key&amp; __x</code> 表示参数 <code>__x</code> 是一个常量引用，类型为 <code>Key</code>，即要删除的键的类型。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::map&lt;string, <span class="type">int</span>&gt; myMap = &#123; &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;, &#123;<span class="string">&quot;Two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;Three&quot;</span>, <span class="number">3</span>&#125;, &#123; <span class="string">&quot;Four&quot;</span>, <span class="number">4</span> &#125;, &#123;<span class="string">&quot;Five&quot;</span>, <span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="string">&quot;Two&quot;</span>);<span class="comment">// 删除指定键的键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Three&quot;</span>);<span class="comment">// 删除指定迭代器指向的键值对</span></span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">myMap.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> start = myMap.<span class="built_in">find</span>(<span class="string">&quot;Five&quot;</span>);<span class="comment">// 删除一定范围内的键值对</span></span><br><span class="line"><span class="keyword">auto</span> end = myMap.<span class="built_in">find</span>(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">myMap.<span class="built_in">erase</span>(start, end);<span class="comment">// 左开右闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\tValue: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Key: Five       Value: 5</span><br><span class="line">Key: Four       Value: 4</span><br><span class="line">Key: One        Value: 1</span><br><span class="line">Key: Three      Value: 3</span><br><span class="line">Key: Two        Value: 2</span><br><span class="line"></span><br><span class="line">Key: Four       Value: 4</span><br><span class="line">Key: One        Value: 1</span><br></pre></td></tr></table></figure><h2 id="1-4std-pair"><a href="#1-4std-pair" class="headerlink" title="1.4std::pair"></a>1.4std::pair</h2><p><code>std::pair</code>是C++标准库中的模板类，用于表示两个值的有序对，它可以存储不同类型的值，并提供了一些成员函数和操作符来访问和操作这两个值，在使用<code>std::pair</code>之前，我们需要导入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span><span class="comment">// 导入该头文件才能正常使用pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">// 但是当我们使用了标准输入输出流的时候，就已经包括了该头文件，无需重复导入</span></span></span><br></pre></td></tr></table></figure><h3 id="1-4-1pair的定义和初始化"><a href="#1-4-1pair的定义和初始化" class="headerlink" title="1.4.1pair的定义和初始化"></a>1.4.1pair的定义和初始化</h3><ul><li>使用构造函数进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair &lt;<span class="type">int</span>, std::string&gt; <span class="built_in">myPair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>使用初始化器<code>&#123;&#125;</code>来初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair &lt;<span class="type">int</span>, std::string&gt; myPair = &#123;<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用<code>make_pair</code>函数进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);<span class="comment">// 使用auto自动推断构建后的类型</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2pair的访问与修改"><a href="#1-4-2pair的访问与修改" class="headerlink" title="1.4.2pair的访问与修改"></a>1.4.2pair的访问与修改</h3><p>使用<code>.</code>来访问<code>std::pair</code>中的值，<code>std::pair</code> 的第一个值可以通过 <code>pair.first</code> 访问，第二个值可以通过 <code>pair.second</code> 访问。需要注意的是，<code>std::pair</code> 是一个简单的容器，只包含两个值，没有提供像容器类（如 <code>std::vector</code> 或 <code>std::map</code>）那样的迭代器和成员函数。使用 <code>std::pair</code> 主要是为了方便地存储和传递两个相关的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl;<span class="comment">//访问pair1的第一个值</span></span><br><span class="line">pair2.second = <span class="number">5</span>;<span class="comment">//修改pair2的第二个值</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3pair的比较"><a href="#1-4-3pair的比较" class="headerlink" title="1.4.3pair的比较"></a>1.4.3pair的比较</h3><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pair2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isEqual = (pair1 == pair2);</span><br><span class="line"><span class="type">bool</span> isNotEqual = (pair1 != pair2);</span><br><span class="line"><span class="type">bool</span> isLess = (pair1 &lt; pair2);</span><br><span class="line"><span class="type">bool</span> isGreater = (pair1 &gt; pair2);</span><br><span class="line">cout &lt;&lt; isEqual &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isNotEqual &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isLess &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; isGreater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure><h2 id="1-5std-set"><a href="#1-5std-set" class="headerlink" title="1.5std::set"></a>1.5std::set</h2><p><code>std::set</code>是C++标准库中的容器类，用于存储唯一且自动排序的元素集合，类似于Python中的<code>set</code>。要使用<code>std::set</code>，我们需要包含以下头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-5-1set的定义"><a href="#1-5-1set的定义" class="headerlink" title="1.5.1set的定义"></a>1.5.1set的定义</h3><p><code>set</code>是一个模板类，需要的一个模板参数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;类型名&gt; 变量名;</span><br></pre></td></tr></table></figure><p>类型名可以是各种类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">std::set&lt;string&gt; mySet;</span><br></pre></td></tr></table></figure><h3 id="1-5-2set的初始化"><a href="#1-5-2set的初始化" class="headerlink" title="1.5.2set的初始化"></a>1.5.2set的初始化</h3><p><code>std::set</code>可以使用多种方式来进行初始化</p><ul><li>使用初始化列表来初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//使用初始化列表初始化set</span></span><br></pre></td></tr></table></figure><ul><li>使用迭代器范围初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mySet</span><span class="params">(vec.begin(), vec.end())</span></span>;<span class="comment">// 使用迭代器范围初始化set</span></span><br></pre></td></tr></table></figure><ul><li>使用另一个<code>std::set</code>进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; sourceSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mySet</span><span class="params">(sourceSet)</span></span>;<span class="comment">// 使用另一个`std::set`进行初始化</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3set的插入与删除"><a href="#1-5-3set的插入与删除" class="headerlink" title="1.5.3set的插入与删除"></a>1.5.3set的插入与删除</h3><p><code>std::set</code>中有关插入与修删除的函数分别是：</p><ul><li><code>insert()</code>，插入一个元素</li><li><code>erase()</code>，删除一个元素</li></ul><p>插入元素的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">10</span>);<span class="comment">// 插入一个元素10</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3 10</span><br></pre></td></tr></table></figure><p>删除元素的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">1</span>);<span class="comment">// 插入一个元素1</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="1-5-4set的遍历"><a href="#1-5-4set的遍历" class="headerlink" title="1.5.4set的遍历"></a>1.5.4set的遍历</h3><p>在C++标准库中<code>std::set</code>是基于红黑树实现的关联容器，其中元素按照特定的排序顺序规则进行存储和访问，所以<code>std::set</code>不支持使用<code>[]</code>通过下标来进行访问，对于<code>std::set</code>要访问其中的元素，我们可以使用<strong>迭代器</strong>或者<strong>范围-based for循环</strong>来访问</p><ul><li>使用迭代器来遍历访问</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (std::set&lt;<span class="type">int</span>&gt;::iterator it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;<span class="comment">// 手动指定迭代器类型</span></span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;<span class="comment">// 使用auto关键字自动推断迭代器类型</span></span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><ul><li>使用范围-based for循环来遍历访问</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; value : mySet) &#123;<span class="comment">// 手动指定value的类型</span></span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : mySet) &#123;<span class="comment">// 使用auto关键字自动推导类型</span></span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="1-5-5set中的常用函数"><a href="#1-5-5set中的常用函数" class="headerlink" title="1.5.5set中的常用函数"></a>1.5.5set中的常用函数</h3><ul><li><code>count()</code>，返回指定键在set中的出现次数</li><li><code>find()</code>，查找指定值的迭代器</li><li><code>size()</code>，获取元素的数量</li><li><code>empty()</code>，判断set是否为空</li><li><code>clear()</code>，清空set</li></ul><p><strong>（1）count()</strong></p><p><code>std::set::count()</code>会返回查找元素在容器中的次数，这里是<code>std::set</code>，不允许有重复的元素，所以如果查找到元素的话就返回<code>1</code>，没有查找到元素就返回<code>0</code>。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mySet.<span class="built_in">count</span>(<span class="number">1</span>) != <span class="number">0</span>) &#123;<span class="comment">// 查找元素1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;找到元素&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;未找到元素为&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到元素</span><br></pre></td></tr></table></figure><p><strong>（2）find()</strong></p><p><code>std::set::find()</code>会返回查找元素的迭代器，如果没找到，则遍历到<code>std::set::end()</code></p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// set初始化为1, 2, 3</span></span><br><span class="line"><span class="comment">//auto it = mySet.find(3);</span></span><br><span class="line"><span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it == mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;遍历到末尾未找到元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;找到元素为:&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">遍历到末尾未找到元素</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到元素为:3</span><br></pre></td></tr></table></figure><h2 id="1-6std-stack"><a href="#1-6std-stack" class="headerlink" title="1.6std::stack"></a>1.6std::stack</h2><p>在C++中，<code>std::stack</code>是一个容器适配器，它基于其他容器实现了栈的功能，栈是一种先进后出（first int last out， FILO）的数据结构，要使用<code>std::stack</code>我们得先包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-6-1stack的初始化"><a href="#1-6-1stack的初始化" class="headerlink" title="1.6.1stack的初始化"></a>1.6.1stack的初始化</h3><p><code>std::stack</code>的使用过程中一般使用默认初始化，即不给<code>std::stack</code>赋值，<code>std::stack</code>不支持使用花括号初始化器<code>&#123;&#125;</code>来进行初始化，但是<code>std::stack</code>可以使用其他容器来进行初始化，比如<code>std::deque</code>，这种初始化方式会调用适当的构建函数来构建栈对象。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">std::stack&lt;<span class="type">int</span>&gt; <span class="title">myStack</span><span class="params">(myDeque)</span></span>;<span class="comment">// 使用std::deque来构建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::stack&lt;<span class="type">int</span>&gt; <span class="title">myStack</span><span class="params">(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;)</span></span>;<span class="comment">// // 使用std::deque作为底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><h3 id="1-6-2stack的常用函数"><a href="#1-6-2stack的常用函数" class="headerlink" title="1.6.2stack的常用函数"></a>1.6.2stack的常用函数</h3><ul><li><code>push()</code>，向栈顶添加元素</li><li><code>pop()</code>，弹出栈顶元素，请注意无返回值</li><li><code>top()</code>，访问栈顶元素</li><li><code>empty()</code>，判断栈是否为空</li><li><code>size()</code>，获取栈中元素的数量</li></ul><p>举个使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">myStack.<span class="built_in">push</span>(i + <span class="number">1</span>);<span class="comment">// 向栈中添加元素</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;栈顶元素为: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;<span class="comment">// 查看栈顶元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;弹出元素&quot;</span> &lt;&lt; std::endl;<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">myStack.<span class="built_in">pop</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;栈中元素个数为: &quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl;<span class="comment">// 查看元素个数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;栈是否为空: &quot;</span> &lt;&lt; myStack.<span class="built_in">empty</span>() &lt;&lt; std::endl;<span class="comment">// 查看栈是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈顶元素为: 10</span><br><span class="line">弹出元素</span><br><span class="line">栈中元素个数为: 8</span><br><span class="line">栈是否为空: 0</span><br></pre></td></tr></table></figure><h2 id="1-7std-queue"><a href="#1-7std-queue" class="headerlink" title="1.7std::queue"></a>1.7std::queue</h2><p>在C++标准库中，<code>std::queue</code>是一个容器适配器，它提供了队列的功能<code>queue</code>，队列是一种先进先出（first in first out）的数据结构，<code>std::queue</code>通过封装<code>std:deque</code>来实现队列操作，使用<code>std::queue</code>需要包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-7-1queue的初始化"><a href="#1-7-1queue的初始化" class="headerlink" title="1.7.1queue的初始化"></a>1.7.1queue的初始化</h3><p><code>std::queue</code>可以使用默认初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br></pre></td></tr></table></figure><p><code>std::queue</code>也可以使用花括号初始化器<code>&#123;&#125;</code>来进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; myQueue = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-7-2queue的常用函数"><a href="#1-7-2queue的常用函数" class="headerlink" title="1.7.2queue的常用函数"></a>1.7.2queue的常用函数</h3><ul><li><code>push()</code>，在队尾添加元素</li><li><code>front()</code>，访问队首元素</li><li><code>back()</code>，访问队尾元素</li><li><code>pop()</code>，移除队首元素，无返回值</li><li><code>empty()</code>，检查是否为空</li><li><code>size()</code>，返回队列中元素数量</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; myQueue;<span class="comment">// 默认初始化</span></span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">// 添加元素</span></span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;当前队首元素为: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;<span class="comment">// 查看队首元素</span></span><br><span class="line">myQueue.<span class="built_in">pop</span>();<span class="comment">// 移除队首元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;当前队列中的元素数量为: &quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl;<span class="comment">// 查看队列中元素个数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;当前队列是否为空: &quot;</span> &lt;&lt; myQueue.<span class="built_in">empty</span>() &lt;&lt; std::endl;<span class="comment">// 查看当前队列是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前队首元素为: 1</span><br><span class="line">当前队列中的元素数量为: 2</span><br><span class="line">当前队列是否为空: 0</span><br></pre></td></tr></table></figure><h2 id="1-8std-priority-queue"><a href="#1-8std-priority-queue" class="headerlink" title="1.8std::priority_queue"></a>1.8std::priority_queue</h2><p>Cpp的标准库中<code>std::priority_queue</code>是一个模板类，用于实现优先级队列，其中的元素按照一定的优先级顺序进行排列，默认情况下，<code>std::priority_queue</code>使用大顶堆进行排序（即最大的元素优先）。使用<code>std::priority_queue</code>需要先包含头文件</p><h3 id="1-8-1std-priority-queue的基本用法"><a href="#1-8-1std-priority-queue的基本用法" class="headerlink" title="1.8.1std::priority_queue的基本用法"></a>1.8.1std::priority_queue的基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>1.定义元素类型：确定要存储在优先级队列中的元素类型。该类型必须支持比较操作符（<code>&lt;</code>），以便进行元素的排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyElement</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.定义比较函数或使用自定义比较器（可选）：如果您的元素类型不是内置类型或没有默认的 <code>&lt;</code> 操作符，您需要定义一个比较函数或使用自定义的比较器类来指定元素的优先级排序规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyElement&amp; lhs, <span class="type">const</span> MyElement&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.priority &lt; rhs.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.创建优先级队列对象：使用定义的元素类型和比较函数&#x2F;比较器类，创建一个 <code>std::priority_queue</code> 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;MyElement, std::vector&lt;MyElement&gt;, Compare&gt; pq;</span><br></pre></td></tr></table></figure><p>4.插入元素：使用 <code>push</code> 函数将元素插入优先级队列中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyElement element1&#123;<span class="number">5</span>, <span class="string">&quot;First&quot;</span>&#125;;</span><br><span class="line">MyElement element2&#123;<span class="number">3</span>, <span class="string">&quot;Second&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pq.<span class="built_in">push</span>(element1);</span><br><span class="line">pq.<span class="built_in">push</span>(element2);</span><br></pre></td></tr></table></figure><p>5.访问顶部元素：使用 <code>top</code> 函数访问优先级队列中的最高优先级元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyElement topElement = pq.top();</span><br></pre></td></tr></table></figure><p>6.删除顶部元素：使用 <code>pop</code> 函数从优先级队列中删除最高优先级元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pq.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><p>通过重复执行步骤 5 和步骤 6，您可以顺序访问和删除优先级队列中的元素。</p><h3 id="1-8-2std-priority-queue的使用示例"><a href="#1-8-2std-priority-queue的使用示例" class="headerlink" title="1.8.2std::priority_queue的使用示例"></a>1.8.2std::priority_queue的使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    std::string description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> p, <span class="type">const</span> std::string&amp; desc) : <span class="built_in">priority</span>(p), <span class="built_in">description</span>(desc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Task&amp; lhs, <span class="type">const</span> Task&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.priority &lt; rhs.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, Compare&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到队列</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(<span class="number">2</span>, <span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(<span class="number">1</span>, <span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(<span class="number">3</span>, <span class="string">&quot;Task 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理任务</span></span><br><span class="line">    <span class="keyword">while</span> (!taskQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Task currentTask = taskQueue.<span class="built_in">top</span>();</span><br><span class="line">        taskQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing task: &quot;</span> &lt;&lt; currentTask.description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Processing task: Task 3</span><br><span class="line">Processing task: Task 2</span><br><span class="line">Processing task: Task 1</span><br></pre></td></tr></table></figure><h2 id="1-9std-algorithm"><a href="#1-9std-algorithm" class="headerlink" title="1.9std::algorithm"></a>1.9std::algorithm</h2><p>Cpp的标准库中<code>std::algorithm</code>提供了许多使用的算法函数，用于处理容器（如<code>std::vector</code>、<code>std::list</code>等）中的元素，这些算法函数可以用于查找、排序、转换、合并等操作。在使用<code>std::algorithm</code>之前，需要包含头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-9-1algorithm中的常用函数"><a href="#1-9-1algorithm中的常用函数" class="headerlink" title="1.9.1algorithm中的常用函数"></a>1.9.1algorithm中的常用函数</h3><ul><li><code>std::sort()</code>，对容器进行排序</li><li><code>std::find()</code>，返回查找容器中的值的迭代器，没有找到则返回<code>容器::end()</code></li><li><code>std::copy()</code>，将一个容器的元素复制到另一个容器中</li><li><code>std::reverse()</code>，将容器中的元素进行反转</li><li><code>std::max()</code>，返回比较值中的最大元素</li><li><code>std::max_element()</code>，返回查找指定范围中的最大值所对应的迭代器</li><li><code>std::min()</code>，返回比较值中的最小元素</li><li><code>std::min_element()</code>，返回查找指定范围中的最小值所对应的迭代器</li><li><code>std::swap()</code>，交换两个对象的值</li></ul><p><strong>（1）std::sort()</strong></p><p>函数的原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">    Compare pred)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myV&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myV.<span class="built_in">begin</span>(), myV.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : myV) &#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>举个例子，使用逆序排列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompareReverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myV&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">//std::sort(myV.begin(), myV.end(), CompareReverse);// 1.传入比较函数</span></span><br><span class="line">std::<span class="built_in">sort</span>(myV.<span class="built_in">begin</span>(), myV.<span class="built_in">end</span>(),<span class="comment">// 2.使用Lambda匿名函数</span></span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : myV) &#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 8 7 6 5 3 2 1 0</span><br></pre></td></tr></table></figure><p><strong>（2）std::find()</strong></p><p>函数原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">cout &lt;&lt; *std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 1.查找元素3</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">bool</span>(std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">8</span>) == v.<span class="built_in">end</span>());<span class="comment">// 2.未找到元素8，返回v.end()</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>（3）std::copy()</strong></p><p>函数原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator destBeg)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; source&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">destination</span><span class="params">(source.size(),<span class="number">0</span>)</span></span>;<span class="comment">// 确保destination能够容纳source的所有元素</span></span><br><span class="line">std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), destination.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : destination) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>（4）std::reverse()</strong></p><p>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    BidirectionalIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::<span class="built_in">reverse</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : v1) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure><p><strong>（5）std::max()，std::min()</strong></p><p>函数原型分别是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Type&amp; <span class="title">max</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; left,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; right)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> Type&amp; <span class="title">min</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; left,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Type&amp; right)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The max value of two is: &quot;</span> &lt;&lt; std::<span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The max value of three is: &quot;</span> &lt;&lt; std::<span class="built_in">max</span>(&#123; <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The max value of two is: 7</span><br><span class="line">The max value of three is: 9</span><br></pre></td></tr></table></figure><p><strong>（6）std::max_element()，std::min_element()</strong></p><p>函数原型分别是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ForwardIterator <span class="title">max_element</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ForwardIterator <span class="title">min_element</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    ForwardIterator last )</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> min_it = std::<span class="built_in">min_element</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The max of v1 is: &quot;</span> &lt;&lt; *max_it &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The min of v1 is: &quot;</span> &lt;&lt; *min_it;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The max of v1 is: 9</span><br><span class="line">The min of v1 is: 1</span><br></pre></td></tr></table></figure><p><strong>（7）std::swap()</strong></p><p>函数原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type&amp; left,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type&amp; right)</span></span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myV&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; myV.<span class="built_in">size</span>(), j &lt; myV.<span class="built_in">size</span>(); i += <span class="number">2</span>, j += <span class="number">2</span>) &#123;</span><br><span class="line">std::<span class="built_in">swap</span>(myV[i], myV[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : myV) &#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 4 3</span><br></pre></td></tr></table></figure><p>这个例子两两交换了数组中的值。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.apiref.com/cpp-zh/cpp/container.html">C++容器库</a><br><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?view=msvc-170">C++微软库</a></p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型预测控制MPC详解（附带案例实现）</title>
      <link href="/2024/02/22/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6MPC%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2024/02/22/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6MPC%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="模型预测控制MPC详解（附带案例实现）"><a href="#模型预测控制MPC详解（附带案例实现）" class="headerlink" title="模型预测控制MPC详解（附带案例实现）"></a>模型预测控制MPC详解（附带案例实现）</h1><p>写在前面本文是记录学习B站博主<a href="https://space.bilibili.com/230105574?spm_id_from=333.337.0.0">Dr.can</a>的学习笔记，如有侵权请联系笔者删除此文。</p><h2 id="1-最优控制问题"><a href="#1-最优控制问题" class="headerlink" title="1. 最优控制问题"></a>1. 最优控制问题</h2><p>最优控制问题就是研究在约束条件下达到最优的系统表现，通常系统的表现是综合分析的结果。比如考虑一个<strong>单输入单输出</strong>的系统（<strong>SISO</strong>），状态变量$x$，输出为$y$，要求其输出能跟踪预设的参考值$r$，误差可以表示为$e&#x3D;y-r$，那么最优控制的目标是</p><p>$$<br>\min \int_0^t e^2 dt<br>$$</p><p>如果同时希望输入量$u$也能越小越好（一般的目的是减少能耗），那最优控制的目标可以是</p><p>$$<br>\min \int_0^t q\times e^2 dt + r\times u^2 dt<br>$$</p><p>其中$q,r$分别是权重参数，用于调节两个目标的重要性。</p><p>考虑一个<strong>多输入多输出</strong>的系统（<strong>MIMO</strong>），系统的模型为：</p><p>$$<br>\begin{align*}<br>\frac{dX}{dt} &amp; &#x3D; AX + BU\<br>Y &amp; &#x3D; CX<br>\end{align*}<br>$$</p><p>那么可以将上述的最优化目标改写为：</p><p>$$<br>J &#x3D; \int^t_0 E^T Q E + U^T R U dt<br>$$</p><p>举一个实际的例子，系统的模型如下所示：</p><p>$$<br>\begin{align*}<br>\frac{d}{dt}<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix} &amp; &#x3D; A<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix} + B<br>\begin{bmatrix}<br>u_1\<br>u_2<br>\end{bmatrix}\<br>\begin{bmatrix}<br>y_1\<br>y_2<br>\end{bmatrix} &amp; &#x3D;<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix}<br>\end{align*}<br>$$</p><p>设置的参考值$R$为:</p><p>$$<br>R &#x3D; \begin{bmatrix}<br>r_1\<br>r_2<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>0\<br>0<br>\end{bmatrix}<br>$$</p><p>那么可以推导出误差$E$为：</p><p>$$<br>E &#x3D;<br>\begin{bmatrix}<br>e_1\<br>e_2<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>y_1 - r_1\<br>y_2 - r_2<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix}<br>$$</p><p>那么上述最优控制的目标函数可以写成：</p><p>$$<br>\begin{align*}<br>E^TQE  &amp; &#x3D;<br>\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix}^T \begin{bmatrix}<br>q_1 &amp; 0\<br>0 &amp; q_2<br>\end{bmatrix}\begin{bmatrix}<br>x_1\<br>x_2<br>\end{bmatrix} &#x3D; q_1 x_1^2 + q_2 x_2^2\<br>U^TRU &amp; &#x3D;<br>\begin{bmatrix}<br>u_1\<br>u_2<br>\end{bmatrix}^T \begin{bmatrix}<br>r_1 &amp; 0\<br>0 &amp; r_2<br>\end{bmatrix}\begin{bmatrix}<br>u_1\<br>u_2<br>\end{bmatrix} &#x3D; r_1 u_1^2 +r_2 u_2^2\<br>J &amp; &#x3D; \int^t_0 q_1 x_1^2 + q_2 x_2^2 + r_1 u_1^2 + r_2 u_2^2<br>\end{align*}<br>$$</p><h2 id="2-什么是MPC"><a href="#2-什么是MPC" class="headerlink" title="2. 什么是MPC"></a>2. 什么是MPC</h2><p>MPC（Model Predictive Control，模型预测控制）的基本思想是通过建立一个系统的动态模型，并在每一个控制时刻使用这个模型来预测系统未来的行为。基于这些预测，它可以生成一个优化控制序列，然后通过执行第一个控制动作来调整系统状态，接着在下一个时刻重新计算和执行。这个过程反复进行，以使系统能够在未来的一段时间内优化一个特定的性能指标。</p><p>通常来说，MPC包括以下四个基本步骤：</p><ul><li><p><strong>系统模型化</strong>：建立描述系统动态行为的数学模型，通常是差分方程或微分方程。</p></li><li><p><strong>预测</strong>：在当前时刻基于系统状态和控制输入，使用模型预测未来一段时间内的系统响应。</p></li><li><p><strong>优化</strong>：基于预测的系统响应，通过求解一个优化问题来计算最优的控制输入序列，以最大化或最小化一个性能指标（如系统响应时间、能耗等）。</p></li><li><p><strong>执行</strong>：根据优化得到的控制输入序列中的第一个值，执行这个控制动作，并将实际的系统状态反馈到下一个控制周期中</p></li></ul><p>在具体实施的过程中MPC主要分为下列的三个步骤：</p><p>在<code>k</code>时刻：</p><ul><li><font color=red>step1</font>：估计&#x2F;测量&#x2F;读取当前的系统状态；</li><li><font color=red>step2</font>：基于$\bold{u}<em>k, \bold{u}</em>{k+1},  \cdots, \bold{u}<em>{k+N}$来进行最优化<br>  $$<br>  J &#x3D; \sum_k^{N-1} E_k^TQE_k + U_k^T R U_k + \underbrace{E_N^TFE_N}</em>{\text{Terminal Cost}}<br>  $$<br>  其中Terminal Cost代表了模型滑动窗口的末端的控制误差。</li><li><font color=red>step3</font>：只取$\bold{u}_k$，进行滚动优化控制。</li></ul><h2 id="3-二次规划Quadratic-Programming"><a href="#3-二次规划Quadratic-Programming" class="headerlink" title="3. 二次规划Quadratic Programming"></a>3. 二次规划Quadratic Programming</h2><p>为了能求解MPC问题，我们需要将其转换成二次规划（Quadratic Programming）的形式，对于二次规划已经有很多成熟的求解器了，我们只需要使用这些求解器就能顺利求解。</p><p>二次规划一般具有如下的形式：</p><p>$$<br>\begin{align*}<br>&amp; \min_\bold{x} \bold{x}^TH\bold{x} + f^T\bold{x}\<br>&amp; \text{subject to} \quad…<br>\end{align*}<br>$$</p><p>其中$H$是正定的对称矩阵，$f$，$\bold{x}$是向量。</p><h2 id="4-MPC为什么可以转换成QP问题（推导过程）"><a href="#4-MPC为什么可以转换成QP问题（推导过程）" class="headerlink" title="4. MPC为什么可以转换成QP问题（推导过程）"></a>4. MPC为什么可以转换成QP问题（推导过程）</h2><p>考虑一个<font color=red>离散</font>的线性系统</p><p>$$<br>\bold{x}(k+1) &#x3D; A_{n\times n}\bold{x}(k) + B_{n\times p}\bold{u}(k)\<br>\bold{x}<em>{n\times 1} &#x3D; \begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots\<br>x_n<br>\end{bmatrix}, \bold{u}</em>{p\times1} &#x3D; \begin{bmatrix}<br>u_1\<br>u_2\<br>\vdots\<br>u_p<br>\end{bmatrix}<br>$$</p><p>假设滚动的窗口大小（预测区间，Predictive Horizon）为$N$，在$k$时刻，预测$k$时刻的输入为$\bold{u}(k|k)$，预测$k+1$时刻的输入为$\bold{u}(k+1|k)$，以此类推预测，预测区间的最后一个时刻的输入为$\bold{u}(k+N-1|k)$，将这些预测输入整合成一个向量</p><p>$$<br>\bold{U}_k &#x3D; \begin{bmatrix}<br>\bold{u}(k|k)\<br>\bold{u}(k+1|k)\<br>\vdots\<br>\bold{u}(k+i|k)\<br>\bold{u}(k+N-1|k)<br>\end{bmatrix}<br>$$</p><p>在$k$时刻，系统的状态为$\bold{x}(k|k)$，$k+1$系统的状态为$\bold{x}(k+1|k)$，以此类推预测，预测区间的最后一个时刻的系统的状态为$\bold{x}(k+N-1|k)$，然后再加上区间结束后的第一个状态$\bold{x}(k+N|k)$，将这些系统的状态整合成一个向量</p><p>$$<br>\bold{X}_k &#x3D; \begin{bmatrix}<br>\bold{x}(k|k)\<br>\bold{x}(k+1|k)\<br>\vdots\<br>\bold{x}(k+i|k)\<br>\bold{x}(k+N|k)<br>\end{bmatrix}<br>$$</p><p>假设系统的输出$\bold{y}&#x3D;\bold{x}$，设定的参考值$\bold{r}&#x3D;0$，那么系统的误差为$\bold{e}&#x3D;\bold{y}-\bold{r}&#x3D;\bold{x}-0 &#x3D; \bold{x}$，为了最优化误差和最优化输入，我们可以这样表示代价函数（Cost Function)</p><p>$$<br>\min_\bold{u} J &#x3D; \sum^{N-1}<em>{i&#x3D;0} \Big(\bold{x}(k+i|k)^TQ \bold{x}(k+i|k) + \bold{u}(k+i|k)^TR \bold{u}(k+i|k) \Big) + \underbrace{\bold{x}(k+N)^T F \bold{x}(k+N)}</em>{\text{Terminal Cost}}<br>$$</p><p>但是乍一看这并不是二次规划的形式，我们可以通过化简将其转化为标准的二次规划形式。</p><p>在$k$时刻，我们的系统状态可以表示为</p><p>$$<br>\begin{align*}<br>\bold{x}(k|k) &amp; &#x3D; \bold{x}_k\<br>\bold{x}(k+1|k) &amp; &#x3D; A \bold{x}(k|k) + B\bold{u}(k|k) &#x3D; A\bold{x}_k + B\bold{u}(k|k)\<br>\bold{x}(k+2|k) &amp; &#x3D; A \bold{x}(k+1|k) + B\bold{u}(k|k) &#x3D; A^2\bold{x}_k + AB\bold{u}(k|k) + B\bold{u}(k+1|k)\<br>\vdots\<br>\bold{x}(k+N|k) &amp; &#x3D; A^N \bold{x}_k + A^{N-1}B\bold{u}(k|k) + \cdots + B \bold{u}(k+N-1|k)<br>\end{align*}<br>$$</p><p>左边即为$\bold{X}_k$，然后将右边写成矩阵的形式</p><p>$$<br>\begin{align*}<br>\bold{X}<em>k &amp; &#x3D; \underbrace{\begin{bmatrix}<br>I\<br>A\<br>A^2\<br>\vdots\<br>A^N<br>\end{bmatrix}}</em>{M} \bold{x}<em>k + \underbrace{\begin{bmatrix}<br>0 &amp; 0 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>0 &amp; 0 &amp; \cdots &amp; 0\<br>B &amp; 0 &amp; \cdots &amp; 0\<br>AB &amp; B &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>A^{N-1}B &amp; A^{N-2}B &amp; \cdots &amp; B<br>\end{bmatrix}}</em>{C}\bold{U}_k\<br>\bold{X}_k &amp; &#x3D; M \bold{x}_k + C \bold{U}_k<br>\end{align*}<br>$$</p><p>其中$M$的前$n$行都是$0$。接下来，我们来将代价函数化成QP的形式</p><p>$$<br>\begin{align*}<br>J &amp; &#x3D; \sum^{N-1}<em>{i&#x3D;0} \Big(\bold{x}(k+i|k)^TQ \bold{x}(k+i|k) + \bold{u}(k+i|k)^TR \bold{u}(k+i|k) \Big) + \bold{x}(k+N)^T F \bold{x}(k+N)\<br>&amp; &#x3D; \bold{x}(k|k)^TQ\bold{x}(k|k) + \bold{x}(k+1|k)^TQ\bold{x}(k+1|k) + \cdots + \bold{x}(k+N-1|k)^TQ\bold{x}(k+N-1|k) + \bold{x}(k+N|k)^TQ\bold{x}(k+N|k) \<br>&amp; + \sum^{N-1}</em>{i&#x3D;0}\bold{u}(k+i|k)^TR\bold{u}(k+i|k)\<br>&amp; &#x3D; \begin{bmatrix}<br>\bold{x}(k|k)\<br>\bold{x}(k+1|k)\<br>\vdots\<br>\bold{x}(k+i|k)\<br>\bold{x}(k+N|k)<br>\end{bmatrix}^T \underbrace{\begin{bmatrix}<br>Q &amp; &amp; &amp;&amp;\<br>&amp; Q &amp; &amp; &amp;\<br>&amp; &amp; Q &amp;&amp;\<br>&amp; &amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; &amp; F<br>\end{bmatrix}}<em>{\bar{Q}}\begin{bmatrix}<br>\bold{x}(k|k)\<br>\bold{x}(k+1|k)\<br>\vdots\<br>\bold{x}(k+i|k)\<br>\bold{x}(k+N|k)<br>\end{bmatrix} + \begin{bmatrix}<br>\bold{u}(k|k)\<br>\bold{u}(k+1|k)\<br>\vdots\<br>\bold{u}(k+i|k)\<br>\bold{u}(k+N-1|k)<br>\end{bmatrix}^T \underbrace{\begin{bmatrix}<br>R &amp; &amp; &amp;&amp;\<br>&amp; R &amp; &amp; &amp;\<br>&amp; &amp; R &amp;&amp;\<br>&amp; &amp; &amp; \ddots &amp;\<br>&amp; &amp; &amp; &amp; R<br>\end{bmatrix}}</em>{\bar{R}}\begin{bmatrix}<br>\bold{u}(k|k)\<br>\bold{u}(k+1|k)\<br>\vdots\<br>\bold{u}(k+i|k)\<br>\bold{u}(k+N-1|k)<br>\end{bmatrix}\<br>&amp; &#x3D; \bold{X}_k^T \bar{Q} \bold{X}_k + \bold{U}_k \bar{R} \bold{U}_k<br>\end{align*}<br>$$</p><p>然后再将前面推导的条件带入</p><p>$$<br>\begin{align*}<br>J &amp; &#x3D; \bold{X}_k^T \bar{Q} \bold{X}_k + \bold{U}_k \bar{R} \bold{U}_k\<br>&amp; &#x3D; (M \bold{x}_k + C \bold{U}_k)^T \bar{Q}(M \bold{x}_k + C \bold{U}_k) + \bold{U}_k \bar{R} \bold{U}_k\<br>&amp; &#x3D; \bold{x}_k^TM^T\bar{Q}M\bold{x}_k + \underbrace{\bold{U}_k^TC^T\bar{Q}M\bold{x}_k + \bold{x}<em>k^TM^T\bar{Q}C}</em>{2\bold{x}^TC^T\bar{Q}M\bold{U}_k} \bold{U}_k + \bold{U}_k^TC^T\bar{Q}C \bold{U}_k + \bold{U}_k \bar{R} \bold{U}_k\<br>&amp; &#x3D; \bold{x}_k^TM^T\bar{Q}M\bold{x}_k + 2\bold{x}^TC^T\bar{Q}M\bold{U}_k \bold{U}_k + \bold{U}_k^TC^T\bar{Q}C \bold{U}_k + \bold{U}_k \bar{R} \bold{U}_k<br>\end{align*}<br>$$</p><p>其中$G&#x3D;M^T\bar{Q}M$，$E&#x3D;C^T\bar{Q}M$，$H&#x3D;C^T\bar{R}C+\bar{R}$，那么$J$可以化简为：</p><p>$$<br>J &#x3D; \bold{x}_k^T G \bold{x}_k + 2\bold{U}_k^T E \bold{x}_k  + \bold{U}_k^T H \bold{U}_k<br>$$</p><p>其中$\bold{x}_k^T G \bold{x}_k$是初始状态，是一个常量，在优化的过程中可以忽略。最终的代价函数可以表示为</p><p>$$<br>\min_\bold{U}J &#x3D; \bold{U}_k^T E \bold{x}_k  + 0.5 \times\bold{U}_k^T H \bold{U}_k\<br>G&#x3D;M^T\bar{Q}M\<br>E&#x3D;C^T\bar{Q}M\<br>H&#x3D;C^T\bar{R}C+\bar{R}\<br>\bar{Q} &#x3D; \begin{bmatrix}<br>Q &amp; \cdots &amp;\<br>\vdots &amp; Q &amp; \vdots\<br>&amp; \cdots &amp; F<br>\end{bmatrix}, \bar{R} &#x3D; \begin{bmatrix}<br>R &amp; \cdots &amp;\<br>\vdots &amp; \ddots &amp; \vdots\<br>&amp; \cdots &amp; R<br>\end{bmatrix}<br>$$</p><p>这就是一个标准的QP问题。</p><h2 id="5-MPC总结"><a href="#5-MPC总结" class="headerlink" title="5. MPC总结"></a>5. MPC总结</h2><h3 id="5-1-MPC的优势劣势"><a href="#5-1-MPC的优势劣势" class="headerlink" title="5.1 MPC的优势劣势"></a>5.1 MPC的优势劣势</h3><p>:smile:MPC的<font color=blue>优势</font>在于：</p><ul><li>可以处理多输入多数出的系统（MIMO），PID控制只能在一个PID环内控制一个系统状态，当系统状态相互影响的时候PID控制往往难以设计，MPC就体现出了其优势</li><li>MPC的另一个优势在于可以处理约束条件，约束很重要，因为违反它们会导致不良后果。</li></ul><p>:smile:MPC的<font color=blue>不足</font>在于：</p><ul><li>MPC是在线滚动优化的，所以需要比较强的算力。</li></ul><h3 id="5-2-MPC的衍生算法"><a href="#5-2-MPC的衍生算法" class="headerlink" title="5.2 MPC的衍生算法"></a>5.2 MPC的衍生算法</h3><p>:smile:如何<font color=blue>选择</font>合适的MPC？</p><p><font size="4" color="red"><b>自适应MPC（Adaptive MPC）</b></font></p><p>在自适应MPC 中，线性模型是随着工作条件的变化而动态计算的，并且在每个时间步长，您都可以使用此线性模型更新。MPC控制器使用的内部被控对象模型，请注意，在自适应MPC 中，优化问题的结构在不同的工作点上保持不变。这意味着在预测范围内，状态数量和约束数量不会因不同的操作条件而改变。</p><p><img src="https://pic.imgdb.cn/item/66d2eea2d9c307b7e93b34c6.png" alt="img"></p><p><font size="4" color="red"><b>增益调度MPC（Gain-scheduled MPC）</b></font></p><p>如果它们确实发生了变化，则应使用增益调度MPC。在增益调度MPC 中，您可以在感兴趣的工作点进行离线线性化，并为每个工作点设计一个线性MPC控制器。每个控制器彼此独立，因此可能具有不同数量的状态和不同数量的约束。</p><p><img src="https://pic.imgdb.cn/item/66d2eec3d9c307b7e93b4ce4.png" alt="img"></p><p>小结：</p><p>如果被控对象是非线性的，但可以通过线性模型逼近，则可以使用自适应MPC 控制器和如果被控对象是非线性的且状态的维度和约束的数量会发生变化，那么应该使用增益调度的MPC控制器。如果优化问题的结构在不同的工作条件下没有变化，则应使用自适应 MPC；但是，如果该结构有变化，则使用增益调度 MPC；如果因您有一个无法通过线性化进行良好逼近的高度非线性系统，从而导致以上这些方法都不起作用，则可以使用非线性MPC。具体可以如下图所示：</p><p><img src="https://pic.imgdb.cn/item/66d2eed6d9c307b7e93b5a37.png" alt="img"></p><h2 id="6-示例实现"><a href="#6-示例实现" class="headerlink" title="6. 示例实现"></a>6. 示例实现</h2><p>这个示例系统的状态方程为</p><p>$$<br>\begin{bmatrix}<br>x_1(k+1)\<br>x_2(k+1)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>1 &amp; 0.1\<br>-1 &amp; 2<br>\end{bmatrix}\begin{bmatrix}<br>x_1(k)\<br>x_2(k)<br>\end{bmatrix} + \begin{bmatrix}<br>0.2 &amp; 1\<br>0.5 &amp; 2<br>\end{bmatrix}\begin{bmatrix}<br>u_1(k)\<br>u_2(k)<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>y_1(k)\<br>y_2(k)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>x_1(k)\<br>x_2(k)<br>\end{bmatrix}, \begin{bmatrix}<br>r_1(k)\<br>r_2(k)<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br>0\<br>0<br>\end{bmatrix}<br>$$</p><p>Dr_can提供的<code>matlab/octave</code>示例代码</p><p><code>MPC_Test.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 清屏</span></span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%% 加载 optim package,若使用matlab，则注释掉此行</span></span><br><span class="line">pkg load optim;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 第一步，定义状态空间矩阵</span></span><br><span class="line"><span class="comment">%% 定义状态矩阵 A, n x n 矩阵</span></span><br><span class="line">A=[<span class="number">1</span> <span class="number">0.1</span>; <span class="number">-1</span> <span class="number">2</span>];</span><br><span class="line">n=<span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">%% 定义输入矩阵 B, n x p 矩阵</span></span><br><span class="line">B=[ <span class="number">0.2</span> <span class="number">1</span>; <span class="number">0.5</span> <span class="number">2</span>];</span><br><span class="line">p=<span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%% 定义Q矩阵，n x n 矩阵</span></span><br><span class="line">Q=[<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%% 定义F矩阵，n x n 矩阵</span></span><br><span class="line">F=[<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%% 定义R矩阵，p x p 矩阵</span></span><br><span class="line">R=[<span class="number">1</span> <span class="number">0</span> ;<span class="number">0</span> <span class="number">.1</span>];</span><br><span class="line"><span class="comment">%% 定义step数量k</span></span><br><span class="line">k_steps=<span class="number">100</span>;</span><br><span class="line"><span class="comment">%% 定义矩阵 X_K， n x k 矩 阵</span></span><br><span class="line">X_K = <span class="built_in">zeros</span>(n,k_steps);</span><br><span class="line"><span class="comment">%% 初始状态变量值， n x 1 向量</span></span><br><span class="line">X_K(:,<span class="number">1</span>) =[<span class="number">20</span>;<span class="number">-20</span>];</span><br><span class="line"><span class="comment">%% 定义输入矩阵 U_K， p x k 矩阵</span></span><br><span class="line">U_K=<span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">%% 定义预测区间K</span></span><br><span class="line">N=<span class="number">5</span>;</span><br><span class="line"><span class="comment">%% Call MPC_Matrices 函数 求得 E,H矩阵 </span></span><br><span class="line">[E,H]=MPC_Matrices(A,B,Q,R,F,N);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算每一步的状态变量的值</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line"><span class="comment">%% 求得U_K(:,k)</span></span><br><span class="line">U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);</span><br><span class="line"><span class="comment">%% 计算第k+1步时状态变量的值</span></span><br><span class="line">X_K(:,k+<span class="number">1</span>)=(A*X_K(:,k)+B*U_K(:,k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘制状态变量和输入的变化</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span> :<span class="built_in">size</span> (X_K,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span> (X_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>)</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span> : <span class="built_in">size</span> (U_K,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span> (U_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;u1&quot;</span>,<span class="string">&quot;u2&quot;</span>) </span><br></pre></td></tr></table></figure><p><code>MPC_Matrices.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[E , H]</span>=<span class="title">MPC_Matrices</span><span class="params">(A,B,Q,R,F,N)</span></span></span><br><span class="line">n=<span class="built_in">size</span>(A,<span class="number">1</span>);<span class="comment">% A 是 n x n 矩阵, 得到 n</span></span><br><span class="line">p=<span class="built_in">size</span>(B,<span class="number">2</span>);<span class="comment">% B 是 n x p 矩阵, 得到 p</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%</span></span><br><span class="line">M=[<span class="built_in">eye</span>(n);<span class="built_in">zeros</span>(N*n,n)];<span class="comment">% 初始化 M 矩阵. M 矩阵是 (N+1)n x n的，它上面是 n x n 个 &quot;I&quot;, 这一步先把下半部分写成 0 </span></span><br><span class="line">C=<span class="built_in">zeros</span>((N+<span class="number">1</span>)*n,N*p); <span class="comment">% 初始化 C 矩阵, 这一步令它有 (N+1)n x NP 个 0</span></span><br><span class="line"><span class="comment">% 定义M 和 C </span></span><br><span class="line">tmp=<span class="built_in">eye</span>(n);<span class="comment">%定义一个n x n 的 I 矩阵</span></span><br><span class="line"><span class="comment">%　更新Ｍ和C</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N <span class="comment">% 循环，i 从 1到 N</span></span><br><span class="line"><span class="comment">%定义当前行数，从i x n开始，共n行</span></span><br><span class="line">rows =<span class="built_in">i</span>*n+(<span class="number">1</span>:n);</span><br><span class="line">C(rows,:)=[tmp*B,C(rows-n, <span class="number">1</span>:<span class="keyword">end</span>-p)]; <span class="comment">%将c矩阵填满</span></span><br><span class="line">tmp= A*tmp;<span class="comment">%每一次将tmp左乘一次A</span></span><br><span class="line">M(rows,:)=tmp;<span class="comment">%将M矩阵写满</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义Q_bar和R_bar</span></span><br><span class="line">Q_bar = kron(<span class="built_in">eye</span>(N),Q);</span><br><span class="line">Q_bar = <span class="built_in">blkdiag</span>(Q_bar,F);</span><br><span class="line">R_bar = kron(<span class="built_in">eye</span>(N),R);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算G, E, H</span></span><br><span class="line">G=M&#x27;*Q_bar*M;<span class="comment">% G: n x n</span></span><br><span class="line">E=C&#x27;*Q_bar*M;<span class="comment">% E: NP x n</span></span><br><span class="line">H=C&#x27;*Q_bar*C+R_bar;<span class="comment">% NP x NP </span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Prediction.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u_k</span>= <span class="title">Prediction</span><span class="params">(x_k,E,H,N,p)</span></span></span><br><span class="line">U_k = <span class="built_in">zeros</span>(N*p,<span class="number">1</span>); <span class="comment">% NP x 1</span></span><br><span class="line">U_k = quadprog(H,E*x_k);</span><br><span class="line">u_k = U_k(<span class="number">1</span>:p,<span class="number">1</span>); <span class="comment">% 取第一个结果</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>仿真的结果如下</p><p><img src="https://pic.imgdb.cn/item/66d2eef6d9c307b7e93b6f2e.png" alt="img"></p><p>使用<code>CasaDi Python API</code>重新实现了Dr_can视频里提到的示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> casadi <span class="keyword">as</span> ca</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统参数</span></span><br><span class="line">N = <span class="number">5</span>  <span class="comment"># 预测区间</span></span><br><span class="line">k_steps = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态矩阵A和输入矩阵B</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">0.1</span>], [-<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">B = np.array([[<span class="number">0.2</span>, <span class="number">1</span>], [<span class="number">0.5</span>, <span class="number">2</span>]])</span><br><span class="line">n = A.shape[<span class="number">0</span>]</span><br><span class="line">p = B.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q、F、R矩阵</span></span><br><span class="line">Q = np.diag([<span class="number">100</span>, <span class="number">1</span>])</span><br><span class="line">F = np.diag([<span class="number">100</span>, <span class="number">1</span>])</span><br><span class="line">R = np.diag([<span class="number">1</span>, <span class="number">0.1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义step的数量</span></span><br><span class="line">k_steps = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开辟所有状态x的存储空间并初始状态</span></span><br><span class="line">X_k = np.zeros((n, k_steps+<span class="number">1</span>))</span><br><span class="line">X_k[:,<span class="number">0</span>] = np.array([<span class="number">20</span>,-<span class="number">20</span>])</span><br><span class="line"><span class="comment"># 开辟所有控制输入u的存储空间</span></span><br><span class="line">U_k = np.zeros((p, k_steps))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算QP中代价函数相关的矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_QPMatrix</span>(<span class="params">A, B, Q, R, F, N</span>):</span><br><span class="line">    M = np.vstack([np.eye(n), np.zeros((N*n, n))])</span><br><span class="line">    C = np.zeros(((N+<span class="number">1</span>)*n, N*p))</span><br><span class="line">    temp = np.eye(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        rows = i * n + np.arange(n)</span><br><span class="line">        C[rows,:] = np.hstack([temp @ B, C[rows-n, :-p]])</span><br><span class="line">        temp = A @ temp</span><br><span class="line">        M[rows,:] = temp</span><br><span class="line"></span><br><span class="line">    Q_ = np.kron(np.eye(N), Q)</span><br><span class="line">    rows_Q, cols_Q = Q_.shape</span><br><span class="line">    rows_F, cols_F = F.shape</span><br><span class="line">    Q_bar = np.zeros((rows_Q+rows_F, cols_Q+cols_F))</span><br><span class="line">    Q_bar[:rows_Q, :cols_Q] = Q_</span><br><span class="line">    Q_bar[rows_Q:, cols_Q:] = F</span><br><span class="line">    R_bar = np.kron(np.eye(N), R)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># G = M.T @ Q_bar @ M</span></span><br><span class="line">    E = C.T @ Q_bar @ M</span><br><span class="line">    H = C.T @ Q_bar @ C + R_bar</span><br><span class="line">    <span class="keyword">return</span> E, H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义MPC优化问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mpc_prediction</span>(<span class="params">x_k, E, H, N, p</span>):</span><br><span class="line">    <span class="comment"># 定义优化变量</span></span><br><span class="line">    U = ca.SX.sym(<span class="string">&#x27;U&#x27;</span>, N * p)</span><br><span class="line">    <span class="comment"># 定义目标函数</span></span><br><span class="line">    objective = <span class="number">0.5</span> * ca.mtimes([U.T, H, U]) + ca.mtimes([U.T, E, x_k])</span><br><span class="line">    qp = &#123;<span class="string">&#x27;x&#x27;</span>: U, <span class="string">&#x27;f&#x27;</span>: objective&#125;</span><br><span class="line">    opts = &#123;<span class="string">&#x27;print_time&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;ipopt&#x27;</span>: &#123;<span class="string">&#x27;print_level&#x27;</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line">    solver = ca.nlpsol(<span class="string">&#x27;solver&#x27;</span>, <span class="string">&#x27;ipopt&#x27;</span>, qp, opts)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求解问题</span></span><br><span class="line">    sol = solver()</span><br><span class="line">    <span class="comment"># 提取最优解</span></span><br><span class="line">    U_k = sol[<span class="string">&#x27;x&#x27;</span>].full().flatten()</span><br><span class="line">    u_k = U_k[:p]  <span class="comment"># 取第一个结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u_k</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Get QP Matrix</span></span><br><span class="line">    E, H = get_QPMatrix(A, B, Q, R, F, N)</span><br><span class="line">    <span class="comment"># Simulation</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_steps):</span><br><span class="line">        x_k = X_k[:,i]</span><br><span class="line">        u_k = mpc_prediction(x_k, E, H, N, p)</span><br><span class="line">        x_k = A @ x_k + B @ u_k</span><br><span class="line">        X_k[:,i+<span class="number">1</span>] = x_k</span><br><span class="line">        U_k[:,i] = u_k</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制结果</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_k.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.plot(X_k[i, :], label=<span class="string">f&quot;x<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.title(<span class="string">&quot;State Variables&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;Time Step&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;State Value&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二个子图: 控制输入</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(U_k.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.plot(U_k[i, :], label=<span class="string">f&quot;u<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.title(<span class="string">&quot;Control Inputs&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;Time Step&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;Control Value&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调整布局并显示</span></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66d2ef0ed9c307b7e93b80b0.png" alt="img"></p><p>结果如下</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="https://www.bilibili.com/video/BV11B4y1X78N/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">MPC模型预测控制器</a><br>[2]<a href="https://www.youtube.com/watch?v=8U0xiOkDcmw&list=PLn8PRpmsu08ozoeoXgxPSBKLyd4YEHww8">Understanding Model Predictive Control</a><br>[3]<a href="https://github.com/tomcattiger1230/CasADi_MPC_MHE_Python/tree/master">CasADi_MPC_MHE_Python</a><br>[4]<a href="https://github.com/MMehrez/MPC-and-MHE-implementation-in-MATLAB-using-Casadi/tree/master">MPC-and-MHE-implementation-in-MATLAB-using-Casadi</a><br>[5]<a href="https://www.youtube.com/playlist?list=PLK8squHT_Uzej3UCUHjtOtm5X7pMFSgAL">MPC and MHE implementation in Matlab using Casadi</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制理论 </tag>
            
            <tag> 模型预测控制 </tag>
            
            <tag> MPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制障碍函数CBF详解（附带案例实现）</title>
      <link href="/2024/02/21/%E6%8E%A7%E5%88%B6%E9%9A%9C%E7%A2%8D%E5%87%BD%E6%95%B0CBF%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2024/02/21/%E6%8E%A7%E5%88%B6%E9%9A%9C%E7%A2%8D%E5%87%BD%E6%95%B0CBF%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E5%B8%A6%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="控制障碍函数CBF详解（附带案例实现）"><a href="#控制障碍函数CBF详解（附带案例实现）" class="headerlink" title="控制障碍函数CBF详解（附带案例实现）"></a>控制障碍函数CBF详解（附带案例实现）</h1><h2 id="1-Control-Affine-System"><a href="#1-Control-Affine-System" class="headerlink" title="1. Control Affine System"></a>1. Control Affine System</h2><p>一个控制仿射系统的典型形式是</p><p>$$<br>\dot{x} &#x3D; F(x,u)<br>$$</p><p>其中，$x\in \mathbb{R}^n$是系统的状态，$u\in\mathbb{R}^m$是系统的控制输入，$F$是Lipschitz连续的，这样就能保证给定一个初始状态$x(t_0)&#x3D;x_0$的时候，动态系统的轨迹$x(t)$存在且唯一。</p><p>我们通常处理的是非线性系统，那么我们可以将非线性的仿射系统写成如下的形式</p><p>$$<br>\dot{x} &#x3D; f(x) + g(x) u<br>$$</p><p>其中$f:\mathbb{R}^n \to \mathbb{R}^n$是系统的漂移向量场，它描述了系统在没有控制输入时的动态行为，$g:\mathbb{R}^n\to\mathbb{R}^{n\times m}$，是系统的控制向量场，它描述了系统的控制输入$u$是如何影响系统的。</p><h2 id="2-Lyapunov-Theory-Nagumo’s-Theory-Invariance-Principle"><a href="#2-Lyapunov-Theory-Nagumo’s-Theory-Invariance-Principle" class="headerlink" title="2. Lyapunov Theory, Nagumo’s Theory, Invariance Principle"></a>2. Lyapunov Theory, Nagumo’s Theory, Invariance Principle</h2><p><strong>Lyapunov Theory</strong></p><p>对于系统$\dot{x}&#x3D;f(x)$而言，$x\in \mathbb{R}^n$是系统的状态，$f:\mathbb{R}^n \to \mathbb{R}^n$是一个系统状态的映射函数。如果</p><p>$$<br>\exists V(x)\<br>\text{s.t. } V(x_e) &#x3D; 0, V(x)&gt;0 \text{ for } x \ne x_e,\<br>\dot{V}(x) &#x3D; \frac{\partial V}{\partial x} f(x) &lt; 0 \text{ for } x\ne x_e<br>$$</p><p>那么系统则是稳定的。并且状态$x$所构成的集合，可以被称为是一个不变集（Invariance set）。</p><p><strong>不变集合：</strong> 集合$\mathcal{C}$被称为不变的，如果系统从$\mathcal{C}$内的任意一点开始演化，那么系统的轨迹始终停留在$\mathcal{C}$内。</p><p><strong>Nagumo’s Theory</strong></p><p>对于系统$\dot{x} &#x3D; f(x)$而言，$x\in \mathbb{R}^n$是系统的状态，$\mathcal{C}&#x3D;{x|h(x)\ge0}$是映射$h:\mathbb{R}^n \to \mathbb{R}$的一个上水平集，如果</p><p>$$<br>\dot{h}(x) \ge 0\<br>\forall x\in\partial\mathcal{C}<br>$$</p><p>那么$\mathcal{C}$是一个不变集。符号的具体含义如下：</p><p>$$<br>\begin{align*}<br>    \mathcal{C} &amp; &#x3D; { x\in D\sub \mathbb{R}^n: h(x) \ge 0 },\<br>    \partial\mathcal{C} &amp; &#x3D; { x\in D\sub \mathbb{R}^n: h(x) &#x3D; 0 }, \<br>    \text{Int}(\mathcal{C}) &amp; &#x3D; { x\in D\sub \mathbb{R}^n: h(x) &gt; 0 },<br>\end{align*}<br>$$</p><p>集合$\mathcal{C}$是安全集，$\partial\mathcal{C}$是安全集的边界，$\text{Int}(\mathcal{C})$是安全集的内部点。</p><h2 id="3-Control-Lyapunov-Function-CLF-and-CLF-QP"><a href="#3-Control-Lyapunov-Function-CLF-and-CLF-QP" class="headerlink" title="3. Control Lyapunov Function (CLF) and CLF-QP"></a>3. Control Lyapunov Function (CLF) and CLF-QP</h2><p><strong>Control Lyapunov Function</strong></p><p>设$V(x):\mathbb{R}^n \to \mathbb{R}$是一个连续可微的函数，如果这里存在一个常量$c&gt;0$使得</p><p>$$<br>\begin{align*}<br>&amp; \text{1) }\Omega_c :&#x3D; { x\in\mathbb{R}^n: V(x) \le c}, \text{ a sublevel set of } V(x) \text{ is bounded}\<br>&amp; \text{2) }V(x)  &gt; 0, \forall s \in\mathbb{R}^n \backslash {x_e}, V(x_e) &#x3D; 0\<br>&amp; \text{3) }\inf_{u\in U} \dot{V}(x,u)  &lt; 0, \forall x \in \Omega_c \backslash {x_e}<br>\end{align*}<br>$$</p><p>1）存在一个子集，使得$V(x)\le c$是有界的</p><p>2）Lyapunov函数不在原点时大于零，在原点时等于零</p><p>3）对于控制量和系统状态来说，总使得$V(x)$的导数$\dot{V}(x)$小于零。</p><p>其中，$V(x)$可以被称为局部控制李雅普诺夫函数，$\Omega_c$是一个引力区（Region of Attraction, ROA），$\Omega_c$中的每一个点都会收敛到$x_e$，整个轨迹就如下图所示，会一直保持在这个区域内，并且最终收敛到$x_e$，这其实就是一种渐进稳定。</p><p><img src="https://pic.imgdb.cn/item/66d2b31dd9c307b7e9ea5788.png" alt="img"></p><p>我们可以将导数显示地写出来</p><p>$$<br>\begin{align*}<br>\dot{V}(x) &amp; &#x3D; \nabla V(x) \dot{x}\<br>&amp; &#x3D; \nabla V(x)f(x) + \nabla V(x)g(x)u\<br>&amp; &#x3D; L_fV(x) + L_g V(x) u<br>\end{align*}<br>$$</p><p>其中$L_p q(x) &#x3D; \nabla q(x) \cdot p(x)$是李导数算子，使得公式更加简洁。</p><p>为了使收敛更加迅速，我们需要考虑收敛的时间限制，指数收敛是一种快速的方式，所以我们希望最终的结果能够按照指数的方式进行收敛。</p><p>我们可以增加一个判断条件，设$V(x):\mathbb{R}^n \to \mathbb{R}$是连续可微、正定、有界的函数，如果$\exists \lambda&gt;0$使得</p><p>$$<br>\text{4) }\inf_{u\in U} \dot{V}(x,u) + \lambda V(x) \le 0<br>$$</p><p>或者写成</p><p>$$<br>\inf_{u\in U} [L_f V(x) + L_gV(x)u] + \lambda V(x) \le 0<br>$$</p><p>那么$V(x)$就是指数稳定的控制李雅普诺夫函数（exponentially stabilizing CLF，ES-CLF），其中$\lambda$是$V(x(t))$上界的衰减率。</p><p><img src="https://pic.imgdb.cn/item/66d2b481d9c307b7e9eddffb.png" alt="img"></p><p><strong>Control Lyapunov Function  Quadratic Program</strong></p><p><img src="https://pic.imgdb.cn/item/66d2b493d9c307b7e9ee1147.png" alt="img"></p><p>CLF约束对于$u$是线性的，因此用最小范数控制器，二次规划的目标位最小化控制量，受限制为，满足李雅普诺夫函数收敛的上界以及控制量 $u$在解集内。由于这个优化为一个凸优化问题，因此其实时性是可以被保证的，CLF约束通常用松弛变量来保证问题的可行性，如果没有松弛变量，控制器将指数稳定到系统原点$x_e$</p><h2 id="4-Control-Barrier-Function-CBF-and-CBF-CLF-QP"><a href="#4-Control-Barrier-Function-CBF-and-CBF-CLF-QP" class="headerlink" title="4. Control Barrier Function (CBF) and CBF-CLF-QP"></a>4. Control Barrier Function (CBF) and CBF-CLF-QP</h2><p>设$B(x):\mathbb{R}^n \to \mathbb{R}$是连续、可微的函数，$\mathcal{C}&#x3D;{x|B(x)\ge 0}$是该函数的零上水平集，并且$\nabla B(x)\ne 0,\forall x\in\partial\mathcal{C}$，如果$\exists \gamma$使得$\forall x\in\mathcal{C}$</p><p>$$<br>\sup_{u \in U}[L_fB(x) + L_g B(x)u] + \gamma B(x) \ge 0<br>$$</p><p>那么$B(x)$就被称作Control Barrier Function</p><p><img src="https://pic.imgdb.cn/item/66d2b4a8d9c307b7e9ee4dd5.png" alt="img"></p><p>因此这个二次规划问题就变成了</p><p><img src="https://pic.imgdb.cn/item/66d2b4c1d9c307b7e9ee98ff.png" alt="img"></p><h2 id="5-A-Toy-Example"><a href="#5-A-Toy-Example" class="headerlink" title="5. A Toy Example"></a>5. A Toy Example</h2><p>我们考虑一个简单的例子，在这个例子中有两辆车辆，分别是<code>lead vehicle</code>和<code>ego vehicle</code>，如下图所示</p><p><img src="https://pic.imgdb.cn/item/66d2b4d7d9c307b7e9eeca7a.png" alt="img"></p><p>下面我们先推导一下，然后再进行仿真验证。</p><h3 id="5-1-Derivation"><a href="#5-1-Derivation" class="headerlink" title="5.1 Derivation"></a>5.1 Derivation</h3><p>设计我们的状态量为：$x &#x3D; [p, v, z]^T \in \mathbb{R}^3$，系统的微分方程为：</p><p>$$<br>\begin{align*}<br>    \dot{p} &amp; &#x3D; v\<br>    \dot{v} &amp; &#x3D; \frac{u - F_r(v)}{m}, \quad F_r(v) &#x3D; f_0 + f_1 v + f_2 v^2 \<br>    \dot{z} &amp; &#x3D; v_0 - v<br>\end{align*}<br>$$</p><p>其中<code>F_r(v)</code>是摩擦力，将微分方程写成矩阵的形式</p><p>$$<br>\dot{x} &#x3D;<br>\begin{bmatrix}<br>    \dot{p}\<br>    \dot{v} \<br>    \dot{z}\<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>    v\<br>    -\frac{1}{m} F_r(v)\<br>    v_0 - v<br>\end{bmatrix} +<br>\begin{bmatrix}<br>    0\<br>    \frac{1}{m}\<br>    0<br>\end{bmatrix} u<br>$$</p><p>为了保障系统的安全性，给系统的输入做如下的限制</p><p>$$<br>-mc_dg \le u \le mc_ag<br>$$</p><p><code>ego vehicle</code>的目标速度为</p><p>$$<br>v \to v_d<br>$$</p><p>最小安全距离必须满足时间前瞻量的限制$T_h$</p><p>$$<br>z \ge T_h v<br>$$</p><p>系统的平衡点$x_e &#x3D; [\cdot, v_d, \cdot]^T$设计Lyapunov Function $V(x)$</p><p>$$<br>\begin{align*}<br>    V(x) &amp; &#x3D; (v - v_d)^2\<br>    \dot{V}(x) &amp; &#x3D; \nabla V(x) \dot{x}\<br>\end{align*}<br>$$</p><p>其中</p><p>$$<br>\nabla V(x) &#x3D; [0, 2(v-v_d), 0]\<br>\dot{x} &#x3D;<br>\begin{bmatrix}<br>    v\<br>    -\frac{1}{m} F_r(v)\<br>    v_0 - v<br>\end{bmatrix} +<br>\begin{bmatrix}<br>    0\<br>    \frac{1}{m}\<br>    0<br>\end{bmatrix}u<br>$$</p><p>然后我们可以获得</p><p>$$<br>L_f V(x) &#x3D; -\frac{2}{m} F_r(v)(v-v_d)\<br>L_g V(x) &#x3D; \frac{2}{m} (v-v_d)<br>$$</p><p>所以CLF的约束$\inf_{u\in U} \quad[L_f V(x) + L_g V(x)u] + \lambda V(x) \le 0$可以表示为</p><p>$$<br>\inf_{u\in U} \quad(v-v_d) [\frac{2}{m} (u-F_r) + \lambda (v-v_d)] \le 0<br>$$</p><p>保障安全性的目标是$z\ge T_h V$，则设计CBF</p><p>$$<br>B(x) &#x3D; z - T_h V<br>$$</p><p>则有</p><p>$$<br>\nabla B(x) &#x3D; [0, -T_h, 1]\<br>L_f B(x) &#x3D; \frac{T_h}{m} F_r + (v_0 - v), \quad L_g B(x) &#x3D; -\frac{T_h}{m}<br>$$</p><p>所以CBF的约束$\sup_{u\in U} \quad [L_f B(x) + L_g B(x)u] + \gamma B(x) \ge 0$ 可以表示为</p><p>$$<br>\frac{T_h}{m}(F_r - u) + (v_0 - v) + \gamma (z - T_h v) \ge 0<br>$$</p><p>忽略$F_r$，当$u&#x3D;-mc_dg$的时候，CBF的约束可以表示为</p><p>$$<br>T_h c_d g + v_0 + \gamma z - (1+T_h \gamma)v<br>$$</p><p>当$v$足够大的时候，可能会导致CBF的约束小于0，所以我们需要重新设计CBF</p><p>$$<br>B(x) &#x3D; z - T_hv - \textcolor{blue}{\frac{1}{2} \frac{(v-v_0)^2}{c_dg}}<br>$$</p><p>则有</p><p>$$<br>\dot{B}(x,u) &#x3D; \frac{1}{m} (T_h + \textcolor{blue}{\frac{v-v_0}{c_dg}})(F_r(v) - u) + (v_0 - v)<br>$$</p><p>当$u&#x3D;-mc_dg$的时候，$\dot{B}(x,u) &#x3D; \frac{1}{m}T_h F_r + T_h c_dg &gt; 0$，所以此CBF是一个可行的CBF，那么我们最终获得的CLF-CBF-QP为</p><p>$$<br>\begin{align*}<br>    \arg\min &amp; \quad u^T Hu\<br>    \text{s.t.} &amp; \quad (v-v_d)[\frac{2}{m}(u-F_r) + \lambda(v-v_d)]\le 0\<br>    &amp; \quad \frac{1}{m}(T_h + \frac{(v-v_0)}{c_d g})(F_r - u) + (v_0 - v) + \gamma (z - T_h v) \ge 0\<br>    &amp; \quad -m c_d g \le u \le m c_a g<br>\end{align*}<br>$$</p><h3 id="5-2-Simulation"><a href="#5-2-Simulation" class="headerlink" title="5.2 Simulation"></a>5.2 Simulation</h3><p>使用python来编写脚本代码，使用<code>cvxopt</code>凸优化的库来进行求解，具体可以参考<a href="https://cvxopt.org/">cvxopt的wiki官网</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> cvxopt <span class="keyword">import</span> matrix, solvers</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulation parameters</span></span><br><span class="line">dt = <span class="number">0.02</span></span><br><span class="line">T = <span class="number">30</span></span><br><span class="line">length = <span class="built_in">int</span>(np.ceil(T / dt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># System initialization</span></span><br><span class="line">p = np.zeros((length + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">v = np.zeros((length + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">z = np.zeros((length + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">u = np.zeros((length, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">sys = &#123;</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span>: <span class="number">1650</span>,</span><br><span class="line">    <span class="string">&#x27;g&#x27;</span>: <span class="number">9.81</span>,</span><br><span class="line">    <span class="string">&#x27;v0&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="string">&#x27;vd&#x27;</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="string">&#x27;f0&#x27;</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&#x27;f1&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;f2&#x27;</span>: <span class="number">0.25</span>,</span><br><span class="line">    <span class="string">&#x27;ca&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;cd&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>: <span class="number">1.8</span>,</span><br><span class="line">    <span class="string">&#x27;clf_rate&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;cbf_rate&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;weight_input&#x27;</span>: <span class="number">2</span> / <span class="number">1650</span>**<span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;weight_slack&#x27;</span>: <span class="number">2e-2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sys[<span class="string">&#x27;u_max&#x27;</span>] = sys[<span class="string">&#x27;ca&#x27;</span>] * sys[<span class="string">&#x27;m&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">sys[<span class="string">&#x27;u_min&#x27;</span>] = -sys[<span class="string">&#x27;cd&#x27;</span>] * sys[<span class="string">&#x27;m&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial conditions</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">v[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">z[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulation loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    current_p = p[i, <span class="number">0</span>]</span><br><span class="line">    current_v = v[i, <span class="number">0</span>]</span><br><span class="line">    current_z = z[i, <span class="number">0</span>]</span><br><span class="line">    x = np.array([current_p, current_v, current_z])</span><br><span class="line">    </span><br><span class="line">    F_r = sys[<span class="string">&#x27;f0&#x27;</span>] + sys[<span class="string">&#x27;f1&#x27;</span>] * current_v + sys[<span class="string">&#x27;f2&#x27;</span>] * current_v**<span class="number">2</span></span><br><span class="line">    f = np.array([current_v, -F_r / sys[<span class="string">&#x27;m&#x27;</span>], sys[<span class="string">&#x27;v0&#x27;</span>] - current_v])</span><br><span class="line">    g = np.array([<span class="number">0</span>, <span class="number">1</span> / sys[<span class="string">&#x27;m&#x27;</span>], <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    V = (current_v - sys[<span class="string">&#x27;vd&#x27;</span>])**<span class="number">2</span></span><br><span class="line">    dV = np.array([<span class="number">0</span>, <span class="number">2</span> * (current_v - sys[<span class="string">&#x27;vd&#x27;</span>]), <span class="number">0</span>])</span><br><span class="line">    LfV = np.dot(dV, f)</span><br><span class="line">    LgV = np.dot(dV, g)</span><br><span class="line">    B = current_z - sys[<span class="string">&#x27;T&#x27;</span>] * current_v - <span class="number">0.5</span> * (current_v - sys[<span class="string">&#x27;v0&#x27;</span>])**<span class="number">2</span> / (sys[<span class="string">&#x27;cd&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">    dB = np.array([<span class="number">0</span>, -sys[<span class="string">&#x27;T&#x27;</span>] - (current_v - sys[<span class="string">&#x27;v0&#x27;</span>]) / (sys[<span class="string">&#x27;cd&#x27;</span>] * sys[<span class="string">&#x27;g&#x27;</span>]), <span class="number">0</span>])</span><br><span class="line">    LfB = np.dot(dB, f)</span><br><span class="line">    LgB = np.dot(dB, g)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Quadratic program</span></span><br><span class="line">    H_ = np.array([[sys[<span class="string">&#x27;weight_input&#x27;</span>], <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">0</span>, sys[<span class="string">&#x27;weight_slack&#x27;</span>]]])</span><br><span class="line">    f_ = np.array([-sys[<span class="string">&#x27;weight_input&#x27;</span>] * F_r, <span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    A_ = np.array([[LgV, -<span class="number">1</span>], </span><br><span class="line">                   [-LgB, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                   [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    b_ = np.array([-LfV - sys[<span class="string">&#x27;clf_rate&#x27;</span>] * V, </span><br><span class="line">                   LfB + sys[<span class="string">&#x27;cbf_rate&#x27;</span>] * B,</span><br><span class="line">                   sys[<span class="string">&#x27;u_max&#x27;</span>],</span><br><span class="line">                   -sys[<span class="string">&#x27;u_min&#x27;</span>]])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Convert to cvxopt format</span></span><br><span class="line">    P = matrix(H_)</span><br><span class="line">    q = matrix(f_)</span><br><span class="line">    G = matrix(A_)</span><br><span class="line">    h = matrix(b_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve QP problem using cvxopt</span></span><br><span class="line">    sol = solvers.qp(P, q, G, h)</span><br><span class="line">    u_opt = sol[<span class="string">&#x27;x&#x27;</span>][<span class="number">0</span>] <span class="comment"># Second term is the slack variable</span></span><br><span class="line"></span><br><span class="line">    dx = f + g * u_opt</span><br><span class="line">    x_n = x + dx * dt</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save data</span></span><br><span class="line">    u[i, <span class="number">0</span>] = u_opt</span><br><span class="line">    <span class="keyword">if</span> i &lt; length:</span><br><span class="line">        p[i + <span class="number">1</span>, <span class="number">0</span>] = x_n[<span class="number">0</span>]</span><br><span class="line">        v[i + <span class="number">1</span>, <span class="number">0</span>] = x_n[<span class="number">1</span>]</span><br><span class="line">        z[i + <span class="number">1</span>, <span class="number">0</span>] = x_n[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plotting</span></span><br><span class="line">time = np.arange(<span class="number">0</span>, T + dt, dt)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(time, p)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time, v)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(time, z)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">plt.plot(time[:-<span class="number">1</span>], u)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time (s)&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最后的结果如下</p><p><img src="https://pic.imgdb.cn/item/66d2b4f7d9c307b7e9ef2b78.png" alt="img"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="https://www.youtube.com/watch?v=_Tkn_Hzo4AA&t=3550s">Jason Choi – Introduction to Control Lyapunov Functions and Control Barrier Functions</a><br>[2]<a href="https://github.com/HybridRobotics/CBF-CLF-Helper">CBF-CLF-Helper</a></p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制理论 </tag>
            
            <tag> 控制障碍函数 </tag>
            
            <tag> CBF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Algo学习笔记 1. 复杂度分析 + 栈</title>
      <link href="/2024/01/18/Hello-Algo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/18/Hello-Algo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-Algo学习笔记-1-复杂度分析-栈"><a href="#Hello-Algo学习笔记-1-复杂度分析-栈" class="headerlink" title="Hello Algo学习笔记 1. 复杂度分析 + 栈"></a>Hello Algo学习笔记 1. 复杂度分析 + 栈</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>​递归 recursion 和常用的循环迭代不一样，这种策略算法通过调用自身来解决问题，它主要包含两个方面：</p><ol><li>递：程序不断深入调用自身，通常传入更下或更简化的参数，直到达到“终止条件”</li><li>归：出发“终止条件”之后，程序从最深处开始逐层返回，并且汇聚每一层的结果。</li></ol><p>从实现的角度来说，设计递归算法主要需要三个主要的条件</p><ol><li>终止条件：什么条件下终止“递”，从而开始“归”</li><li>递归调用：对应“递”，函数里应该不断调用自身，通常传入更小的参数</li><li>返回递归的结果：对应“归”，将当前递归层级的结果返回到上一级中。</li></ol><p>虽然从计算的角度来看，迭代与递归可以获得相类似的结果，但是它们是两种完全不同的思考和解决问题的范式。</p><ul><li>迭代：“自下而上”地解决问题，从基础的步骤开始，然后不断重复或者累加这些步骤，直到完成任务。</li><li>递归：”自上而下“地解决问题，如果问题和其子问题具有相同的形式，将原问题拆分为更小的部分，通过确定终止条件和返回结果来完成递归的调用。</li></ul><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>​递归函数每次调用自身的时候，系统都会为其开启新的函数分配内存，来存储局部变量、调用地址和其他信息，这就会导致递归比迭代更消耗内存空间。</p><ul><li>函数的上下文数据都存储在称为”栈帧空间“的内存区域中，直到函数返回之后才会被释放。</li><li>递归函数会产生额外的开销。因此递归通常比循环的时间效率更低。</li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>​如果函数在返回前的最后一步才进行递归调用，则这种递归就被称为<strong>尾递归 tail recursion</strong>，这种尾递归可以通过编译器来实现自动优化，递归和迭代的特点对比如下：</p><table><thead><tr><th align="left"></th><th align="left">迭代</th><th align="left">递归</th></tr></thead><tbody><tr><td align="left">实现方式</td><td align="left">循环结构</td><td align="left">函数调用自身</td></tr><tr><td align="left">时间效率</td><td align="left">效率通常较高，无函数调用开销</td><td align="left">每次函数调用都会产生开销</td></tr><tr><td align="left">内存使用</td><td align="left">通常使用固定大小的内存空间</td><td align="left">累积函数调用可能使用大量的栈帧空间</td></tr><tr><td align="left">适用问题</td><td align="left">适用于简单循环任务，代码直观、可读性好</td><td align="left">适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td></tr></tbody></table><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>​我们常说的时间复杂度，其实是指算法的渐进上界，其数学定义如下：</p><p>若存在正实数$c$和实数$n_0$，使得对于所有的$n&gt; n_0$，均有$T(n)\le c \cdot f(n)$，则可以认为$f(n)$给出了$T(n)$的一个渐进上界，记为$T(n)&#x3D;O(f(n))$。</p><p>计算渐进上界其实就是寻找一个函数$f(n)$，使得当$n$趋于$\infty$的时候，$T(n)$和$f(n)$处于相同的增长级别。</p><p>​计算时间复杂度，可以遵循下列的计算技巧：</p><ul><li>忽略$T(n)$中的常数项，因为常数项对时间复杂度都不产生影响</li><li>省略所有系数</li><li>循环嵌套的时候使用乘法</li><li>时间复杂度由$T(n)$中的最高阶项来决定</li></ul><p>常见的时间复杂度类型有：<br>$$<br>O(1) &lt; O(\log n) &lt; O(n) &lt; O(n\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)<br>$$<br>指数阶对应的是每次增加一倍的情况，类似与”细胞分裂“的过程，而对数阶对应的是每次缩减一倍的情况。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>​空间复杂度的推算方法与时间复杂度大致相同，只是将统计的对象从“操作数”变为了“使用内存大小”，与时间复杂度不同，我们只需要关注于最差空间复杂度，因为内存空间是一项硬性要求，我们必须确保所有的输入数据都有足够的内存空间预留。最差空间复杂度表示以算法运行中的峰值内存为准。</p><h2 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h2><p>原码、反码和补码的引入都为了加速计算机的运算，所有的数字都是以“补码”的形式存储在计算机中的，三者的定义如下：</p><ul><li>原码 sign-magnitude：将数字的最高位视为符号位，用0表示正数，1表示负数，其余的位置用于存放数字</li><li>反码 1’s complement：除了最高位符号位不变，其余位置均取反</li><li>补码 2’s complement：将反码+1</li></ul><p>出现反码的原因是计算为了方便计算减法，直接使用反码相加就能够同时计算加法和减法；为了解决0在存储的过程中出现+0和-0的区别，使用补码来让0的补码也是0，消除了零正负奇异的问题。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组array是一种线性的数据结构，其将相同类型的数据存储在连续的内存空间当中，我们将元素在数组中的位置称为该元素的索引index，索引本质上是<strong>内存地址的偏移量</strong>，所以数组中的第一个元素的索引是0。由于索引的设计，我们访问数组中的任意一个元素的时间复杂度为$O(1)$。<strong>数组支持随机访问</strong>。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表linked list是一种线性数据结构，其中每一个元素都是一个节点，各个节点通过“引用”（指针）相连接，引用记录了下一个节点的物理地址。链表的设计使得其可以分散在内存的各处，并且它们的内存地址无须连续。</p><p>用python实现链表的Node：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val<span class="comment">#当前节点值</span></span><br><span class="line">        self.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span> <span class="comment">#指向下一个节点的指针</span></span><br></pre></td></tr></table></figure><p><strong>链表不支持随机访问</strong>，访问元素的时间复杂度为$O(n)$。</p><p>表 4-1  数组与链表的效率对比</p><table><thead><tr><th align="left"></th><th align="left">数组</th><th align="left">链表</th></tr></thead><tbody><tr><td align="left">存储方式</td><td align="left">连续内存空间</td><td align="left">分散内存空间</td></tr><tr><td align="left">容量扩展</td><td align="left">长度不可变</td><td align="left">可灵活扩展</td></tr><tr><td align="left">内存效率</td><td align="left">元素占用内存少、但可能浪费空间</td><td align="left">元素占用内存多</td></tr><tr><td align="left">访问元素</td><td align="left">$O(1)$</td><td align="left">$O(n)$</td></tr><tr><td align="left">添加元素</td><td align="left">$O(n)$</td><td align="left">$O(1)$</td></tr><tr><td align="left">删除元素</td><td align="left">$O(n)$</td><td align="left">$O(n)$</td></tr></tbody></table><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈stack是一种先进后出的数据结构，栈一般包括如下的一些操作：</p><p>表 5-1  栈的操作效率</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push()</code></td><td align="left">元素入栈（添加至栈顶）</td><td align="left">$O(1)$</td></tr><tr><td align="left"><code>pop()</code></td><td align="left">栈顶元素出栈</td><td align="left">$O(1)$</td></tr><tr><td align="left"><code>peek()</code></td><td align="left">访问栈顶元素</td><td align="left">$O(1)$</td></tr></tbody></table><p>栈的实现有几种方式，第一种是基于链表的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于链表的栈实现&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._peek: LinkNode | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">        self._size: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._peek</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;栈为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._peek.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        node = LinkNode(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self._peek</span><br><span class="line">        self._peek = node</span><br><span class="line">        self._size += <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        val = self.peek()</span><br><span class="line">        self._peek = self._peek.<span class="built_in">next</span></span><br><span class="line">        self._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;转换成list方便调试&quot;&quot;&quot;</span></span><br><span class="line">        arr = []</span><br><span class="line">        node = self._peek</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            arr.append(node.val)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> arr.reverse()</span><br></pre></td></tr></table></figure><p>第二种是基于列表的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._stack: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self._stack == []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item: <span class="built_in">int</span></span>):</span><br><span class="line">        self._stack.append(item)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;栈为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._stack.pop()</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empy():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;栈为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._stack[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self._stack</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.hello-algo.com/">Hello算法</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Data Structure </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客 教程(三)客制化butterfly主题</title>
      <link href="/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%89-%E5%AE%A2%E5%88%B6%E5%8C%96butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%89-%E5%AE%A2%E5%88%B6%E5%8C%96butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-Hexo-Github-Build-Your-Blog-教程-三-客制化butterfly主题"><a href="#Use-Hexo-Github-Build-Your-Blog-教程-三-客制化butterfly主题" class="headerlink" title="Use Hexo + Github Build Your Blog 教程(三)客制化butterfly主题"></a>Use Hexo + Github Build Your Blog 教程(三)客制化butterfly主题</h1><h2 id="参考官方的配置教程"><a href="#参考官方的配置教程" class="headerlink" title="参考官方的配置教程"></a>参考官方的配置教程</h2><p>每个主题都有自己的配置方法，官方都有详细的说明，可以参考官方的说明文档。这里以博主使用的<code>butterfly</code>主题为例。<code>butterfly</code>的官方配置教程在这里<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>我们的大部分修改要在主题文件的<code>_config.yml</code>和hexo目录中的<code>_config.yml</code>文件中进行。</p><h2 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h2><p>在<code>_config.yml</code>中找到字段<code>Site</code>，修改基本信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">网站的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">网站作者名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># en # zh-TW</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>在<code>themes/butterfly/_config.yml</code>进行修改，具体的修改方式可以参考官方的说明文档<a href="https://butterfly.js.org/">https://butterfly.js.org/</a>。这里不再赘述了。</p><h2 id="为butterfly主题添加Gitalk评论功能"><a href="#为butterfly主题添加Gitalk评论功能" class="headerlink" title="为butterfly主题添加Gitalk评论功能"></a>为butterfly主题添加Gitalk评论功能</h2><p>使用gitalk评论系统，原因是因为它可以直接在github上管理评论，不需要在别的平台注册，并且有github的背书，所以安全性更高。</p><h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><p>点开Github头像，点击<code>Settings</code>，然后点击<code>Developer settings</code>，再点<code>OAuth Apps</code>，然后点击<code>New OAuth App</code>。</p><p>填写相关信息，注意<code>Homepage URL</code>和<code>Authorization callback URL</code>要填写博客的地址。</p><img src="https://pic.imgdb.cn/item/658ce904c458853aefb3205f.jpg" class="" title="注册OAuth Application"><img src="https://pic.imgdb.cn/item/658ce99dc458853aefb4ba76.jpg" class="" title="Client ID"><h3 id="配置Gitalk"><a href="#配置Gitalk" class="headerlink" title="配置Gitalk"></a>配置Gitalk</h3><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>comments</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span></span><br><span class="line">  <span class="attr">use:</span>  <span class="string">Gitalk</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><p>然后找到<code>gitalk</code>字段，修改如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitalk</span></span><br><span class="line"><span class="comment"># https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxxxxxxxxxxx</span> <span class="string">your</span> <span class="string">client</span> <span class="string">id</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxxxxxxxxxxxxxxxxxx</span> <span class="string">your</span> <span class="string">client</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">shenmuxin.github.io</span> <span class="comment"># 博客的仓库名称(注意不是地址)</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">shenmuxin</span> <span class="comment"># github用户名</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">shenmuxin</span> <span class="comment"># github用户名</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>这样就成功配置了<code>Gitalk</code>，效果如下</p><img src="https://pic.imgdb.cn/item/658ceac7c458853aefb81024.jpg" class="" title="Gitalk效果"><h2 id="为butterfly配置加载动画preloader"><a href="#为butterfly配置加载动画preloader" class="headerlink" title="为butterfly配置加载动画preloader"></a>为butterfly配置加载动画preloader</h2><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>preloader</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loading Animation (加載動畫)</span></span><br><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source</span></span><br><span class="line">  <span class="comment"># 1. fullpage-loading</span></span><br><span class="line">  <span class="comment"># 2. pace (progress bar)</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># pace theme (see https://codebyzach.github.io/pace/)</span></span><br><span class="line">  <span class="attr">pace_css_url:</span></span><br></pre></td></tr></table></figure><h2 id="为butterfly配置打字副标题"><a href="#为butterfly配置打字副标题" class="headerlink" title="为butterfly配置打字副标题"></a>为butterfly配置打字副标题</h2><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>subtitle</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主頁subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js (配置typed.js)</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span></span><br><span class="line">  <span class="comment"># source 調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  調用一句網（簡體） https://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Your</span> <span class="string">slogan.</span></span><br></pre></td></tr></table></figure><h2 id="为butterfly配置local-search"><a href="#为butterfly配置local-search" class="headerlink" title="为butterfly配置local search"></a>为butterfly配置local search</h2><p>在<code>themes/butterfly/_config.yml</code>中找到字段<code>local_search</code>，修改为如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">-1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure><p>然后前往博客的根目录，安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h2 id="使用更好的渲染器"><a href="#使用更好的渲染器" class="headerlink" title="使用更好的渲染器"></a>使用更好的渲染器</h2><p>首先安装<code>Mathjax</code>插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>然后更改Hexo的Markdown渲染器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>修改转义配置进入<code>node_modules\kramed\lig\rules\inline.js</code><br>找到<code>escape</code>字段，修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>找到<code>em</code>字段，修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/qisi007/p/13731562.html">https://www.cnblogs.com/qisi007/p/13731562.html</a><br><a href="https://blog.misaka.rest/2023/02/01/hexo-gitalk/">https://blog.misaka.rest/2023/02/01/hexo-gitalk/</a><br><a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br><a href="https://shanhainanhua.github.io/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/">https://shanhainanhua.github.io/2019/09/18/hexo-next%E4%B8%BB%E9%A2%98-markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客 教程(二)配置github与自选主题</title>
      <link href="/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%BA%8C-%E9%85%8D%E7%BD%AEgithub%E4%B8%8E%E8%87%AA%E9%80%89%E4%B8%BB%E9%A2%98/"/>
      <url>/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%BA%8C-%E9%85%8D%E7%BD%AEgithub%E4%B8%8E%E8%87%AA%E9%80%89%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-Hexo-Github-Build-Your-Blog-教程-二-配置github与自选主题"><a href="#Use-Hexo-Github-Build-Your-Blog-教程-二-配置github与自选主题" class="headerlink" title="Use Hexo + Github Build Your Blog 教程(二)配置github与自选主题"></a>Use Hexo + Github Build Your Blog 教程(二)配置github与自选主题</h1><h2 id="配置github远端连接"><a href="#配置github远端连接" class="headerlink" title="配置github远端连接"></a>配置github远端连接</h2><p>我们需要在<code>Github</code>上新建一个仓库来托管我们的网页，需要注意<code>Github</code>只能使用一个同名的仓库名来托管一个静态的站点，所以我新建的仓库名字应该和我们的用户名一致，比如我的用户名是<code>shenmuxin</code>，那么我的仓库名应该为<code>shenmuxin.github.io</code>，具体可以参考下图</p><img src="https://pic.imgdb.cn/item/658cde5bc458853aef90518d.jpg" class="" title="创建github仓库"><p>然后我们需要配置SSH key，这样我们就可以通过SSH来连接<code>Github</code>了，具体操作如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your email(和上面的邮箱一致)&quot;</span></span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，便可以生成SSH key，可以采用以下的指令来查看自己生成的SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>也可以手动打开<code>~/.ssh/id_rsa.pub</code>文件来查看，复制SSH key的全部内容</p><img src="https://pic.imgdb.cn/item/658cdf64c458853aef941ad2.jpg" class="" title="ssh key的路径"><p>然后将SSH key添加到<code>Github</code>上，在<code>Github</code>上找到<code>Settings</code>，然后找到<code>SSH and GPG keys</code>，点击<code>New SSH key</code>，将SSH key的内容粘贴到<code>Key</code>中，然后点击<code>Add SSH key</code></p><img src="https://pic.imgdb.cn/item/658cdfdcc458853aef956abe.jpg" class="" title="添加ssh key"><p>然后在<code>_config.yml</code>文件中进行配置，</p><img src="https://pic.imgdb.cn/item/658ce091c458853aef976745.jpg" class="" title="配置_config.yml"><p>将<code>deploy</code>的配置修改为如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/your name/your name.github.io.git</span><br><span class="line">  brach: master</span><br></pre></td></tr></table></figure><p>然后再安装一个部署从插件<code>hexo-deployer-git</code>,在博客文件中使用<code>Git Bash Here</code>打开终端，输入以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行如下的两条命令就能够部署上传了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时用浏览器打开<code>your name.github.io</code>就能访问你的网页了。</p><h2 id="配置好看的主题"><a href="#配置好看的主题" class="headerlink" title="配置好看的主题"></a>配置好看的主题</h2><p>Hexo官方收录了许多好看主题，可以在这里找到<a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a>，笔者使用的主题是<code>butterfly</code>，<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>。<br>直接下载主题文件夹，然后放置在<code>themes</code>文件夹下，在<code>themes/butterfly/_config.yml</code>文件中进行配置，选择当前使用的主题名字</p><img src="https://pic.imgdb.cn/item/658ce2fec458853aef9ebfa0.jpg" class="" title="配置主题"><p>然后我们可以进行渲染</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>查看当前的主题效果。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br><a href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;d02fb26eb2345ac42c054db0bb8d8864</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客 教程(一)搭建基本环境与基本操作</title>
      <link href="/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%80-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/12/28/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E6%95%99%E7%A8%8B-%E4%B8%80-%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-Hexo-Github-Build-Your-Blog-教程-一-搭建基本环境与基本操作"><a href="#Use-Hexo-Github-Build-Your-Blog-教程-一-搭建基本环境与基本操作" class="headerlink" title="Use Hexo + Github Build Your Blog 教程(一)搭建基本环境与基本操作"></a>Use Hexo + Github Build Your Blog 教程(一)搭建基本环境与基本操作</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先笔者使用的操作系统环境为<code>windows11</code>,以下默认的安装环境为<code>windows11</code>。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>首先下载Git，<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>下载完成后直接安装即可。然后在git中进行基本配置，首先绑定自己的<code>Github</code>账号，鼠标右键点击<code>Git Bash Here</code>打开Git的终端，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><p>将相应位置替换为你自己的<code>Github</code>账号信息。配置完成之后可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>查看一下配置是否正确。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>然后，下载Nodejs，<a href="https://nodejs.org/en">https://nodejs.org/en</a><br>下载完成后直接安装即可。安装完成之后，查看安装是否正确，同样用<code>Git Bash Here</code>打开终端，然后在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果出现了相应的版本号，则说明安装成功。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装Hexo，在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>等待安装完成后，查看版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>如果出现了相应的版本号，则说明安装成功。</p><h2 id="初始化Blog文件"><a href="#初始化Blog文件" class="headerlink" title="初始化Blog文件"></a>初始化Blog文件</h2><ul><li>使用Hexo初始化一个博客文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init YourBlogFileName</span><br><span class="line"><span class="built_in">cd</span> YourBlogFileName</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>等待安装完成，我们可以直接进行渲染，看安装是否正确</p><ul><li>开启Hexo服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment">#或者缩写成 hexo s</span></span><br></pre></td></tr></table></figure><p>如果过程无误，可以打开本地的端口<code>http://localhost:4000/</code>查看网页的效果，那么显示的结果应该如下所示</p><img src="https://pic.imgdb.cn/item/658cdac6c458853aef83433f.png" class="" width="1000" height="600" title="渲染结果"><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>使用Hexo初始化blog</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init YourBlogFileName</span><br><span class="line"><span class="built_in">cd</span> YourBlogFileName</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li>新建一个page</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;YourPageName&quot;</span></span><br></pre></td></tr></table></figure><ul><li>新建一个post</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;YourPostName&quot;</span></span><br></pre></td></tr></table></figure><ul><li>生成静态文件（可以理解为编译）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment"># 缩写为 hexo g</span></span><br></pre></td></tr></table></figure><ul><li>渲染（开启服务）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 缩写为 hexo s</span></span><br></pre></td></tr></table></figure><ul><li>清除构建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 缩写为 hexo c</span></span><br></pre></td></tr></table></figure><ul><li>推送到远端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy <span class="comment"># 缩写为 hexo d</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&vd_source=d02fb26eb2345ac42c054db0bb8d8864">https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;d02fb26eb2345ac42c054db0bb8d8864</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 5. Monte Carlo Learning]</title>
      <link href="/2023/07/24/Reinforcement-Learning-with-Code-Chapter-5-Monte-Carlo-Learning/"/>
      <url>/2023/07/24/Reinforcement-Learning-with-Code-Chapter-5-Monte-Carlo-Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code"></a>Reinforcement Learning with Code</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-5-Monte-Carlo-Learning"><a href="#Chapter-5-Monte-Carlo-Learning" class="headerlink" title="Chapter 5. Monte Carlo Learning"></a>Chapter 5. Monte Carlo Learning</h2><p>​What is Monte Carlo estimation? Monte Carlo estimation refers to a broad class of techniques that use stochastic samples to solve approximation problems using the <font color=blue>Law of Large Numbers</font>. </p><p>​ChatGpt tells us that “Monte Carlo estimation is a statistical method used to estimate unknown quantities or solve problems by generating random samples and using the law of large numbers to approximate the true value.”</p><h3 id="5-1-Law-of-large-numbers"><a href="#5-1-Law-of-large-numbers" class="headerlink" title="5.1 Law of large numbers"></a>5.1 Law of large numbers</h3><p>​(Law of Large Numbers) <em>For a random variable</em> $X$. <em>Suppose</em> ${x_i}<em>{i&#x3D;1}^n$ <em>are some independent and indentically distribution (iid) samples</em>. <em>Let</em> $\bar{x}&#x3D;\frac{1}{n}\sum</em>{i&#x3D;1}^n x_i$ <em>be the average of the samples. Then</em>,<br>$$<br>\mathbb{E}[\bar{x}] &#x3D; \mathbb{E}[X]\<br>\mathrm{var}[\bar{x}] &#x3D; \frac{1}{n} \mathrm{var}[X]<br>$$<br>The above two equations indicate that $\bar{x}$ is an <em>unbiased estimate</em> of $\mathbb{E}[X]$ and its variance decreases to zero as $n$ increases to infinity.</p><p>​<strong>Proof</strong>, First, $\mathbb{E}[\bar{x}] &#x3D; \mathbb{E}[\frac{1}{n}\sum_{i&#x3D;1}^n x_i]&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n\mathbb{E}[x_i]&#x3D;\frac{1}{n}n\mathbb{E}[X]&#x3D;\mathbb{E}[X]$, where the last equability is because the samples are <em>independent and indentically distribution (iid)</em> (that is, $\mathbb{E}[x_i]&#x3D;\mathbb{E}[X]$).</p><p>​Second, $\mathrm{var}[\bar{x}]&#x3D;\mathrm{var}[\frac{1}{n}\sum_{i&#x3D;1}^n x_i]&#x3D;\frac{1}{n^2}\sum_{i&#x3D;1}^n\mathrm{var}[x_i]&#x3D;\frac{1}{n^2}n*\mathrm{var}[X]&#x3D;\frac{1}{n}\mathrm{var}[X]$, where the second equality is because the samples are <em>independent and indentically distribution (iid)</em> (that is, $\mathrm{var}[x_i]&#x3D;\mathrm{var}[X]$)</p><h3 id="5-2-Simple-example"><a href="#5-2-Simple-example" class="headerlink" title="5.2 Simple example"></a>5.2 Simple example</h3><p>​Consider a problem that we need to calculate the expectation $\mathbb{E}[X]$ of random variable $X$ which takes value in the finite set $\mathcal{X}$. There are two ways. </p><p>​First, <em>model-based</em> approach, we can use the definition of expectation that<br>$$<br>\mathbb{E}[X] &#x3D; \sum_{x\in\mathcal{X}} p(x)x<br>$$<br>​Second, <em>model-free</em> approach, if the probability of distribution is unknown we can use the <em>Law of Large Numbers</em> to estimate the expectation.<br>$$<br>\mathbb{E}[X]\approx \bar{x} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n x_i<br>$$<br>The example gives us an intutition that: When the system model is available, the expectation can be calculated based on the model.</p><p>When the model is unavailable, the expectation can be estimated approximately using stochastic samples.</p><h3 id="5-3-Monte-Carlo-Basic"><a href="#5-3-Monte-Carlo-Basic" class="headerlink" title="5.3 Monte Carlo Basic"></a>5.3 Monte Carlo Basic</h3><p><strong>Review policy iteration</strong>:</p><p>​The simplest Monte Carlo learning also called Monte Carlo Basic (MC Basic) just replaces the policy iteration model-based part by MC estimation. Recall the <font color=blue>matrix-vector form of policy iteration</font></p><p>$$<br>\begin{aligned}<br>    v_{\pi_k}^{(j+1)} &amp; &#x3D; r_{\pi_k} + \gamma P_{\pi_k} v_{\pi_k}^{(j)}\quad \text{(policy evaluation)} \<br>    \pi_{k+1} &amp; &#x3D; \arg \max_{\pi_k}(r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k})\quad \text{(policy improvement)}<br>\end{aligned}<br>$$</p><p>The <font color=blue>elementwise form of policy iteration</font> is</p><p>$$<br>\begin{aligned}<br>    v_{\pi_k}^{(j+1)}(s) &amp; &#x3D; \sum_a \pi_k(a|s) \Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k}^{(j)} (s^\prime)\Big)\quad \text{(policy evaluation)}\<br>    \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k}  \sum_a \pi(a|s)<br>    \underbrace{<br>    \Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k} (s^\prime)\Big)}<em>{q</em>{\pi_k}(s,a)}<br>    \quad \text{(policy improvement)}\<br>    \to \pi_{k+1}(s) &amp; &#x3D;  \sum_a \pi(a|s) \arg \max_a q_{\pi_k}(s,a)<br>\end{aligned}<br>$$</p><p>Its obvious that the core is to calculate the action values by usting<br>$$<br>q_{\pi_k}(s,a) &#x3D; \sum_r p(r|s,a)r + \sum_{s^\prime}p(s^\prime|s,a)v_{\pi_k}(s^\prime)<br>$$<br>​However, the above equation needs the model of the environment (that  $p(r|s,a)$ and $p(s^\prime|s,a)$ are required). We can replace this part by Monte Carlo estimation. Recall the definition of action value refer to section 2.5.<br>$$<br>q_\pi(s,a) \triangleq \mathbb{E}[G_t|S_t&#x3D;s, A_t&#x3D;a]<br>$$<br>Action value can be interpreted as <font color=blue>average return</font> along trajectory generated by <font color=blue>policy $\pi$ </font> after taking a <font color=blue>specific action $a$</font>.</p><p><strong>Convert to model free</strong>:</p><p>​Suppose there are $n$ episodes sampling starting at state $s$ and takeing action $a$,  and then denote the $i$ th episode return as $\textcolor{blue}{g^{(i)}(s,a)}$. Then using the idea of Monte Carlo estimation and Law of Large Numbers, the action values can be approxiamte as<br>$$<br>q_\pi(s,a) \triangleq \mathbb{E}[G_t|S_t&#x3D;s, A_t&#x3D;a] \textcolor{blue}{\approx \frac{1}{n} \sum_{j&#x3D;1}^n g^{(j)}(s,a)}<br>$$<br>Suppose the number of episodes $n$ is sufficiently large. So, the above equation is the unbiased estimation of action value $q_\pi(s,a)$.</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658bfa94c458853aef6a9405.png" class="" width="800" height="400" title="state-transform"><p>​Here are some questions.  <font color=red>Why does the MC Basic algorithm estimate action values instead of state values?</font> That is because state value cannot be used to improve policies directly. Even if we are given state values, we still need to calculate action values from these state value using $q_{\pi_k}(s,a) &#x3D; \sum_r p(r|s,a)r + \sum_{s^\prime}p(s^\prime|s,a)v_{\pi_k}(s^\prime)$. But this calculation requires the system model. Therefore, when models are not available, we should directly estimate action values.</p><h3 id="5-4-Monte-Carlo-Exploring-Starts"><a href="#5-4-Monte-Carlo-Exploring-Starts" class="headerlink" title="5.4 Monte Carlo Exploring Starts"></a>5.4 Monte Carlo Exploring Starts</h3><p><strong>Some concepts</strong>:</p><ul><li><p><font color=blue>Vist</font>: a state-action pair appears in the episode, it is called a <em>vist</em> of the state-action pair. Such as<br>$$<br>\textcolor{blue}{s_1 \xrightarrow{a_2}} s_2 \xrightarrow{a_4} \textcolor{blue}{s_1 \xrightarrow{a_2}} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots<br>$$<br>$(s_1,a_2)$ is called a visit.</p></li><li><p><font color=blue>First visit</font>: In the above trajectory $(s_1,a_2)$ is visited twice. If we only count the first-time visit, such kind of strategy is called <em>first-visit</em>.</p></li><li><p><font color=blue>Every visit</font>: If every time state-action pair is visited and the rest of the episode is used to estimate its action value, such a strategy is called <em>every-visit</em>.</p></li></ul><p>​For example,</p><p>$$<br>\begin{aligned}<br>    s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_4} s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\textcolor{blue}{\text{origianl episode}}]\<br>    s_2 \xrightarrow{a_4} s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\text{episode starting from }(s_2,a_4)]\<br>    s_1 \xrightarrow{a_2} s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\textcolor{red}{\text{episode starting from }(s_1,a_2)}]\<br>    s_2 \xrightarrow{a_3} s_5 \xrightarrow{a_13}\cdots &amp; \quad [\text{episode starting from }(s_2,a_3)]\<br>    s_5 \xrightarrow{a_13}\cdots &amp; \quad [\text{episode starting from }(s_2,a_4)]<br>\end{aligned}<br>$$</p><p>Suppose we need to estimate the action value $q_\pi(s_1,a_2)$. The <em>first-visit</em> only counts the first visit of $(s_1,a_2)$. So we need a huge numbers of episodes starting from $(s_1,a_2)$. As the blue one episode in the above equations. The <em>every-visi</em>t counts every time the visit of $(s_1,a_2)$. Hence, we can use the blue one and the red one to estimate the action value $q_\pi(s_1,a_2)$. In this way, the samples in the episode are utilized more sufficiently.</p><p><strong>Using sample more efficiently</strong>:</p><p>​From the example, we are informed that <font color=blue>if an episode is sufficiently long so that it can visit all the state-action pairs many times, then this single episode is sufficient to estimate all the action values by using the every-visit strategy</font>. However, one single episode is pretty ideal result. Because the samples obtained by the <em>every-visit</em> is relevant due to the trajectory starting from the second visit is merely a subset of the trajectory starting from the first. Nevertheless, if the two visits are far away from each other, which means there is a siginificant non-overlap portion, the relevance would not be strong. Moreover, the relevance can be further suppressed due to the discount rate. <font color=blue>Therefore, when there are few episodes and each episode is very long, the every-visit strategy is a good option</font>.</p><p><strong>Using estimation more efficiently</strong>:</p><p>​The first startegy in MC Basic, in the policy evaluation step, to collect all the episodes starting from the same state-action pair and then approximate the action value using the average return of these episodes. The drawback of the strategy is that the agent must wait until all episodes have been collected.</p><p>​The second strategy, which can overcome the drawback, is to <font color=blue>use the return of a single episode to approximate the corresponding action value</font> (the idea of stochastic estimation). In this way, we can improve the policy in an <font color=blue>episode-by-episode</font> fasion.</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658bfac5c458853aef6b25fb.png" class="" width="800" height="500" title="state-transform"><p><font color=blue>MC Exploring Starts algorithm compared to MC Basic, the sample usage and estimation update are more efficient</font>.</p><h3 id="5-5-Monte-Carlo-epsilon-Greedy"><a href="#5-5-Monte-Carlo-epsilon-Greedy" class="headerlink" title="5.5 Monte Carlo $\epsilon$-Greedy"></a>5.5 Monte Carlo $\epsilon$-Greedy</h3><p>​Why is exploring starts important? In theory, exploring starts is necessary to find optimal policies. Only if every state-action pair is well explored, can we select optimal policies. However, in practice, exploring starts is difficult to achieve. Because its difficult to collect episodes starting from every state-action pair.</p><p>​We can use <em>soft policy</em> to remove the requirement of exploring starts. There are many soft policies. The most common one is $\textcolor{blue}{\epsilon}$<font color=blue>-greedy</font>. The $\epsilon$-greedy has the form of<br>$$<br>\pi(a|s) &#x3D;<br>\left {<br>    \begin{aligned}<br>    1 - \frac{\epsilon}{|\mathcal{A}(s)|}(|\mathcal{A(s)}|-1), &amp; \quad \text{for the geedy action}\<br>    \frac{\epsilon}{|\mathcal{A}(s)|}, &amp; \quad \text{for the other } |\mathcal{A}(s)|-1 \text{ actions}<br>    \end{aligned}<br>\right.<br>$$<br>where $|\mathcal{A}(s) |$ denotes the number of actions associated with $s$. It is worth noting taht the probability to take the greedy action is always greater than other action, because<br>$$<br>1 - \frac{\epsilon}{|\mathcal{A}(s)|}(|\mathcal{A(s)}|-1) &#x3D;<br>1 - \epsilon + \frac{\epsilon}{|\mathcal{A}(s)|} \ge<br>\frac{\epsilon}{|\mathcal{A}(s)|}<br>$$<br>for any $\epsilon\in[0,1]$, when $\epsilon&#x3D;0$ the $\epsilon$-greedy becomes greedy policy.</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658bfae1c458853aef6b7740.png" class="" width="800" height="500" title="state-transform"><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 4. Value Iteration and Policy Iteration]</title>
      <link href="/2023/07/23/Reinforcement-Learning-with-Code-Chapter-4-Value-Iteration-and-Policy-Iteration/"/>
      <url>/2023/07/23/Reinforcement-Learning-with-Code-Chapter-4-Value-Iteration-and-Policy-Iteration/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code"></a>Reinforcement Learning with Code</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-4-Value-Iteration-and-Policy-Iteration"><a href="#Chapter-4-Value-Iteration-and-Policy-Iteration" class="headerlink" title="Chapter 4. Value Iteration and Policy Iteration"></a>Chapter 4. Value Iteration and Policy Iteration</h2><p>​Value iteration and policy iteration have a common name called <font color=blue>dynamic programming</font>. Dynamic programming is model-based algorithm, which is the simplest RL algorithm. Its helpful to us to understand the model-free algorithm.</p><h3 id="4-1-Value-iteration"><a href="#4-1-Value-iteration" class="headerlink" title="4.1 Value iteration"></a>4.1 Value iteration</h3><p>​Value iteration is solving the Bellman optimal equation directly.</p><p><strong>Matrix-vector form</strong>:</p><p>​The <font color=red>value iteration</font> is exactly the algorithm suggested by the contraction mapping in chapter 3. Value iteration concludes two parts. First, in every iteration is called <em>policy update</em>. </p><p>$$<br>\pi_{k+1} &#x3D; \arg \textcolor{red}{\max_{\pi_k}(r_{\pi_k} + \gamma P_\pi v_k)}<br>$$<br>Second, the step is <em>value update</em>. Mathematically, it is to substitute $\pi_{k+1}$ and do the following operation:</p><p>$$<br>v_{k+1} &#x3D; r_{\pi_{k+1}} + \gamma P_{\pi_{k+1}}v_k<br>$$</p><p>The above algorithm is matrix-vector form which is useful to understand the core idea. <font color=red>The above equation is iterative which means we calculate</font> $v_{k+1}$ <font color=red>is only one step calculation</font>.</p><p>There is a <font color=red>misunderstanding</font> that we doesn’t use Bellman equation to calculate state value $v_{k+1}$ directly. Instead, when we use greedy policy update strategy the state value $v_{k+1}$ is actually the maximum action value $\max_a q_k(s,a)$.</p><p>The value iteration includes solving the Bellman optimal equation part as show in red.</p><p><strong>Elementwise form</strong>:</p><p>​First, the elementwise form <em>policy update</em> is </p><p>$$<br>\begin{aligned}<br>\pi_{k+1} &amp; &#x3D; \arg \max_{\pi_k}(r_{\pi_k} + \gamma P_\pi v_k)\quad \text{(matrx-vector form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k} \sum_a \pi_k(a|s)<br>\Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_k(s^\prime)\Big) \quad \text{(elementwise  form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k} \sum_a \pi_k(a|s) q_{\pi_k}(s,a)\newline<br>\to \pi_{k+1}(s) &amp; &#x3D;  \sum_a \pi_k(a|s) \arg \max_{a_k}q_{\pi_k}(s,a)<br>\end{aligned}<br>$$</p><p>Then use the greedy policy update algorithm, when $a&#x3D;a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 1$, when $a\ne a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 0$, where $a_k^*(s) &#x3D; \arg\max_a q_k(a,s)$.</p><p>​Second, the elementwise form <em>value update</em> is </p><p>$$<br>\begin{aligned}<br>    v_{k+1} &amp; &#x3D; r_{\pi_{k+1}} + \gamma P_{\pi_{k+1}}v_k\quad \text{(matrx-vector form)}\newline<br>    \to v_{k+1}(s) &amp; &#x3D; \sum_a \pi_{k+1}(a|s)<br>    \underbrace{<br>    \Big(\sum_r p(r|s,a)r+ \gamma \sum_{s^\prime}p(s^\prime|s,a)v_k(s^\prime) \Big)}_{q_k(s,a)}\quad \text{(elementwise  form)}<br>\end{aligned}<br>$$</p><p><font color=blue>Since $\pi_{k+1}$ is a greedy policy, the above equation is simply</font></p><p>$$<br>v_{k+1}(s) &#x3D; \max_a q_k(s,a)<br>$$</p><p><strong>Pesudocode</strong>:</p><img src="https://pic.imgdb.cn/item/658be0b6c458853aef1b95ef.png" class="" width="800" height="400" title="state-transform"><h3 id="4-2-Policy-iteration"><a href="#4-2-Policy-iteration" class="headerlink" title="4.2 Policy iteration"></a>4.2 Policy iteration</h3><p>​The <font color=red>policy iteration</font> is not an algorithm directly solving the Bellman optimality equation. However, it has an intimate relationship to value iteration. The policy iteration includes two parts <font color=blue>policy evaluation</font> and <font color=blue>policy improvement</font>.</p><p><strong>Policy evaluation</strong>:</p><p>​The first step is policy evaluation. Mathematically, it is to sovle Bellman equation of $\pi_k$:</p><p>$$<br>v_{\pi_k} &#x3D; r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k}<br>$$</p><p>This is the matrix-vector form of the Bellman equation, where $r_{\pi_k}$ and $P_{\pi_k}$ are known. Here, $v_{\pi_k}$ is the state value to be solved.</p><p><font color=blue>How to calculate state value</font> $v_{\pi_k}$ is important. In section 2.4 we have already introduced how to solve Bellman equation to get state value $v_{\pi_k}$ as following</p><p>$$<br>\textcolor{blue}{v_{\pi_k}^{(j+1)} &#x3D; r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k}^{(j)}}, \quad j&#x3D;0,1,2,\dots<br>$$</p><p><font color=red>Its clear that policy iteration is directly calculate the state value using the above equation, which means the calculation is infity step calculation</font>.</p><p><strong>Policy improvement</strong>:</p><p>​The second step is to imporve the policy. How to do that? Once $v_{\pi_k}$ is calculated in the first step, a new and improved policy could be obtained as </p><p>$$<br>\pi_{k+1} &#x3D; \arg \max_\pi (r_\pi + \gamma P_\pi v_{\pi_k})<br>$$</p><p> <strong>Elementwise form</strong>:</p><p>​The policy evaluation step is to solve $v_{\pi_k}$ from the Bellman equation dirctly.</p><p>$$<br>\begin{aligned}<br>    v_{\pi_k}^{(j+1)} &amp; &#x3D; r_{\pi_k} + \gamma P_{\pi_k} v_{\pi_k}^{(j)}\quad \text{(matrix-vector form)} \newline<br>    \to v_{\pi_k}^{(j+1)}(s) &amp; &#x3D; \sum_a \pi_k(a|s) \Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k}^{(j)} (s^\prime)\Big) \quad \text{(elementwise form)}<br>\end{aligned}<br>$$<br>where $j&#x3D;0,1,2,\dots$</p><p>The policy improvement step is to solve $\pi_{k+1}&#x3D;\arg \max_\pi (r_\pi + \gamma P_{\pi_k}v_{\pi_k})$.</p><p>$$<br>\begin{aligned}<br>\pi_{k+1} &amp; &#x3D;\arg \max_{\pi_k} (r_{\pi_k} + \gamma P_{\pi_k}v_{\pi_k})\quad \text{(matrix-vector form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D; \arg \max_{\pi_k}  \sum_a \pi(a|s)<br>\Big(\sum_r p(r|s,a)r + \sum_{s^\prime} p(s^\prime|s,a) v_{\pi_k} (s^\prime)\Big)<br>\quad \text{(elementwise form)}\newline<br>\to \pi_{k+1}(s) &amp; &#x3D;  \sum_a \pi(a|s) \arg \max_a q_{\pi_k}(s,a)<br>\end{aligned}<br>$$</p><p>Let $a^*<em>k(s) &#x3D; \text{arg} \max_a q</em>{\pi_k}(s,a)$. The greedy optimal policy is when $a&#x3D;a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 1$, when $a\ne a_k^*(s)$, $\pi_{k+1}(a|s) &#x3D; 0$, where $a_k^*(s) &#x3D; \arg\max_a q_k(a,s)$.</p><p><strong>Pesudocode:</strong></p><img src="https://pic.imgdb.cn/item/658be0dfc458853aef1c2798.png" class="" width="800" height="400" title="state-transform"><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 3. Optimal State Value and Bellman Optimal Equation]</title>
      <link href="/2023/07/23/Reinforcement-Learning-with-Code-Chapter-3-Optimal-State-Value-and-Bellman-Optimal-Equation/"/>
      <url>/2023/07/23/Reinforcement-Learning-with-Code-Chapter-3-Optimal-State-Value-and-Bellman-Optimal-Equation/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code."></a>Reinforcement Learning with Code.</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-3-Optimal-State-Value-and-Bellman-Optimality-Equation"><a href="#Chapter-3-Optimal-State-Value-and-Bellman-Optimality-Equation" class="headerlink" title="Chapter 3. Optimal State Value and Bellman Optimality Equation"></a>Chapter 3. Optimal State Value and Bellman Optimality Equation</h2><h3 id="3-1-How-to-define-optimal"><a href="#3-1-How-to-define-optimal" class="headerlink" title="3.1 How to define optimal"></a>3.1 How to define optimal</h3><p>​One core idea is that we use the action value to judge the optimality of the action. If we update the policy to select the action with the <em>greatest action value</em>, we could find a better policy.</p><p>​(<font color=blue>Optimal policy and optimal state value</font>). <em>A policy</em> $\pi^*$ <em>is optimal if</em> $v_{\pi^*}(s) \ge v_\pi(s)$ <em>for all</em> $s\in\mathcal{S}$ <em>and for any other policy</em> $\pi$. <em>The state values of</em>  $\pi^*$ <em>are the optimal state values</em>.</p><p><font color=blue>Why does the definition works? One intuitive explanation is that state value $v_\pi(s)$ denote the mean of return along the trajectory following policy $\pi$. If the policy $\pi^*$ has greatest expectation of return, hence we can believe that the policy $\pi^*$ is optimal.</font></p><h3 id="3-2-Bellman-optimal-equation-BOE"><a href="#3-2-Bellman-optimal-equation-BOE" class="headerlink" title="3.2 Bellman optimal equation (BOE)"></a>3.2 Bellman optimal equation (BOE)</h3><p>​The Bellamn optimal eqaution (BOE) is </p><p>$$<br>\begin{aligned}<br>v(s) &amp; &#x3D; \max_\pi \sum_a \pi(a|s) \Big[ \sum_r p(r|s,a)r + \gamma \sum_{s^\prime} p(s^{\prime}|s,a) v_\pi(s^{\prime}) \Big] \newline<br>\textcolor{red}{v(s)} &amp; \textcolor{red}{&#x3D; \max_\pi \sum_a \pi(a|s) q_\pi(s,a)}<br>\end{aligned}<br>$$</p><p>There is a problem that the BOE has two unknown variables $q_\pi(s,a)$ and $\pi(a|s)$. How can we solve the BOE?</p><p>​The idea is that we can <font color=blue>fix one variable</font> and solve the maximization problem. For Bellman optimal equation, we can <font color=blue>fix variable $\pi(a|s)$ for all $a\in\mathcal{A}(s)$</font> and then by maximize the state value to find the optimal policy $\pi$.</p><p>​Before analysis, we consider one example first. Suppose $x_1,x_2,x_3\in\mathbb{R}$ are given. Find $c_1^*,c_2^*,c_3^*$ solving<br>$$<br>\max_{c_1,c_2,c_3} c_1x_1+c_2x_2+c_3x_3\newline<br>\text{subject to } c_1+c_2+c_3&#x3D;1<br>$$<br>Without generality, suppose $x_3 \ge x_1, x_2$. Then, the optimal solution is $c_3^*&#x3D;1$ and $c_1^*&#x3D;c_2^*&#x3D;0$. This is because for any $c_1,c_2,c_3$<br>$$<br>x_3 &#x3D; (c_1+c_2+c_3)x_3 &#x3D; c_1x_3 + c_2x_3 + c_3x_3 \ge c_1x_1 +c_2x_2+c_3x_3<br>$$<br>​Hence, inspired by the above example, considering that $\sum_a \pi(a|s)&#x3D;1$, we have</p><p>$$<br>\begin{aligned}<br>v(s) &amp; &#x3D; \max_\pi \sum_a \pi(a|s) q_\pi(s,a) \newline<br>&amp; &#x3D; \sum_a \pi(a|s) \max_\pi q_\pi(s,a) \quad \text{by fix } \pi(a|s) \newline<br>&amp; &#x3D; \sum_a \pi(a|s) \max_{a\in\mathcal{A}} q_\pi(s,a) \newline<br>&amp; \le \max_{a\in\mathcal{A}} q_\pi(s,a)<br>\end{aligned}<br>$$</p><p>where the equality is achieved when $a&#x3D;a^*$, $\pi(a|s)&#x3D;1$ when $a\ne a^*$, $\pi(a|s)&#x3D;0$.</p><p>$$<br>a^* &#x3D; \text{arg} \max_a q(s,a)<br>$$</p><p>This policy is often called <font color=blue>greedy policy</font>.</p><h3 id="3-3-Matrix-vector-form-of-Bellman-optimal-equation"><a href="#3-3-Matrix-vector-form-of-Bellman-optimal-equation" class="headerlink" title="3.3 Matrix-vector form of Bellman optimal equation"></a>3.3 Matrix-vector form of Bellman optimal equation</h3><p>Refering to matrix-vector form of Bellman equation, it’s obvious to get matrix-vector form of Bellman optimal equation as follows<br>$$<br>\textcolor{blue} {v &#x3D; \max_\pi (r_\pi +\gamma P_\pi v)}<br>$$<br>where $v\in\mathbb{R^{|\mathcal{S}|}}$. The structure of $r_\pi$ and $P_\pi$ are the same as those in the matrix-vector form of Bellman equation:</p><p>$$<br>[r_\pi]_s \triangleq \sum_a \pi(a|s) \sum_r p(r|s,a)r<br>$$</p><p>$$<br>[P_\pi]<em>{s, s^\prime} &#x3D; \sum_a \pi(a|s) \sum</em>{s^\prime} p(s^\prime|s,a)<br>$$</p><p>Furthermore, denote the right hand side as </p><p>$$<br>f(v) \triangleq \max_\pi(r_\pi + \gamma P_\pi v)<br>$$</p><p>Hence, we have the Bellman optimal equation as</p><p>$$<br>v&#x3D;f(v) \newline<br>f(v) - v &#x3D; 0<br>$$</p><p><font color=blue>It turns solving Bellman optimal equation to solving find the root of function</font> $\textcolor{blue}{f(v) - v &#x3D;0}$.</p><h3 id="3-4-Contraction-mapping-theorem"><a href="#3-4-Contraction-mapping-theorem" class="headerlink" title="3.4 Contraction mapping theorem"></a>3.4 Contraction mapping theorem</h3><p>​<font color=red>Fixed point</font>: consider a function $f(x)$ where $x\in\mathbb{R}^b$ and $f:\mathbb{R}^b\to\mathbb{R}^b$. A point $x^*$ is called a fixed point if<br>$$<br>f(x^*) &#x3D; x^*<br>$$<br>The function $f$ is called a <font color=red>contracting mapping</font> if there <font color=blue>exists</font> $\gamma\in(0,1)$ such that<br>$$<br>||f(x_1)-f(x_2)|| \le \gamma ||x_1 - x_2||<br>$$<br>for any $x_1, x_2\in \mathbb{R}$.</p><p>​(<font color=red>Contraction mapping theorem</font>) For any equation that has the form of $x&#x3D;f(x)$ where $x$ and $f(x)$ are real vectors, if $f$ is a contraction mapping, then</p><ul><li><p>Existence: There exists a fixed point $x^*$ satisfying $f(x^*)&#x3D;x^*$.</p></li><li><p>Uniqueness: The fixed point $x^*$ is unique.</p></li><li><p>Algorithm: Consider the iterative process:<br>$$<br>x_{k+1} &#x3D; f(x_k)<br>$$<br>where $k&#x3D;0,1,2,\dots$. Then , $x_k\to x^*$ as $k\to \infty$ for any initial guess $x_0$. Moreover, the convergence rate is exponentially fast.</p></li></ul><h3 id="3-5-Solution-of-BOE"><a href="#3-5-Solution-of-BOE" class="headerlink" title="3.5 Solution of BOE"></a>3.5 Solution of BOE</h3><p>​(Contraction property of BOE). The function $f(v) \triangleq \max_\pi(r_\pi + \gamma P_\pi v)$ in the BOE is a contraction mapping statisfying<br>$$<br>||f(v_1)-f(v_2)|| \le \gamma ||v_1 - v_2||<br>$$<br>where $v_1,v_2\in\mathbb{R}^{|\mathcal{S}|}$ are any two vectors and $\gamma\in(0,1)$ is the discounted rate.</p><p>The proof is omitted.</p><p>​Using contraction mapping theorem to solve BOE, we have the following theorem:</p><p>​(<font color=red>Existence, Uniqueness, Algorithm</font>). <em>For the BOE</em> $v&#x3D;f(v) \triangleq \max_\pi(r_\pi + \gamma P_\pi v)$, <em>there always exists a unique solution</em> $v^*$, <em>which can be solved iteratively by</em><br>$$<br>v_{k+1} &#x3D; f(v_k) &#x3D; \max_\pi(r_\pi + \gamma P_\pi v_k), \quad k&#x3D;0,1,\dots<br>$$<br><em>The sequence</em> ${v(k)}$ <em>converges to optimal solution of BOE</em> $v^*$ <em>exponentially fast given any inital guess</em> $v_0$.</p><p>This algorithm is actually called <font  color=blue>value iteration</font>. </p><p>​<font color=blue>First</font>, following the algorithm above will give us the optimal state value $v^*$. <font color=blue>Second</font>, we solve the unknown policy $\pi$ in the BOE. Suppose $v^*$ has been obtained and<br>$$<br>\pi^* &#x3D; \text{arg}\max_\pi(r_\pi+\gamma P_\pi v^*)<br>$$<br>Then, $v^*$ and $\pi^*$ statisfy<br>$$<br>v^* &#x3D; r_{\pi^*} + \gamma P_{\pi^*} v^*<br>$$<br>​(<font color=blue>Greedy optimal policy</font>). <em>For any</em> $s\in\mathcal{S}$, <em>the deterministic greedy policy</em> </p><p>where the equality is achieved when $a&#x3D;a^*$, $\pi(a|s)&#x3D;1$ when $a\ne a^*$, $\pi(a|s)&#x3D;0$.</p><p><em>is an optimal policy solving the BOE. Here</em><br>$$<br>a^*(s) &#x3D; \text{arg} \max_a q^*(a,s)<br>$$<br><em>where</em><br>$$<br>q^*(s,a) \triangleq \sum_r p(r|s,a)r + \gamma \sum_{s^\prime} p(s^{\prime}|s,a) v^*(s)<br>$$<br>​The matrix-vecotr form of the optimal policy is $\pi^*&#x3D;\text{arg}\max_\pi(r_\pi+\gamma P_\pi v^*(s))$. Its <font color=blue>elementwise form</font> is</p><p>$$<br>\begin{aligned}<br> \pi^* &amp; &#x3D; \text{arg}\max_\pi(r_\pi+\gamma P_\pi v^*)\newline<br> \to \pi^*(s) &amp; &#x3D; \text{arg}\max_\pi \sum_a \pi(a|s) \Big( \sum_r p(r|s,a)r + \gamma \sum_{s^\prime} p(s^{\prime}|s,a) v^*(s)\Big)\newline<br> \to \pi^*(s) &amp; &#x3D; \text{arg}\max_\pi \sum_a \pi(a|s) q^*(s,a),\quad \text{for s}\in\mathcal{S}<br>\end{aligned}<br>$$</p><p>It is clear that $\sum_a \pi(a|s)q^*(s,a)$ is maximized if $\pi(s)$ selects the action with the greatest value of $q^*(s,a)$.</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 2. State Value and Bellman Equation]</title>
      <link href="/2023/07/21/Reinforcement-Learning-with-Code-Chapter-2-State-Value-and-Bellman-Equation/"/>
      <url>/2023/07/21/Reinforcement-Learning-with-Code-Chapter-2-State-Value-and-Bellman-Equation/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code."></a>Reinforcement Learning with Code.</h1><p>This note records how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em>, .</p><h2 id="Chapter-2-State-Value-and-Bellman-Equation"><a href="#Chapter-2-State-Value-and-Bellman-Equation" class="headerlink" title="Chapter 2. State Value and Bellman Equation"></a>Chapter 2. State Value and Bellman Equation</h2><h3 id="2-1-State-value"><a href="#2-1-State-value" class="headerlink" title="2.1 State value"></a>2.1 State value</h3><ul><li><p><font color=red>State value</font> is defined as the mean of <font color=blue>all possible returns</font> starting from a state, which is actually the <font color=blue>expectation of return</font> from a specific state.</p></li><li><p>The mathematical definition is as follows:</p><p>Note that the capital letters denote <em>random variables</em>, such as $S_t, S_{t+1}, A_t, R_{t+1}$. In particular, $S_t,S_{t+1}\in\mathcal{S},A_t\in\mathcal{A}(S_t)$ and $R_{t+1}\in\mathcal{R}(S_t,A_t)$. $G_t$ denote the random variable of return.</p><p>Starting from $t$, we can obtain a state-action-reward trajectory:</p><p>$$<br>S_t \xrightarrow{A_t} S_{t+1},R_{t+1} \xrightarrow{A_{t+1}} S_{t+2},R_{t+2} \xrightarrow{A_{t+2}} S_{t+3},R_{t+3} \cdots<br>$$</p><p>The discounted return along the trajectory is </p><p>$$<br>G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma R_{t+3} + \cdots<br>$$</p><p>The state value is defined as:</p><p>$$<br>\textcolor{blue}{v_\pi(s)\triangleq \mathbb{E}[G_t|S_t&#x3D;s]}<br>$$</p><p>which means <font color=blue>start from state</font> $s$ can get the <font color=blue>expectation return</font> along the trajecotry generated by <font color=blue>policy $\pi$ </font>. </p><p>$v_\pi(s)$ is also called <font color=blue>state-value funtion</font>.</p></li></ul><h3 id="2-2-Bellman-Equation"><a href="#2-2-Bellman-Equation" class="headerlink" title="2.2 Bellman Equation"></a>2.2 Bellman Equation</h3><ul><li><p>Bellman equation is a set of linear equations <font color=blue>describing the relationship among the values of all the states</font>.</p><p>For example,</p></li></ul><img src="https://pic.imgdb.cn/item/658bd598c458853aeff51217.png" class="" width="400" height="400" title="state-transform"><p>  Let $v_i$ denote the return obtained starting from $s_i$. The return starting from the four states in figure can be respectively calculated as </p><p>$$<br>v_1 &#x3D; r_1 + \gamma r_2 + \gamma^2 r_3 + \cdots \newline<br>v_2 &#x3D; r_2 + \gamma r_3 + \gamma^2 r_4 + \cdots \newline<br>v_3 &#x3D; r_3 + \gamma r_4 + \gamma^2 r_1 + \cdots \newline<br>v_4 &#x3D; r_4 + \gamma r_1 + \gamma^2 r_2 + \cdots<br>$$</p><p> Using the idea of <em>bootstrapping</em>, we can rewrite it to</p><p>$$<br>v_1 &#x3D; r_1 + \gamma (r_2 + \gamma r_3) + \cdots &#x3D; r_1 + \gamma v_2 \newline<br>v_2 &#x3D; r_2 + \gamma (r_3 + \gamma r_4) + \cdots &#x3D; r_2 + \gamma v_3 \newline<br>v_3 &#x3D; r_3 + \gamma (r_4 + \gamma r_1) + \cdots &#x3D; r_3 + \gamma v_4 \newline<br>v_4 &#x3D; r_4 + \gamma (r_1 + \gamma r_2) + \cdots &#x3D; r_4 + \gamma v_1<br>$$</p><p>  Then rewrite it into matrix form</p><p>$$<br>\textbf{v} &#x3D;  \begin{bmatrix} v_1 \newline v_2 \newline v_3 \newline v_4 \end{bmatrix} , \textbf{r} &#x3D; \begin{bmatrix} r_1 \newline r_2 \newline r_3 \newline r_4 \end{bmatrix}, \textbf{v} &#x3D;  \begin{bmatrix} v_1 \newline v_2 \newline v_3 \newline v_4 \end{bmatrix}<br>$$</p><p>$$<br>\textbf{P} &#x3D;  \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \newline 0 &amp; 0 &amp; 1 &amp; 0 \newline 0 &amp; 0 &amp; 0 &amp; 1 \newline 1 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}<br>$$</p><p> The equation $\textbf{v}&#x3D;\textbf{r}+\gamma\textbf{P}\textbf{v}$ is called Bellman equation.</p><ul><li>Then we can derive Bellman equation from scratch as follows:</li></ul><p>Note that the discounted return random variable $G_t$ can be rewritten as </p><p>$$<br>\begin{aligned}<br>G_t &amp; &#x3D;  R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \cdots\newline<br>&amp; &#x3D;  R_{t+1} + \gamma(R_{t+2}+\gamma R_{t+3} + \cdots) \newline<br>&amp; &#x3D;  R_{t+1} + \gamma G_{t+1}<br>\end{aligned}<br>$$</p><p> where $G_{t+1} &#x3D; R_{t+2} + \gamma R_{t+3} + \cdots$ . This equation establishes the relationship between $G_t$ and $G_{t+1}$. Then the state value can be rewritten as </p><p>$$<br>\begin{aligned}<br>v_\pi(s) &amp; &#x3D;  \mathbb{E}[G_t|S_t&#x3D;s] \newline<br>&amp; &#x3D;  \mathbb{E}[R_{t+1} + \gamma G_{t+1} | S_t&#x3D;s] \newline<br>&amp; &#x3D;  \mathbb{E}[R_{t+1}|S_t&#x3D;s] + \gamma \mathbb{E}[G_{t+1}|S_t&#x3D;s]<br>\quad \text{(linear property of expectation)}<br>\end{aligned}<br>$$</p><p> The <font color = blue> mean of immediate reward</font> can be written as (use 2.3 conditional expectation)</p><p>$$<br>\begin{aligned}<br>\mathbb{E}[R_{t+1}|S_t&#x3D;s] &amp; &#x3D;  \sum_a \pi(a|s) \mathbb{E}[R_{t+1} | S_t&#x3D;s,A_t&#x3D;a] \quad \text{(conditional expectation)}\newline<br>&amp; &#x3D;  \sum_a \pi(a|s) \sum_r p(r|s,a)r<br>\end{aligned}<br>$$</p><p>  The <font color = blue>mean of future reward</font> can be written as </p><p>$$<br>\begin{aligned}<br>\gamma \mathbb{E}[G_{t+1}|S_t&#x3D;s] &amp; &#x3D;  \gamma \sum_a \pi(a|s) \mathbb{E}[G_{t+1}|S_t&#x3D;s, A_t&#x3D;a]\quad \text{(conditional expectation)}\newline<br>&amp; &#x3D;  \gamma \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\newline<br>\end{aligned}<br>$$</p><p>Then the state value can be rewritten as <font color=red>Bellman equation (BE)</font> form </p><p>$$<br>\begin{aligned}<br>v_\pi(s) &amp; &#x3D;  \mathbb{E}[G_t|S_t&#x3D;s] \newline<br>&amp; &#x3D;  \mathbb{E}[R_{t+1}|S_t&#x3D;s] + \gamma \mathbb{E}[G_{t+1}|S_t&#x3D;s] \newline<br>&amp; &#x3D;<br>\sum_a \pi(a|s) \sum_r p(r|s,a)r </p><p>+<br>\gamma \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\newline<br>&amp; &#x3D;  \sum_a \pi(a|s) \Big[\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\Big], \quad \text{for all } s\in\mathcal{S}<br>\end{aligned}<br>$$</p><p>Next, we will introduce the matrix vector form of Bellman equation in terms of state value. Let $v_\pi&#x3D;[v_\pi(s_1),v_\pi(s_2),\cdots]^T\in\mathbb{R}^n$, $r_\pi&#x3D;[r_\pi(s_1),r_\pi(s_2),\cdots]^T\in\mathbb{R}^n$, and $P_\pi\in\mathbb{R}^{n\times n}$. Then we have the matrix-vector form of Bellman equation in terms of state value.</p><p>$$<br>\textcolor{red}{v_\pi &#x3D; r + \gamma P_\pi v_\pi} \quad \text{(matrix-vector form)}<br>$$</p><p>where</p><p>$$<br>[r_\pi]<em>s \triangleq \sum_a \pi(a|s) \sum_r p(r|s,a)r,<br>[P_\pi]</em>{s,s^\prime} &#x3D; \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a)<br>$$</p><h3 id="2-3-Review-conditional-expectaion"><a href="#2-3-Review-conditional-expectaion" class="headerlink" title="2.3 Review conditional expectaion"></a>2.3 Review conditional expectaion</h3><ul><li>The definition of conditional expectation is</li></ul><p>$$<br>\mathbb{E} &#x3D; [X|A&#x3D;a] &#x3D; \sum_{x}xp(x|a)<br>$$</p><p>  Similar to the law of total probability, we have the law of total expectation:</p><p>$$<br>\mathbb{E}[X] &#x3D; \sum_a p(a) \mathbb{E}[X|A&#x3D;a]<br>$$</p><p>  <em>Proof</em></p><p>  By definition of expectation the right hand side can be written as </p><p>$$<br>\begin{aligned}<br>\mathbb{E}[X] &amp; &#x3D;  \sum_a p(a) \sum_x x p(x|a)\newline<br>&amp; &#x3D;  \sum_x \sum_a p(x|a) p(a)  \quad \text{(law of total probability)}\newline<br>&amp; &#x3D;  \sum_x p(x)\newline<br>&amp; &#x3D;  \mathbb{E}[X]<br>\end{aligned}<br>$$</p><h3 id="2-4-Solve-Bellman-Equation"><a href="#2-4-Solve-Bellman-Equation" class="headerlink" title="2.4 Solve Bellman Equation"></a>2.4 Solve Bellman Equation</h3><p>​From the analysis above we are informed that Bellman equation is</p><p>$$<br>\textcolor{blue}{v_\pi(s)&#x3D;\sum_a \pi(a|s) \Big[\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)\Big]}<br>$$</p><p>We can rewrite it into the follow form</p><p>$$<br>v_\pi(s) &#x3D; r_\pi(s) + \gamma \sum_{s^\prime} p_\pi(s^\prime|s) v_\pi(s^\prime)<br>$$</p><p>where</p><p>$$<br>\begin{aligned}<br>r_\pi(s) \triangleq \sum_a \pi(a|s) \sum_r p(r|s,a)r\newline<br>\newline<br>\newline<br>\newline<br>\end{aligned} \qquad<br>\begin{aligned}<br>p_\pi(s^\prime|s) &amp; \triangleq \sum_a \pi(a|s) \sum_{s^\prime} p(s^\prime|s,a)\newline<br>&amp; &#x3D; \sum_{s^\prime} \sum_a \pi(a|s) p(s^\prime|s,a)\newline<br>&amp; &#x3D; p_\pi(s^\prime|s)<br>\end{aligned}<br>$$</p><p>​Suppose the states are indexed as $s_i$. For state $s_i$, the Bellman equation is </p><p>$$<br>v_\pi(s_i) &#x3D; r_\pi(s_i) + \gamma \sum_{s_j} p_\pi(s_j|s_i) v_\pi(s_j)<br>$$</p><p>Let $v_\pi&#x3D;[v_\pi(s_1),\dots,v_\pi(s_n)]^T \in \mathbb{R}^n$, $r_\pi&#x3D;[r_\pi(s_1),\dots,r_\pi(s_n)]^T \in \mathbb{R}^n$, and $P_\pi \in \mathbb{R}^{n\times n}$, where $[P_\pi]_{ij} &#x3D; p_\pi(s_j|s_i)$. Hence we have the matrix form as </p><p>$$<br>v_\pi &#x3D; r_\pi + \gamma P_\pi v_\pi<br>$$</p><p>For example, consider four states $s_i$ and four actions $a_i$ the matrix form can be</p><p>$$<br>\underbrace{<br>\begin{bmatrix}<br>v_\pi(s_1) \newline<br>v_\pi(s_2) \newline<br>v_\pi(s_3) \newline<br>v_\pi(s_4)<br>\end{bmatrix}<br>}<em>{v_\pi} &#x3D;<br>\underbrace{<br>\begin{bmatrix}<br>r_\pi(s_1) \newline<br>r_\pi(s_1) \newline<br>r_\pi(s_1) \newline<br>r_\pi(s_1)<br>\end{bmatrix}<br>}</em>{r_\pi} + \gamma<br>\underbrace{<br>\begin{bmatrix}<br>p_\pi(s_1|s_1) &amp; p_\pi(s_2|s_1) &amp; p_\pi(s_3|s_1) &amp; p_\pi(s_4|s_1) \newline<br>p_\pi(s_1|s_2) &amp; p_\pi(s_2|s_2) &amp; p_\pi(s_3|s_2) &amp; p_\pi(s_4|s_2) \newline<br>p_\pi(s_1|s_3) &amp; p_\pi(s_2|s_3) &amp; p_\pi(s_3|s_3) &amp; p_\pi(s_4|s_3) \newline<br>p_\pi(s_1|s_4) &amp; p_\pi(s_2|s_4) &amp; p_\pi(s_3|s_4) &amp; p_\pi(s_4|s_4) \newline<br>\end{bmatrix}<br>}<em>{P_\pi}<br>\underbrace{<br>\begin{bmatrix}<br>v_\pi(s_1) \newline<br>v_\pi(s_2) \newline<br>v_\pi(s_3) \newline<br>v_\pi(s_4)<br>\end{bmatrix}<br>}</em>{v_\pi}<br>$$</p><p><strong>Conclusions</strong>:</p><ul><li>So we have the <font color=blue>closed form</font> of the solution as $v_\pi &#x3D; (I-\gamma P_\pi)^{-1}r_\pi$. However the inverse operation is hard to implement.</li><li>We seek for other iterative solving methods.</li></ul><p><strong>Iterative solution</strong></p><p>​We can directly sovle the Bellman equation using the following iterative algorithm:</p><p>$$<br>\textcolor{blue}{v_{k+1} &#x3D; r_\pi + \gamma P_\pi v_k}<br>$$</p><p>The proof is omitted.</p><h3 id="2-5-Action-value"><a href="#2-5-Action-value" class="headerlink" title="2.5 Action value"></a>2.5 Action value</h3><p>​<font color=red>Action value</font> is denoted by $q_\pi(s,a)$ which is defined as</p><p>$$<br>q_\pi(s,a) \triangleq \mathbb{E}[G_t|S_t&#x3D;s, A_t&#x3D;a]<br>$$</p><p>for all $s \in \mathcal{S}, a\in \mathcal{A}(s)$. </p><p>Action value can be interpreted as <font color=blue>average return</font> along trajectory generated by <font color=blue>policy $\pi$ </font> after taking a <font color=blue>specific action $a$</font>.</p><p>​From the conditional expectation property that</p><p>$$<br>\underbrace{\mathbb{E}[G_t|S_t&#x3D;s]}<em>{v_\pi(s)} &#x3D; \sum_a \pi(a|s) \underbrace{\mathbb{E}[G_t|S_t&#x3D;s,A_t&#x3D;a]}</em>{q_\pi(s)}<br>$$</p><p>Hence, </p><p>$$<br>v_\pi(s) &#x3D; \sum_a \pi(a|s) q_\pi(s)<br>$$</p><p>So we can obtain the mathematical definition of action value as</p><p>$$<br>\textcolor{blue}{q_\pi(s)&#x3D;\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) v_\pi(s^\prime)}<br>$$</p><p>Substituting $(1)$ into $(2)$ we have</p><p>$$<br>q_\pi(s,a)&#x3D;\sum_r p(r|s,a)r+ \gamma\sum_{s^\prime} p(s^\prime|s,a) \sum_{a^\prime \in \mathcal{A}(s^\prime)}\pi(a^\prime|s^\prime) q_\pi(s^\prime,a^\prime)<br>$$</p><p>​Suppose each state has the same number of actions. The matrix-vecotr form of Bellman eqaution in terms of action value is</p><p>$$<br>\textcolor{red}{q_\pi &#x3D; \tilde{r} + \gamma P \Pi q_\pi}\quad \text{(matrix-vector form)}<br>$$</p><p>where $q_\pi \in \mathbb{R}^{|\mathcal{S}||\mathcal{A}|}$ is the action value vector indexed by state-action pairs. In particular, the $(s,a)$th element is </p><p>$$<br>[q_\pi]_{(s,a)} &#x3D; q_\pi(s,a)<br>$$</p><p>Here, $\tilde{r}\in\mathbb{R}^{|\mathcal{S} ||\mathcal{A} |}$ is the immediate reward vector indexed by state-action pairs. In paricular, the $(s,a)$th reward is</p><p>$$<br>[\tilde{r}]_{(s,a)} &#x3D; \sum_r p(r|s,a)r<br>$$</p><p>Here, $P\in \mathbb{R}^{|\mathcal{S}||\mathcal{A}|\times|\mathcal{S}| }$ is the probability transition matrix, whose row is indexed by state-action pairs and column indexed by states. In particular</p><p>$$<br>[P]_{(s,a),s^\prime} &#x3D; p(s^\prime|s,a)<br>$$</p><p>And $\Pi \in\mathbb{R}^{|\mathcal{S}|\times|\mathcal{S}||\mathcal{A}|}$ describes the policy $\pi$. In particular</p><p>$$<br>\Pi_{s^\prime, (s^\prime,a^\prime)} &#x3D; \pi(a^\prime|s^\prime)<br>$$</p><p>and the other entries of $\Pi$ is zero. $\Pi$ is block diagonal matrix with each block as a $1\times|\mathcal{A}|$ vector.</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>  <a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinforcement Learning with Code [Chapter 1. Basic Concepts]</title>
      <link href="/2023/07/02/Reinforcement-Learning-with-Code-Chapter-1-Basic-Concepts/"/>
      <url>/2023/07/02/Reinforcement-Learning-with-Code-Chapter-1-Basic-Concepts/</url>
      
        <content type="html"><![CDATA[<h1 id="Reinforcement-Learning-with-Code"><a href="#Reinforcement-Learning-with-Code" class="headerlink" title="Reinforcement Learning with Code."></a>Reinforcement Learning with Code.</h1><p>This note record how the author begin to learn RL. Both theoretical understanding and code practice are presented. Many material are referenced such as ZhaoShiyu’s <em>Mathematical Foundation of Reinforcement Learning</em> .</p><h2 id="Chapter-1-Basic-Concepts"><a href="#Chapter-1-Basic-Concepts" class="headerlink" title="Chapter 1. Basic Concepts"></a>Chapter 1. Basic Concepts</h2><h3 id="1-1-State-and-action"><a href="#1-1-State-and-action" class="headerlink" title="1.1 State and action"></a>1.1 State and action</h3><ul><li><font color=red><em>State</em> </font>describe the status of the agent with respect to the environment, denoted by $s$.</li><li><font color=red><em>State space</em> </font> is the set of all states, denoted by $\mathcal{S}&#x3D;{s_1, s_2,\dots,s_n}$.</li><li><font color = red><em>Action</em></font> describe the action that the agent may take with respect to the environment, denoted by $a$.</li><li><font color = red><em>Action space</em></font> is the set of all actions, denoted by $\mathcal{A}&#x3D;{a_1, a_2,\dots,a_n}.$</li></ul><h3 id="1-2-State-transition"><a href="#1-2-State-transition" class="headerlink" title="1.2 State transition"></a>1.2 State transition</h3><p>When taking an action, the agent may move from one state to another. Such a process is called <font color=red><em>state transition</em></font>. State trasition can be denoted by<br>$$<br>s_1 \stackrel{a_2}\longrightarrow s_2<br>$$<br>described by $p(s^\prime|s,a)$.</p><p>State trainsition can be both <em>deterministic</em> and <em>stochastic</em>. For example the deterministic state transition is<br>$$<br>p(s_1|s_1,a_2) &#x3D; 0 \<br>p(s_2|s_1,a_2) &#x3D; 1 \<br>p(s_3|s_1,a_2) &#x3D; 0<br>$$<br>For example the stochastic state transition is<br>$$<br>p(s_1|s_1,a_2) &#x3D; 0.5 \<br>p(s_2|s_1,a_2) &#x3D; 0.3 \<br>p(s_3|s_1,a_2) &#x3D; 0.2<br>$$</p><h3 id="1-3-Policy"><a href="#1-3-Policy" class="headerlink" title="1.3 Policy"></a>1.3 Policy</h3><ul><li><font color = red><em>Policy</em></font> tells the agents which actions to take <font color=blue>at each state</font>, denoted by $\pi$.</li><li>Policy is described by conditional probability.</li><li>Policy can be <em>deterministic</em> or <em>stochastic</em>, which means one state has a deterministic action or one state has probability to select other actions.</li></ul><p>Suppose the actions space is $\mathcal{A}&#x3D;{a_1, a_2,a_3}$, such  deterministic policy can be dentoed by<br>$$<br>\pi(a_1|s_1) &#x3D; 0 \<br>\pi(a_2|s_1) &#x3D; 1 \<br>\pi(a_3|s_1) &#x3D; 0<br>$$<br>which indicated the probability of taking action $a_2$ is $1$ and others are zero. </p><p>Such stochastic policy can be denoted by<br>$$<br>\pi(a_1|s_1) &#x3D; 0.5 \<br>\pi(a_2|s_1) &#x3D; 0.3 \<br>\pi(a_3|s_1) &#x3D; 0.2<br>$$</p><h3 id="1-4-Reward"><a href="#1-4-Reward" class="headerlink" title="1.4 Reward"></a>1.4 Reward</h3><ul><li><font color = red><em>Reward</em></font> is one of the most unique concept in RL.</li><li><font color = red><em>Immediate reward</em></font> can be obtained after taking an action.</li><li><font color = red><em>Reward transition</em></font> is the process of getting a reward after taking an action, reward transition can be <em>deterministic</em> or <em>stochastic</em>. Reward transition is described by $p(r|s,a)$</li></ul><p>For example deterministic reward transition can be denoted by<br>$$<br>p(r&#x3D;-1|s_1,a_2) &#x3D; 1, p(r\ne -1|s_1,a_2)&#x3D;0<br>$$<br>which means at state $s_1$ take action $a_2$ the probability to get immediate reward $-1$ is $1$.</p><p>Stochastic reward transition can be denoted by<br>$$<br>p(r&#x3D;1|s_1,a_2) &#x3D; 0.5, p(r&#x3D; 0|s_1,a_2)&#x3D;0.5<br>$$<br>which means at state $s_1$ take action $a_2$ the probability to get immediate reward $1$ is $0.5$, the probability to get immediate reward $0$ is $0.5$.</p><h3 id="1-5-Trajectory-return-episode"><a href="#1-5-Trajectory-return-episode" class="headerlink" title="1.5 Trajectory, return, episode"></a>1.5 Trajectory, return, episode</h3><ul><li><p><font color = red><em>Trajectory</em></font> is a state-action-reward chain, such as $s_1 \underset{r&#x3D;0}{\xrightarrow{a_2}} s_2 \underset{r&#x3D;0}{\xrightarrow{a_3}} s_3 \underset{r&#x3D;0}{\xrightarrow{a_4}} \cdots\underset{r&#x3D;1}{\xrightarrow{a_n}} s_{n}$.</p></li><li><p><font color = red><em>Return</em></font> of this trajecotry is the sum of all the rewards collected along the trajectory, such as $\text{return} &#x3D; 0+0+0+\cdots+1&#x3D;1$. Return is also called <font color=blue><em>total rewards</em></font> or <font color=blue><em>cumulative rewards</em></font>.</p></li><li><p><font color = red><em>Discounted return</em></font> is defined by the <font color=blue><em>discounted rate</em></font>, denoted by $\gamma\in(0,1)$. Such discounted retrun is<br>$$<br>\text{discounted return} &#x3D; 0+\gamma0+\gamma^2 0 + \gamma^3 0 + \cdots + \gamma^n 1<br>$$</p></li><li><p><font color = red><em>Episode</em></font> refers the trajectory that interacting with the enviornment following a policy <font color = blue>until the agent reach the terminal state</font>. An episode is usually assumed to be a finite trajectory,  that task with episodes are called <em>episodic tasks</em>. Some task may have no terminal state, such task is called <em>continuing tasks</em>.</p></li></ul><h3 id="1-6-Markov-decision-process-MDP"><a href="#1-6-Markov-decision-process-MDP" class="headerlink" title="1.6 Markov decision process (MDP)"></a>1.6 Markov decision process (MDP)</h3><p>Markov decision process is a general framework to <font color=blue>describe stochastic dynamical systems</font>. The key ingredients of an MDP are listed:</p><ul><li><p>Sets:</p><ul><li>State set: the set of all states, denoted as $\mathcal{S}$.</li><li>Actions set: a set of actions, denoted as $\mathcal{A}(s)$, is associated for each state $s\in\mathcal{S}$.</li><li>Reward set: a set of rewards, denoted as $\mathcal{R}(s,a)$, is associated for each state action pari $(s,a)$.</li></ul></li><li><p>Model:</p><ul><li>State transition probability: at state $s$, taking actions $a$, the probability to transit to state $s^\prime$ is $p(s^\prime|s,a)$.</li><li>Reward transition probability: at state $s$, taking action $a$, the probability to get reward $r$ is $p(r|s,a)$.</li></ul></li><li><p>Policy: as state $s$, the probability to choose action $a$ is $\pi(a|s)$.</p></li><li><p>Markov property: one key property of MDPs is the <em>Markov property</em>, which refers to the <font color=blue>memoryless property</font> of a stochastic process, which means<br>$$<br>p(s_{t+1}|s_t,a_t,s_{t-1},a_{t-1},\dots,s_0,a_0)&#x3D;p(s_{t+1}|s_t,a_t)\<br>p(r_{t+1}|s_t,a_t,s_{t-1},a_{t-1},\dots,s_0,a_0)&#x3D;p(r_{t+1}|s_t,a_t)\<br>$$</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0">赵世钰老师的课程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Reinforcement Learning </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
